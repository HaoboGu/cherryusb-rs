/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const CHERRYUSB_VERSION: u32 = 66305;
pub const CHERRYUSB_VERSION_STR: &[u8; 7] = b"v1.3.1\0";
pub const CONFIG_USB_ALIGN_SIZE: u32 = 4;
pub const CONFIG_USBDEV_REQUEST_BUFFER_LEN: u32 = 512;
pub const CONFIG_USBDEV_MSC_MAX_LUN: u32 = 1;
pub const CONFIG_USBDEV_MSC_MAX_BUFSIZE: u32 = 512;
pub const CONFIG_USBDEV_MSC_MANUFACTURER_STRING: &[u8; 1] = b"\0";
pub const CONFIG_USBDEV_MSC_PRODUCT_STRING: &[u8; 1] = b"\0";
pub const CONFIG_USBDEV_MSC_VERSION_STRING: &[u8; 5] = b"0.01\0";
pub const CONFIG_USBDEV_MSC_PRIO: u32 = 4;
pub const CONFIG_USBDEV_MSC_STACKSIZE: u32 = 2048;
pub const CONFIG_USBDEV_RNDIS_RESP_BUFFER_SIZE: u32 = 156;
pub const CONFIG_USBDEV_RNDIS_ETH_MAX_FRAME_SIZE: u32 = 1580;
pub const CONFIG_USBDEV_RNDIS_VENDOR_ID: u32 = 65535;
pub const CONFIG_USBDEV_RNDIS_VENDOR_DESC: &[u8; 10] = b"CherryUSB\0";
pub const CONFIG_USBHOST_MAX_RHPORTS: u32 = 1;
pub const CONFIG_USBHOST_MAX_EXTHUBS: u32 = 1;
pub const CONFIG_USBHOST_MAX_EHPORTS: u32 = 4;
pub const CONFIG_USBHOST_MAX_INTERFACES: u32 = 8;
pub const CONFIG_USBHOST_MAX_INTF_ALTSETTINGS: u32 = 8;
pub const CONFIG_USBHOST_MAX_ENDPOINTS: u32 = 4;
pub const CONFIG_USBHOST_MAX_CDC_ACM_CLASS: u32 = 4;
pub const CONFIG_USBHOST_MAX_HID_CLASS: u32 = 4;
pub const CONFIG_USBHOST_MAX_MSC_CLASS: u32 = 2;
pub const CONFIG_USBHOST_MAX_AUDIO_CLASS: u32 = 1;
pub const CONFIG_USBHOST_MAX_VIDEO_CLASS: u32 = 1;
pub const CONFIG_USBHOST_DEV_NAMELEN: u32 = 16;
pub const CONFIG_USBHOST_PSC_PRIO: u32 = 0;
pub const CONFIG_USBHOST_PSC_STACKSIZE: u32 = 2048;
pub const CONFIG_USBHOST_MSOS_VENDOR_CODE: u32 = 0;
pub const CONFIG_USBHOST_REQUEST_BUFFER_LEN: u32 = 512;
pub const CONFIG_USBHOST_CONTROL_TRANSFER_TIMEOUT: u32 = 500;
pub const CONFIG_USBHOST_MSC_TIMEOUT: u32 = 5000;
pub const CONFIG_USBHOST_RNDIS_ETH_MAX_RX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_RNDIS_ETH_MAX_TX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_CDC_NCM_ETH_MAX_RX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_CDC_NCM_ETH_MAX_TX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_ASIX_ETH_MAX_RX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_ASIX_ETH_MAX_TX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_RTL8152_ETH_MAX_RX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_RTL8152_ETH_MAX_TX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_BLUETOOTH_TX_SIZE: u32 = 2048;
pub const CONFIG_USBHOST_BLUETOOTH_RX_SIZE: u32 = 2048;
pub const CONFIG_USBDEV_MAX_BUS: u32 = 1;
pub const CONFIG_USBDEV_EP_NUM: u32 = 8;
pub const CONFIG_USBDEV_FSDEV_PMA_ACCESS: u32 = 2;
pub const CONFIG_USB_DWC2_RXALL_FIFO_SIZE: u32 = 256;
pub const CONFIG_USB_DWC2_TX0_FIFO_SIZE: u32 = 16;
pub const CONFIG_USB_DWC2_TX1_FIFO_SIZE: u32 = 128;
pub const CONFIG_USB_DWC2_TX2_FIFO_SIZE: u32 = 16;
pub const CONFIG_USB_DWC2_TX3_FIFO_SIZE: u32 = 16;
pub const CONFIG_USB_DWC2_TX4_FIFO_SIZE: u32 = 0;
pub const CONFIG_USB_DWC2_TX5_FIFO_SIZE: u32 = 0;
pub const CONFIG_USB_DWC2_TX6_FIFO_SIZE: u32 = 0;
pub const CONFIG_USB_DWC2_TX7_FIFO_SIZE: u32 = 0;
pub const CONFIG_USB_DWC2_TX8_FIFO_SIZE: u32 = 0;
pub const CONFIG_USBHOST_MAX_BUS: u32 = 1;
pub const CONFIG_USBHOST_PIPE_NUM: u32 = 10;
pub const CONFIG_USB_EHCI_HCCR_OFFSET: u32 = 0;
pub const CONFIG_USB_EHCI_FRAME_LIST_SIZE: u32 = 1024;
pub const CONFIG_USB_EHCI_QH_NUM: u32 = 10;
pub const CONFIG_USB_EHCI_QTD_NUM: u32 = 3;
pub const CONFIG_USB_EHCI_ITD_NUM: u32 = 20;
pub const CONFIG_USB_OHCI_HCOR_OFFSET: u32 = 0;
pub const CONFIG_USB_XHCI_HCCR_OFFSET: u32 = 0;
pub const CONFIG_USB_DWC2_NPTX_FIFO_SIZE: u32 = 128;
pub const CONFIG_USB_DWC2_PTX_FIFO_SIZE: u32 = 256;
pub const CONFIG_USB_DWC2_RX_FIFO_SIZE: u32 = 157;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 17] = b"@NEWLIB_VERSION@\0";
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 0;
pub const __OBSOLETE_MATH: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const USB_ERR_NOMEM: u32 = 1;
pub const USB_ERR_INVAL: u32 = 2;
pub const USB_ERR_NODEV: u32 = 3;
pub const USB_ERR_NOTCONN: u32 = 4;
pub const USB_ERR_NOTSUPP: u32 = 5;
pub const USB_ERR_BUSY: u32 = 6;
pub const USB_ERR_RANGE: u32 = 7;
pub const USB_ERR_STALL: u32 = 8;
pub const USB_ERR_BABBLE: u32 = 9;
pub const USB_ERR_NAK: u32 = 10;
pub const USB_ERR_DT: u32 = 11;
pub const USB_ERR_IO: u32 = 12;
pub const USB_ERR_SHUTDOWN: u32 = 13;
pub const USB_ERR_TIMEOUT: u32 = 14;
pub const USB_1_1: u32 = 272;
pub const USB_2_0: u32 = 512;
pub const USB_2_1: u32 = 528;
pub const USB_3_0: u32 = 768;
pub const USB_3_1: u32 = 784;
pub const USB_3_2: u32 = 800;
pub const USB_SPEED_UNKNOWN: u32 = 0;
pub const USB_SPEED_LOW: u32 = 1;
pub const USB_SPEED_FULL: u32 = 2;
pub const USB_SPEED_HIGH: u32 = 3;
pub const USB_SPEED_WIRELESS: u32 = 4;
pub const USB_SPEED_SUPER: u32 = 5;
pub const USB_SPEED_SUPER_PLUS: u32 = 6;
pub const USB_MAX_DEVICES: u32 = 127;
pub const USB_CONTROL_OUT_EP0: u32 = 0;
pub const USB_CONTROL_IN_EP0: u32 = 128;
pub const USB_CTRL_EP_MPS: u32 = 64;
pub const USB_BULK_EP_MPS_HS: u32 = 512;
pub const USB_BULK_EP_MPS_FS: u32 = 64;
pub const USB_PID_OUT: u32 = 1;
pub const USB_PID_IN: u32 = 9;
pub const USB_PID_SOF: u32 = 5;
pub const USB_PID_SETUP: u32 = 13;
pub const USB_PID_DATA0: u32 = 3;
pub const USB_PID_DATA1: u32 = 11;
pub const USB_PID_DATA2: u32 = 7;
pub const USB_PID_MDATA: u32 = 15;
pub const USB_PID_ACK: u32 = 2;
pub const USB_PID_NAK: u32 = 10;
pub const USB_PID_STALL: u32 = 14;
pub const USB_PID_NYET: u32 = 6;
pub const USB_PID_PRE: u32 = 12;
pub const USB_PID_ERR: u32 = 12;
pub const USB_PID_SPLIT: u32 = 8;
pub const USB_PID_PING: u32 = 4;
pub const USB_PID_RESERVED: u32 = 0;
pub const USB_REQUEST_DIR_SHIFT: u32 = 7;
pub const USB_REQUEST_DIR_OUT: u32 = 0;
pub const USB_REQUEST_DIR_IN: u32 = 128;
pub const USB_REQUEST_DIR_MASK: u32 = 128;
pub const USB_REQUEST_TYPE_SHIFT: u32 = 5;
pub const USB_REQUEST_STANDARD: u32 = 0;
pub const USB_REQUEST_CLASS: u32 = 32;
pub const USB_REQUEST_VENDOR: u32 = 64;
pub const USB_REQUEST_RESERVED: u32 = 96;
pub const USB_REQUEST_TYPE_MASK: u32 = 96;
pub const USB_REQUEST_RECIPIENT_SHIFT: u32 = 0;
pub const USB_REQUEST_RECIPIENT_DEVICE: u32 = 0;
pub const USB_REQUEST_RECIPIENT_INTERFACE: u32 = 1;
pub const USB_REQUEST_RECIPIENT_ENDPOINT: u32 = 2;
pub const USB_REQUEST_RECIPIENT_OTHER: u32 = 3;
pub const USB_REQUEST_RECIPIENT_MASK: u32 = 3;
pub const USB_REQUEST_GET_STATUS: u32 = 0;
pub const USB_REQUEST_CLEAR_FEATURE: u32 = 1;
pub const USB_REQUEST_SET_FEATURE: u32 = 3;
pub const USB_REQUEST_SET_ADDRESS: u32 = 5;
pub const USB_REQUEST_GET_DESCRIPTOR: u32 = 6;
pub const USB_REQUEST_SET_DESCRIPTOR: u32 = 7;
pub const USB_REQUEST_GET_CONFIGURATION: u32 = 8;
pub const USB_REQUEST_SET_CONFIGURATION: u32 = 9;
pub const USB_REQUEST_GET_INTERFACE: u32 = 10;
pub const USB_REQUEST_SET_INTERFACE: u32 = 11;
pub const USB_REQUEST_SYNCH_FRAME: u32 = 12;
pub const USB_REQUEST_SET_ENCRYPTION: u32 = 13;
pub const USB_REQUEST_GET_ENCRYPTION: u32 = 14;
pub const USB_REQUEST_RPIPE_ABORT: u32 = 14;
pub const USB_REQUEST_SET_HANDSHAKE: u32 = 15;
pub const USB_REQUEST_RPIPE_RESET: u32 = 15;
pub const USB_REQUEST_GET_HANDSHAKE: u32 = 16;
pub const USB_REQUEST_SET_CONNECTION: u32 = 17;
pub const USB_REQUEST_SET_SECURITY_DATA: u32 = 18;
pub const USB_REQUEST_GET_SECURITY_DATA: u32 = 19;
pub const USB_REQUEST_SET_WUSB_DATA: u32 = 20;
pub const USB_REQUEST_LOOPBACK_DATA_WRITE: u32 = 21;
pub const USB_REQUEST_LOOPBACK_DATA_READ: u32 = 22;
pub const USB_REQUEST_SET_INTERFACE_DS: u32 = 23;
pub const USB_FEATURE_ENDPOINT_HALT: u32 = 0;
pub const USB_FEATURE_SELF_POWERED: u32 = 0;
pub const USB_FEATURE_REMOTE_WAKEUP: u32 = 1;
pub const USB_FEATURE_TEST_MODE: u32 = 2;
pub const USB_FEATURE_BATTERY: u32 = 2;
pub const USB_FEATURE_BHNPENABLE: u32 = 3;
pub const USB_FEATURE_WUSBDEVICE: u32 = 3;
pub const USB_FEATURE_AHNPSUPPORT: u32 = 4;
pub const USB_FEATURE_AALTHNPSUPPORT: u32 = 5;
pub const USB_FEATURE_DEBUGMODE: u32 = 6;
pub const USB_GETSTATUS_ENDPOINT_HALT: u32 = 1;
pub const USB_GETSTATUS_SELF_POWERED: u32 = 1;
pub const USB_GETSTATUS_REMOTE_WAKEUP: u32 = 2;
pub const USB_DESCRIPTOR_TYPE_DEVICE: u32 = 1;
pub const USB_DESCRIPTOR_TYPE_CONFIGURATION: u32 = 2;
pub const USB_DESCRIPTOR_TYPE_STRING: u32 = 3;
pub const USB_DESCRIPTOR_TYPE_INTERFACE: u32 = 4;
pub const USB_DESCRIPTOR_TYPE_ENDPOINT: u32 = 5;
pub const USB_DESCRIPTOR_TYPE_DEVICE_QUALIFIER: u32 = 6;
pub const USB_DESCRIPTOR_TYPE_OTHER_SPEED: u32 = 7;
pub const USB_DESCRIPTOR_TYPE_INTERFACE_POWER: u32 = 8;
pub const USB_DESCRIPTOR_TYPE_OTG: u32 = 9;
pub const USB_DESCRIPTOR_TYPE_DEBUG: u32 = 10;
pub const USB_DESCRIPTOR_TYPE_INTERFACE_ASSOCIATION: u32 = 11;
pub const USB_DESCRIPTOR_TYPE_BINARY_OBJECT_STORE: u32 = 15;
pub const USB_DESCRIPTOR_TYPE_DEVICE_CAPABILITY: u32 = 16;
pub const USB_DESCRIPTOR_TYPE_WIRELESS_ENDPOINTCOMP: u32 = 17;
pub const USB_CS_DESCRIPTOR_TYPE_DEVICE: u32 = 33;
pub const USB_CS_DESCRIPTOR_TYPE_CONFIGURATION: u32 = 34;
pub const USB_CS_DESCRIPTOR_TYPE_STRING: u32 = 35;
pub const USB_CS_DESCRIPTOR_TYPE_INTERFACE: u32 = 36;
pub const USB_CS_DESCRIPTOR_TYPE_ENDPOINT: u32 = 37;
pub const USB_DESCRIPTOR_TYPE_SUPERSPEED_ENDPOINT_COMPANION: u32 = 48;
pub const USB_DESCRIPTOR_TYPE_SUPERSPEED_ISO_ENDPOINT_COMPANION: u32 = 49;
pub const USB_DEVICE_CLASS_RESERVED: u32 = 0;
pub const USB_DEVICE_CLASS_AUDIO: u32 = 1;
pub const USB_DEVICE_CLASS_CDC: u32 = 2;
pub const USB_DEVICE_CLASS_HID: u32 = 3;
pub const USB_DEVICE_CLASS_MONITOR: u32 = 4;
pub const USB_DEVICE_CLASS_PHYSICAL: u32 = 5;
pub const USB_DEVICE_CLASS_IMAGE: u32 = 6;
pub const USB_DEVICE_CLASS_PRINTER: u32 = 7;
pub const USB_DEVICE_CLASS_MASS_STORAGE: u32 = 8;
pub const USB_DEVICE_CLASS_HUB: u32 = 9;
pub const USB_DEVICE_CLASS_CDC_DATA: u32 = 10;
pub const USB_DEVICE_CLASS_SMART_CARD: u32 = 11;
pub const USB_DEVICE_CLASS_SECURITY: u32 = 13;
pub const USB_DEVICE_CLASS_VIDEO: u32 = 14;
pub const USB_DEVICE_CLASS_HEALTHCARE: u32 = 15;
pub const USB_DEVICE_CLASS_DIAG_DEVICE: u32 = 220;
pub const USB_DEVICE_CLASS_WIRELESS: u32 = 224;
pub const USB_DEVICE_CLASS_MISC: u32 = 239;
pub const USB_DEVICE_CLASS_APP_SPECIFIC: u32 = 254;
pub const USB_DEVICE_CLASS_VEND_SPECIFIC: u32 = 255;
pub const USB_STRING_LANGID_INDEX: u32 = 0;
pub const USB_STRING_MFC_INDEX: u32 = 1;
pub const USB_STRING_PRODUCT_INDEX: u32 = 2;
pub const USB_STRING_SERIAL_INDEX: u32 = 3;
pub const USB_STRING_CONFIG_INDEX: u32 = 4;
pub const USB_STRING_INTERFACE_INDEX: u32 = 5;
pub const USB_STRING_OS_INDEX: u32 = 6;
pub const USB_STRING_MAX: u32 = 6;
pub const USB_OSDESC_STRING_DESC_INDEX: u32 = 238;
pub const USB_CONFIG_REMOTE_WAKEUP: u32 = 32;
pub const USB_CONFIG_POWERED_MASK: u32 = 64;
pub const USB_CONFIG_BUS_POWERED: u32 = 128;
pub const USB_CONFIG_SELF_POWERED: u32 = 192;
pub const USB_ENDPOINT_DIRECTION_MASK: u32 = 128;
pub const USB_EP_DIR_MASK: u32 = 128;
pub const USB_EP_DIR_IN: u32 = 128;
pub const USB_EP_DIR_OUT: u32 = 0;
pub const USB_ENDPOINT_TYPE_SHIFT: u32 = 0;
pub const USB_ENDPOINT_TYPE_CONTROL: u32 = 0;
pub const USB_ENDPOINT_TYPE_ISOCHRONOUS: u32 = 1;
pub const USB_ENDPOINT_TYPE_BULK: u32 = 2;
pub const USB_ENDPOINT_TYPE_INTERRUPT: u32 = 3;
pub const USB_ENDPOINT_TYPE_MASK: u32 = 3;
pub const USB_ENDPOINT_SYNC_SHIFT: u32 = 2;
pub const USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION: u32 = 0;
pub const USB_ENDPOINT_SYNC_ASYNCHRONOUS: u32 = 4;
pub const USB_ENDPOINT_SYNC_ADAPTIVE: u32 = 8;
pub const USB_ENDPOINT_SYNC_SYNCHRONOUS: u32 = 12;
pub const USB_ENDPOINT_SYNC_MASK: u32 = 12;
pub const USB_ENDPOINT_USAGE_SHIFT: u32 = 4;
pub const USB_ENDPOINT_USAGE_DATA: u32 = 0;
pub const USB_ENDPOINT_USAGE_FEEDBACK: u32 = 16;
pub const USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK: u32 = 32;
pub const USB_ENDPOINT_USAGE_MASK: u32 = 48;
pub const USB_ENDPOINT_MAX_ADJUSTABLE: u32 = 128;
pub const USB_MAXPACKETSIZE_SHIFT: u32 = 0;
pub const USB_MAXPACKETSIZE_MASK: u32 = 2047;
pub const USB_MAXPACKETSIZE_ADDITIONAL_TRANSCATION_SHIFT: u32 = 11;
pub const USB_MAXPACKETSIZE_ADDITIONAL_TRANSCATION_NONE: u32 = 0;
pub const USB_MAXPACKETSIZE_ADDITIONAL_TRANSCATION_ONE: u32 = 2048;
pub const USB_MAXPACKETSIZE_ADDITIONAL_TRANSCATION_TWO: u32 = 4096;
pub const USB_MAXPACKETSIZE_ADDITIONAL_TRANSCATION_MASK: u32 = 6144;
pub const USB_DEVICE_CAPABILITY_WIRELESS_USB: u32 = 1;
pub const USB_DEVICE_CAPABILITY_USB_2_0_EXTENSION: u32 = 2;
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB: u32 = 3;
pub const USB_DEVICE_CAPABILITY_CONTAINER_ID: u32 = 4;
pub const USB_DEVICE_CAPABILITY_PLATFORM: u32 = 5;
pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY_CAPABILITY: u32 = 6;
pub const USB_DEVICE_CAPABILITY_BATTERY_INFO_CAPABILITY: u32 = 7;
pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_CAPABILITY: u32 = 8;
pub const USB_DEVICE_CAPABILITY_PD_PROVIDER_PORT_CAPABILITY: u32 = 9;
pub const USB_DEVICE_CAPABILITY_SUPERSPEED_PLUS: u32 = 10;
pub const USB_DEVICE_CAPABILITY_PRECISION_TIME_MEASUREMENT: u32 = 11;
pub const USB_DEVICE_CAPABILITY_WIRELESS_USB_EXT: u32 = 12;
pub const USB_BOS_CAPABILITY_EXTENSION: u32 = 2;
pub const USB_BOS_CAPABILITY_PLATFORM: u32 = 5;
pub const USB_OTG_FEATURE_B_HNP_ENABLE: u32 = 3;
pub const USB_OTG_FEATURE_A_HNP_SUPPORT: u32 = 4;
pub const USB_OTG_FEATURE_A_ALT_HNP_SUPPORT: u32 = 5;
pub const WINUSB_REQUEST_GET_DESCRIPTOR_SET: u32 = 7;
pub const WINUSB_REQUEST_SET_ALT_ENUM: u32 = 8;
pub const WINUSB_DESCRIPTOR_SET_HEADER_SIZE: u32 = 10;
pub const WINUSB_FUNCTION_SUBSET_HEADER_SIZE: u32 = 8;
pub const WINUSB_FEATURE_COMPATIBLE_ID_SIZE: u32 = 20;
pub const WINUSB_SET_HEADER_DESCRIPTOR_TYPE: u32 = 0;
pub const WINUSB_SUBSET_HEADER_CONFIGURATION_TYPE: u32 = 1;
pub const WINUSB_SUBSET_HEADER_FUNCTION_TYPE: u32 = 2;
pub const WINUSB_FEATURE_COMPATIBLE_ID_TYPE: u32 = 3;
pub const WINUSB_FEATURE_REG_PROPERTY_TYPE: u32 = 4;
pub const WINUSB_FEATURE_MIN_RESUME_TIME_TYPE: u32 = 5;
pub const WINUSB_FEATURE_MODEL_ID_TYPE: u32 = 6;
pub const WINUSB_FEATURE_CCGP_DEVICE_TYPE: u32 = 7;
pub const WINUSB_PROP_DATA_TYPE_REG_SZ: u32 = 1;
pub const WINUSB_PROP_DATA_TYPE_REG_MULTI_SZ: u32 = 7;
pub const WEBUSB_DESCRIPTOR_SET_HEADER_TYPE: u32 = 0;
pub const WEBUSB_CONFIGURATION_SUBSET_HEADER_TYPE: u32 = 1;
pub const WEBUSB_FUNCTION_SUBSET_HEADER_TYPE: u32 = 2;
pub const WEBUSB_URL_TYPE: u32 = 3;
pub const WEBUSB_REQUEST_GET_URL: u32 = 2;
pub const WEBUSB_URL_SCHEME_HTTP: u32 = 0;
pub const WEBUSB_URL_SCHEME_HTTPS: u32 = 1;
pub const WEBUSB_DESCRIPTOR_SET_HEADER_SIZE: u32 = 5;
pub const WEBUSB_CONFIGURATION_SUBSET_HEADER_SIZE: u32 = 4;
pub const WEBUSB_FUNCTION_SUBSET_HEADER_SIZE: u32 = 3;
pub const USB_SIZEOF_SETUP_PACKET: u32 = 8;
pub const USB_SIZEOF_DEVICE_DESC: u32 = 18;
pub const USB_SIZEOF_CONFIG_DESC: u32 = 9;
pub const USB_SIZEOF_INTERFACE_DESC: u32 = 9;
pub const USB_SIZEOF_ENDPOINT_DESC: u32 = 7;
pub const USB_SIZEOF_STRING_LANGID_DESC: u32 = 4;
pub const USB_SIZEOF_IAD_DESC: u32 = 8;
pub const USB_SIZEOF_DEVICE_QUALIFIER_DESC: u32 = 10;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const USB_DBG_ERROR: u32 = 0;
pub const USB_DBG_WARNING: u32 = 1;
pub const USB_DBG_INFO: u32 = 2;
pub const USB_DBG_LOG: u32 = 3;
pub const USB_DBG_TAG: &[u8; 4] = b"USB\0";
pub const USB_OSAL_WAITING_FOREVER: u32 = 4294967295;
pub const HUB_DESCRIPTOR_TYPE_HUB: u32 = 41;
pub const HUB_DESCRIPTOR_TYPE_HUB3: u32 = 42;
pub const HUB_MAX_DEPTH: u32 = 5;
pub const HUB_SUBCLASS: u32 = 0;
pub const HUB_PROTOCOL_STT: u32 = 1;
pub const HUB_PROTOCOL_MTT: u32 = 2;
pub const HUB_REQUEST_GET_STATUS: u32 = 0;
pub const HUB_REQUEST_CLEAR_FEATURE: u32 = 1;
pub const HUB_REQUEST_SET_FEATURE: u32 = 3;
pub const HUB_REQUEST_GET_DESCRIPTOR: u32 = 6;
pub const HUB_REQUEST_SET_DESCRIPTOR: u32 = 7;
pub const HUB_REQUEST_CLEAR_TT_BUFFER: u32 = 8;
pub const HUB_REQUEST_RESET_TT: u32 = 9;
pub const HUB_REQUEST_GET_TT_STATE: u32 = 10;
pub const HUB_REQUEST_STOP_TT: u32 = 11;
pub const HUB_REQUEST_SET_HUB_DEPTH: u32 = 12;
pub const HUB_FEATURE_HUB_C_LOCALPOWER: u32 = 0;
pub const HUB_FEATURE_HUB_C_OVERCURRENT: u32 = 1;
pub const HUB_PORT_FEATURE_CONNECTION: u32 = 0;
pub const HUB_PORT_FEATURE_ENABLE: u32 = 1;
pub const HUB_PORT_FEATURE_SUSPEND: u32 = 2;
pub const HUB_PORT_FEATURE_OVERCURRENT: u32 = 3;
pub const HUB_PORT_FEATURE_RESET: u32 = 4;
pub const HUB_PORT_FEATURE_L1: u32 = 5;
pub const HUB_PORT_FEATURE_POWER: u32 = 8;
pub const HUB_PORT_FEATURE_POWER_SS: u32 = 9;
pub const HUB_PORT_FEATURE_LOWSPEED: u32 = 9;
pub const HUB_PORT_FEATURE_HIGHSPEED: u32 = 10;
pub const HUB_PORT_FEATURE_TEST: u32 = 11;
pub const HUB_PORT_FEATURE_INDICATOR: u32 = 12;
pub const HUB_PORT_FEATURE_C_CONNECTION: u32 = 16;
pub const HUB_PORT_FEATURE_C_ENABLE: u32 = 17;
pub const HUB_PORT_FEATURE_C_SUSPEND: u32 = 18;
pub const HUB_PORT_FEATURE_C_OVER_CURREN: u32 = 19;
pub const HUB_PORT_FEATURE_C_RESET: u32 = 20;
pub const HUB_PORT_FEATURE_C_BH_RESET: u32 = 21;
pub const HUB_PORT_FEATURE_C_LINK_STATE: u32 = 22;
pub const HUB_PORT_FEATURE_C_CONFIG_ERR: u32 = 23;
pub const HUB_STATUS_LOCALPOWER: u32 = 1;
pub const HUB_STATUS_OVERCURRENT: u32 = 2;
pub const HUB_STATUS_C_LOCALPOWER: u32 = 1;
pub const HUB_STATUS_C_OVERCURRENT: u32 = 2;
pub const HUB_PORT_STATUS_CONNECTION: u32 = 1;
pub const HUB_PORT_STATUS_ENABLE: u32 = 2;
pub const HUB_PORT_STATUS_SUSPEND: u32 = 4;
pub const HUB_PORT_STATUS_OVERCURRENT: u32 = 8;
pub const HUB_PORT_STATUS_RESET: u32 = 16;
pub const HUB_PORT_STATUS_L1: u32 = 32;
pub const HUB_PORT_STATUS_LS_U0: u32 = 0;
pub const HUB_PORT_STATUS_LS_U1: u32 = 32;
pub const HUB_PORT_STATUS_LS_U2: u32 = 64;
pub const HUB_PORT_STATUS_LS_U3: u32 = 96;
pub const HUB_PORT_STATUS_LS_SS_DISABLED: u32 = 128;
pub const HUB_PORT_STATUS_LS_RX_DETECT: u32 = 160;
pub const HUB_PORT_STATUS_LS_SS_INACTIVE: u32 = 192;
pub const HUB_PORT_STATUS_LS_POLLING: u32 = 224;
pub const HUB_PORT_STATUS_LS_RECOVERY: u32 = 256;
pub const HUB_PORT_STATUS_LS_HOT_RESET: u32 = 288;
pub const HUB_PORT_STATUS_LS_COMP_MOD: u32 = 320;
pub const HUB_PORT_STATUS_LS_LOOPBACK: u32 = 352;
pub const HUB_PORT_STATUS_POWER: u32 = 256;
pub const HUB_PORT_STATUS_POWER_SS: u32 = 512;
pub const HUB_PORT_STATUS_LOW_SPEED: u32 = 512;
pub const HUB_PORT_STATUS_HIGH_SPEED: u32 = 1024;
pub const HUB_PORT_STATUS_TEST: u32 = 2048;
pub const HUB_PORT_STATUS_INDICATOR: u32 = 4096;
pub const HUB_PORT_STATUS_C_CONNECTION: u32 = 1;
pub const HUB_PORT_STATUS_C_ENABLE: u32 = 2;
pub const HUB_PORT_STATUS_C_SUSPEND: u32 = 4;
pub const HUB_PORT_STATUS_C_OVERCURRENT: u32 = 8;
pub const HUB_PORT_STATUS_C_RESET: u32 = 16;
pub const HUB_PORT_STATUS_C_L1: u32 = 32;
pub const HUB_PORT_STATUS_C_BH_RESET: u32 = 32;
pub const HUB_PORT_STATUS_C_PORTLINK: u32 = 64;
pub const HUB_PORT_STATUS_C_CONFIGERR: u32 = 128;
pub const HUB_CHAR_LPSM_SHIFT: u32 = 0;
pub const HUB_CHAR_LPSM_MASK: u32 = 3;
pub const HUB_CHAR_LPSM_GANGED: u32 = 0;
pub const HUB_CHAR_LPSM_INDIVIDUAL: u32 = 1;
pub const HUB_CHAR_COMPOUND: u32 = 4;
pub const HUB_CHAR_OCPM_SHIFT: u32 = 3;
pub const HUB_CHAR_OCPM_MASK: u32 = 24;
pub const HUB_CHAR_OCPM_GLOBAL: u32 = 0;
pub const HUB_CHAR_OCPM_INDIVIDUAL: u32 = 8;
pub const HUB_CHAR_TTTT_SHIFT: u32 = 5;
pub const HUB_CHAR_TTTT_MASK: u32 = 96;
pub const HUB_CHAR_TTTT_8_BITS: u32 = 0;
pub const HUB_CHAR_TTTT_16_BITS: u32 = 32;
pub const HUB_CHAR_TTTT_24_BITS: u32 = 64;
pub const HUB_CHAR_TTTT_32_BITS: u32 = 96;
pub const HUB_CHAR_PORTIND: u32 = 128;
pub const USB_SIZEOF_HUB_DESC: u32 = 9;
pub const USB_SIZEOF_HUB_SS_DESC: u32 = 11;
pub const USB_CLASS_MATCH_VENDOR: u32 = 1;
pub const USB_CLASS_MATCH_PRODUCT: u32 = 2;
pub const USB_CLASS_MATCH_INTF_CLASS: u32 = 4;
pub const USB_CLASS_MATCH_INTF_SUBCLASS: u32 = 8;
pub const USB_CLASS_MATCH_INTF_PROTOCOL: u32 = 16;
pub const USB_CLASS_MATCH_VID_PID: u32 = 3;
pub const AUDIO_SUBCLASS_UNDEFINED: u32 = 0;
pub const AUDIO_SUBCLASS_AUDIOCONTROL: u32 = 1;
pub const AUDIO_SUBCLASS_AUDIOSTREAMING: u32 = 2;
pub const AUDIO_SUBCLASS_MIDISTREAMING: u32 = 3;
pub const AUDIO_PROTOCOL_UNDEFINED: u32 = 0;
pub const AUDIO_PROTOCOLv20: u32 = 32;
pub const AUDIO_REQUEST_UNDEFINED: u32 = 0;
pub const AUDIO_REQUEST_SET_CUR: u32 = 1;
pub const AUDIO_REQUEST_GET_CUR: u32 = 129;
pub const AUDIO_REQUEST_SET_MIN: u32 = 2;
pub const AUDIO_REQUEST_GET_MIN: u32 = 130;
pub const AUDIO_REQUEST_SET_MAX: u32 = 3;
pub const AUDIO_REQUEST_GET_MAX: u32 = 131;
pub const AUDIO_REQUEST_SET_RES: u32 = 4;
pub const AUDIO_REQUEST_GET_RES: u32 = 132;
pub const AUDIO_REQUEST_SET_MEM: u32 = 5;
pub const AUDIO_REQUEST_GET_MEM: u32 = 133;
pub const AUDIO_REQUEST_GET_STAT: u32 = 255;
pub const AUDIO_REQUEST_CUR: u32 = 1;
pub const AUDIO_REQUEST_RANGE: u32 = 2;
pub const AUDIO_CONTROL_UNDEF: u32 = 1;
pub const AUDIO_CONTROL_HEADER: u32 = 1;
pub const AUDIO_CONTROL_INPUT_TERMINAL: u32 = 2;
pub const AUDIO_CONTROL_OUTPUT_TERMINAL: u32 = 3;
pub const AUDIO_CONTROL_MIXER_UNIT: u32 = 4;
pub const AUDIO_CONTROL_SELECTOR_UNIT: u32 = 5;
pub const AUDIO_CONTROL_FEATURE_UNIT: u32 = 6;
pub const AUDIO_CONTROL_EFFECT_UNIT: u32 = 7;
pub const AUDIO_CONTROL_PROCESSING_UNIT: u32 = 8;
pub const AUDIO_CONTROL_EXTENSION_UNIT: u32 = 9;
pub const AUDIO_CONTROL_CLOCK_SOURCE: u32 = 10;
pub const AUDIO_CONTROL_CLOCK_SELECTOR: u32 = 11;
pub const AUDIO_CONTROL_CLOCK_MULTIPLIER: u32 = 12;
pub const AUDIO_CONTROL_SAMPLERATE_CONVERTER: u32 = 13;
pub const AUDIO_STREAMING_UNDEFINED: u32 = 0;
pub const AUDIO_STREAMING_GENERAL: u32 = 1;
pub const AUDIO_STREAMING_FORMAT_TYPE: u32 = 2;
pub const AUDIO_STREAMING_ENCODER: u32 = 3;
pub const AUDIO_STREAMING_DECODER: u32 = 4;
pub const AUDIO_CLKSRC_EXTERNAL: u32 = 0;
pub const AUDIO_CLKSRC_INTERNAL_FIXED: u32 = 1;
pub const AUDIO_CLKSRC_INTERNAL_VAR: u32 = 2;
pub const AUDIO_CLKSRC_INTERNAL_PROG: u32 = 3;
pub const AUDIO_EFFECT_UNDEF: u32 = 0;
pub const AUDIO_EFFECT_PARAM_EQ_SECTION: u32 = 1;
pub const AUDIO_EFFECT_REVERBERATION: u32 = 2;
pub const AUDIO_EFFECT_MOD_DELAY: u32 = 3;
pub const AUDIO_EFFECT_DYN_RANGE_COMP: u32 = 4;
pub const AUDIO_PROCESS_UNDEFINED: u32 = 0;
pub const AUDIO_PROCESS_UPDOWNMIX: u32 = 1;
pub const AUDIO_PROCESS_DOLBY_PROLOGIC: u32 = 2;
pub const AUDIO_PROCESS_STEREO_EXTENDER: u32 = 3;
pub const AUDIO_ENDPOINT_UNDEFINED: u32 = 0;
pub const AUDIO_ENDPOINT_GENERAL: u32 = 1;
pub const AUDIO_CONTROL_MUTE: u32 = 1;
pub const AUDIO_CONTROL_VOLUME: u32 = 2;
pub const AUDIO_CONTROL_BASS: u32 = 4;
pub const AUDIO_CONTROL_MID: u32 = 8;
pub const AUDIO_CONTROL_TREBLE: u32 = 16;
pub const AUDIO_CONTROL_GRAPHIC_EQUALIZER: u32 = 32;
pub const AUDIO_CONTROL_AUTOMATIC_GAIN: u32 = 64;
pub const AUDIO_CONTROL_DEALY: u32 = 128;
pub const AUDIO_CONTROL_BASS_BOOST: u32 = 256;
pub const AUDIO_CONTROL_LOUDNESS: u32 = 512;
pub const AUDIO_ENCODER_UNDEF: u32 = 0;
pub const AUDIO_ENCODER_OTHER: u32 = 1;
pub const AUDIO_ENCODER_MPEG: u32 = 2;
pub const AUDIO_ENCODER_AC3: u32 = 3;
pub const AUDIO_ENCODER_WMA: u32 = 4;
pub const AUDIO_ENCODER_DTS: u32 = 5;
pub const AUDIO_DECODER_UNDEF: u32 = 0;
pub const AUDIO_DECODER_OTHER: u32 = 1;
pub const AUDIO_DECODER_MPEG: u32 = 2;
pub const AUDIO_DECODER_AC3: u32 = 3;
pub const AUDIO_DECODER_WMA: u32 = 4;
pub const AUDIO_DECODER_DTS: u32 = 5;
pub const AUDIO_UNDEFINED_DESCRIPTOR_TYPE: u32 = 32;
pub const AUDIO_DEVICE_DESCRIPTOR_TYPE: u32 = 33;
pub const AUDIO_CONFIGURATION_DESCRIPTOR_TYPE: u32 = 34;
pub const AUDIO_STRING_DESCRIPTOR_TYPE: u32 = 35;
pub const AUDIO_INTERFACE_DESCRIPTOR_TYPE: u32 = 36;
pub const AUDIO_ENDPOINT_DESCRIPTOR_TYPE: u32 = 37;
pub const AUDIO_FORMAT_TYPE_I_UNDEFINED: u32 = 0;
pub const AUDIO_FORMAT_PCM: u32 = 1;
pub const AUDIO_FORMAT_PCM8: u32 = 2;
pub const AUDIO_FORMAT_IEEE_FLOAT: u32 = 3;
pub const AUDIO_FORMAT_ALAW: u32 = 4;
pub const AUDIO_FORMAT_MULAW: u32 = 5;
pub const AUDIO_V2_FORMAT_PCM: u32 = 1;
pub const AUDIO_V2_FORMAT_PCM8: u32 = 2;
pub const AUDIO_V2_FORMAT_IEEE_FLOAT: u32 = 4;
pub const AUDIO_V2_FORMAT_ALAW: u32 = 8;
pub const AUDIO_V2_FORMAT_MULAW: u32 = 16;
pub const AUDIO_CHANNEL_M: u32 = 0;
pub const AUDIO_CHANNEL_FL: u32 = 1;
pub const AUDIO_CHANNEL_FR: u32 = 2;
pub const AUDIO_CHANNEL_FC: u32 = 4;
pub const AUDIO_CHANNEL_LFE: u32 = 8;
pub const AUDIO_CHANNEL_BL: u32 = 16;
pub const AUDIO_CHANNEL_BR: u32 = 32;
pub const AUDIO_CHANNEL_FLC: u32 = 64;
pub const AUDIO_CHANNEL_FRC: u32 = 128;
pub const AUDIO_CHANNEL_BC: u32 = 256;
pub const AUDIO_CHANNEL_SL: u32 = 512;
pub const AUDIO_CHANNEL_SR: u32 = 1024;
pub const AUDIO_CHANNEL_TC: u32 = 2048;
pub const AUDIO_CHANNEL_TFL: u32 = 4096;
pub const AUDIO_CHANNEL_TFC: u32 = 8192;
pub const AUDIO_CHANNEL_TFR: u32 = 16384;
pub const AUDIO_CHANNEL_TBL: u32 = 32768;
pub const AUDIO_CHANNEL_TBC: u32 = 65536;
pub const AUDIO_CHANNEL_TBR: u32 = 131072;
pub const AUDIO_CHANNEL_TFLC: u32 = 262144;
pub const AUDIO_CHANNEL_TFRC: u32 = 524288;
pub const AUDIO_CHANNEL_LLFE: u32 = 1048576;
pub const AUDIO_CHANNEL_RLFE: u32 = 2097152;
pub const AUDIO_CHANNEL_TSL: u32 = 4194304;
pub const AUDIO_CHANNEL_TSR: u32 = 8388608;
pub const AUDIO_CHANNEL_BOC: u32 = 16777216;
pub const AUDIO_CHANNEL_BLC: u32 = 33554432;
pub const AUDIO_CHANNEL_BRC: u32 = 67108864;
pub const AUDIO_CHANNEL_RD: u32 = 2147483648;
pub const AUDIO_CATEGORY_UNDEF: u32 = 0;
pub const AUDIO_CATEGORY_SPEAKER: u32 = 1;
pub const AUDIO_CATEGORY_THEATER: u32 = 2;
pub const AUDIO_CATEGORY_MICROPHONE: u32 = 3;
pub const AUDIO_CATEGORY_HEADSET: u32 = 4;
pub const AUDIO_CATEGORY_TELEPHONE: u32 = 5;
pub const AUDIO_CATEGORY_CONVERTER: u32 = 6;
pub const AUDIO_CATEGORY_RECORDER: u32 = 7;
pub const AUDIO_CATEGORY_IO_BOX: u32 = 8;
pub const AUDIO_CATEGORY_INSTRUMENT: u32 = 9;
pub const AUDIO_CATEGORY_PROAUDIO: u32 = 10;
pub const AUDIO_CATEGORY_AV: u32 = 11;
pub const AUDIO_CATEGORY_CONTROL: u32 = 12;
pub const AUDIO_CATEGORY_OTHER: u32 = 255;
pub const AUDIO_CS_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_CS_CONTROL_SAM_FREQ: u32 = 1;
pub const AUDIO_CS_CONTROL_CLOCK_VALID: u32 = 2;
pub const AUDIO_CX_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_CX_CONTROL_CLOCKSEL: u32 = 1;
pub const AUDIO_CM_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_CM_CONTROL_NUMERATOR: u32 = 1;
pub const AUDIO_CM_CONTROL_DENOMINATOR: u32 = 2;
pub const AUDIO_TE_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_TE_CONTROL_COPY_PROTECT: u32 = 1;
pub const AUDIO_TE_CONTROL_CONNECTOR: u32 = 2;
pub const AUDIO_TE_CONTROL_OVERLOAD: u32 = 3;
pub const AUDIO_TE_CONTROL_CLUSTER: u32 = 4;
pub const AUDIO_TE_CONTROL_UNDERFLOW: u32 = 5;
pub const AUDIO_TE_CONTROL_OVERFLOW: u32 = 6;
pub const AUDIO_TE_CONTROL_LATENCY: u32 = 7;
pub const AUDIO_MU_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_MU_CONTROL_MIXER: u32 = 1;
pub const AUDIO_MU_CONTROL_CLUSTER: u32 = 2;
pub const AUDIO_MU_CONTROL_UNDERFLOW: u32 = 3;
pub const AUDIO_MU_CONTROL_OVERFLOW: u32 = 4;
pub const AUDIO_MU_CONTROL_LATENCY: u32 = 5;
pub const AUDIO_SU_CONTROL_UNDEFINE: u32 = 0;
pub const AUDIO_SU_CONTROL_SELECTOR: u32 = 1;
pub const AUDIO_SU_CONTROL_LATENCY: u32 = 2;
pub const AUDIO_FU_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_FU_CONTROL_MUTE: u32 = 1;
pub const AUDIO_FU_CONTROL_VOLUME: u32 = 2;
pub const AUDIO_FU_CONTROL_BASS: u32 = 3;
pub const AUDIO_FU_CONTROL_MID: u32 = 4;
pub const AUDIO_FU_CONTROL_TREBLE: u32 = 5;
pub const AUDIO_FU_CONTROL_EQUALIZER: u32 = 6;
pub const AUDIO_FU_CONTROL_AGC: u32 = 7;
pub const AUDIO_FU_CONTROL_DELAY: u32 = 8;
pub const AUDIO_FU_CONTROL_BASS_BOOST: u32 = 9;
pub const AUDIO_FU_CONTROL_LOUDNESS: u32 = 10;
pub const AUDIO_FU_CONTROL_INP_GAIN: u32 = 11;
pub const AUDIO_FU_CONTROL_INP_GAIN_PAD: u32 = 12;
pub const AUDIO_FU_CONTROL_PHASE_INVERT: u32 = 13;
pub const AUDIO_FU_CONTROL_UNDERFLOW: u32 = 14;
pub const AUDIO_FU_CONTROL_OVERFLOW: u32 = 15;
pub const AUDIO_FU_CONTROL_LATENCY: u32 = 16;
pub const AUDIO_V2_FU_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_V2_FU_CONTROL_MUTE: u32 = 3;
pub const AUDIO_V2_FU_CONTROL_VOLUME: u32 = 12;
pub const AUDIO_V2_FU_CONTROL_BASS: u32 = 48;
pub const AUDIO_V2_FU_CONTROL_MID: u32 = 192;
pub const AUDIO_V2_FU_CONTROL_TREBLE: u32 = 768;
pub const AUDIO_V2_FU_CONTROL_EQUALIZER: u32 = 3072;
pub const AUDIO_V2_FU_CONTROL_AGC: u32 = 12288;
pub const AUDIO_V2_FU_CONTROL_DELAY: u32 = 49152;
pub const AUDIO_V2_FU_CONTROL_BASS_BOOST: u32 = 196608;
pub const AUDIO_V2_FU_CONTROL_LOUDNESS: u32 = 786432;
pub const AUDIO_V2_FU_CONTROL_INP_GAIN: u32 = 3145728;
pub const AUDIO_V2_FU_CONTROL_INP_GAIN_PAD: u32 = 12582912;
pub const AUDIO_V2_FU_CONTROL_PHASE_INVERT: u32 = 50331648;
pub const AUDIO_V2_FU_CONTROL_UNDERFLOW: u32 = 201326592;
pub const AUDIO_V2_FU_CONTROL_OVERFLOW: u32 = 805306368;
pub const AUDIO_PE_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_PE_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_PE_CONTROL_CENTERFREQ: u32 = 2;
pub const AUDIO_PE_CONTROL_QFACTOR: u32 = 3;
pub const AUDIO_PE_CONTROL_GAIN: u32 = 4;
pub const AUDIO_PE_CONTROL_UNDERFLOW: u32 = 5;
pub const AUDIO_PE_CONTROL_OVERFLOW: u32 = 6;
pub const AUDIO_PE_CONTROL_LATENCY: u32 = 7;
pub const AUDIO_RV_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_RV_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_RV_CONTROL_TYPE: u32 = 2;
pub const AUDIO_RV_CONTROL_LEVEL: u32 = 3;
pub const AUDIO_RV_CONTROL_TIME: u32 = 4;
pub const AUDIO_RV_CONTROL_FEEDBACK: u32 = 5;
pub const AUDIO_RV_CONTROL_PREDELAY: u32 = 6;
pub const AUDIO_RV_CONTROL_DENSITY: u32 = 7;
pub const AUDIO_RV_CONTROL_HF_ROLLOFF: u32 = 8;
pub const AUDIO_RV_CONTROL_UNDERFLOW: u32 = 9;
pub const AUDIO_RV_CONTROL_OVERFLOW: u32 = 10;
pub const AUDIO_RV_CONTROL_LATENCY: u32 = 11;
pub const AUDIO_MD_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_MD_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_MD_CONTROL_BALANCE: u32 = 2;
pub const AUDIO_MD_CONTROL_RATE: u32 = 3;
pub const AUDIO_MD_CONTROL_DEPTH: u32 = 4;
pub const AUDIO_MD_CONTROL_TIME: u32 = 5;
pub const AUDIO_MD_CONTROL_FEEDBACK: u32 = 6;
pub const AUDIO_MD_CONTROL_UNDERFLOW: u32 = 7;
pub const AUDIO_MD_CONTROL_OVERFLOW: u32 = 8;
pub const AUDIO_MD_CONTROL_LATENCY: u32 = 9;
pub const AUDIO_DR_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_DR_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_DR_CONTROL_COMP_RATE: u32 = 2;
pub const AUDIO_DR_CONTROL_MAXAMPL: u32 = 3;
pub const AUDIO_DR_CONTROL_THRESHOLD: u32 = 4;
pub const AUDIO_DR_CONTROL_ATTACK_TIME: u32 = 5;
pub const AUDIO_DR_CONTROL_RELEASE_TIME: u32 = 6;
pub const AUDIO_DR_CONTROL_UNDERFLOW: u32 = 7;
pub const AUDIO_DR_CONTROL_OVERFLOW: u32 = 8;
pub const AUDIO_DR_CONTROL_LATENCY: u32 = 9;
pub const AUDIO_UD_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_UD_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_UD_CONTROL_MODE_SELECT: u32 = 2;
pub const AUDIO_UD_CONTROL_CLUSTER: u32 = 3;
pub const AUDIO_UD_CONTROL_UNDERFLOW: u32 = 4;
pub const AUDIO_UD_CONTROL_OVERFLOW: u32 = 5;
pub const AUDIO_UD_CONTROL_LATENCY: u32 = 6;
pub const AUDIO_DP_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_DP_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_DP_CONTROL_MODE_SELECT: u32 = 2;
pub const AUDIO_DP_CONTROL_CLUSTER: u32 = 3;
pub const AUDIO_DP_CONTROL_UNDERFLOW: u32 = 4;
pub const AUDIO_DP_CONTROL_OVERFLOW: u32 = 5;
pub const AUDIO_DP_CONTROL_LATENCY: u32 = 6;
pub const AUDIO_STEXT_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_STEXT_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_STEXT_CONTROL_WIDTH: u32 = 2;
pub const AUDIO_STEXT_CONTROL_UNDERFLOW: u32 = 3;
pub const AUDIO_STEXT_CONTROL_OVERFLOW: u32 = 4;
pub const AUDIO_STEXT_CONTROL_LATENCY: u32 = 5;
pub const AUDIO_XU_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_XU_CONTROL_ENABLE: u32 = 1;
pub const AUDIO_XU_CONTROL_CLUSTER: u32 = 2;
pub const AUDIO_XU_CONTROL_UNDERFLOW: u32 = 3;
pub const AUDIO_XU_CONTROL_OVERFLOW: u32 = 4;
pub const AUDIO_XU_CONTROL_LATENCY: u32 = 5;
pub const AUDIO_AS_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_AS_CONTROL_ACT_ALT: u32 = 1;
pub const AUDIO_AS_CONTROL_VAL_ALT: u32 = 2;
pub const AUDIO_AS_CONTROL_AUDIO_FORMAT: u32 = 3;
pub const AUDIO_EN_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_EN_CONTROL_BIT_RATE: u32 = 1;
pub const AUDIO_EN_CONTROL_QUALITY: u32 = 2;
pub const AUDIO_EN_CONTROL_VBR: u32 = 3;
pub const AUDIO_EN_CONTROL_TYPE: u32 = 4;
pub const AUDIO_EN_CONTROL_UNDERFLOW: u32 = 5;
pub const AUDIO_EN_CONTROL_OVERFLOW: u32 = 6;
pub const AUDIO_EN_CONTROL_ENCODER_ERR: u32 = 7;
pub const AUDIO_EN_CONTROL_PARAM1: u32 = 8;
pub const AUDIO_EN_CONTROL_PARAM2: u32 = 9;
pub const AUDIO_EN_CONTROL_PARAM3: u32 = 10;
pub const AUDIO_EN_CONTROL_PARAM4: u32 = 11;
pub const AUDIO_EN_CONTROL_PARAM5: u32 = 12;
pub const AUDIO_EN_CONTROL_PARAM6: u32 = 13;
pub const AUDIO_EN_CONTROL_PARAM7: u32 = 14;
pub const AUDIO_EN_CONTROL_PARAM8: u32 = 15;
pub const AUDIO_MPGD_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_MPGD_CONTROL_DUAL_CHAN: u32 = 1;
pub const AUDIO_MPGD_CONTROL_2ND_STEREO: u32 = 2;
pub const AUDIO_MPGD_CONTROL_MULTILING: u32 = 3;
pub const AUDIO_MPGD_CONTROL_DYN_RANGE: u32 = 4;
pub const AUDIO_MPGD_CONTROL_SCALING: u32 = 5;
pub const AUDIO_MPGD_CONTROL_HILO_SCALE: u32 = 6;
pub const AUDIO_MPGD_CONTROL_UNDERFLOW: u32 = 7;
pub const AUDIO_MPGD_CONTROL_OVERFLOW: u32 = 8;
pub const AUDIO_MPGD_CONTROL_DECODE_ERR: u32 = 9;
pub const AUDIO_AC3D_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_AC3D_CONTROL_MODE: u32 = 1;
pub const AUDIO_AC3D_CONTROL_DYN_RANGE: u32 = 2;
pub const AUDIO_AC3D_CONTROL_SCALING: u32 = 3;
pub const AUDIO_AC3D_CONTROL_HILO_SCALE: u32 = 4;
pub const AUDIO_AC3D_CONTROL_UNDERFLOW: u32 = 5;
pub const AUDIO_AC3D_CONTROL_OVERFLOW: u32 = 6;
pub const AUDIO_AC3D_CONTROL_DECODE_ERR: u32 = 7;
pub const AUDIO_WMAD_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_WMAD_CONTROL_UNDERFLOW: u32 = 1;
pub const AUDIO_WMAD_CONTROL_OVERFLOW: u32 = 2;
pub const AUDIO_WMAD_CONTROL_DECODE_ERR: u32 = 3;
pub const AUDIO_DTSD_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_DTSD_CONTROL_UNDERFLOW: u32 = 1;
pub const AUDIO_DTSD_CONTROL_OVERFLOW: u32 = 2;
pub const AUDIO_DTSD_CONTROL_DECODE_ERR: u32 = 3;
pub const AUDIO_EP_CONTROL_UNDEF: u32 = 0;
pub const AUDIO_EP_CONTROL_SAMPLING_FEQ: u32 = 1;
pub const AUDIO_EP_CONTROL_PITCH: u32 = 2;
pub const AUDIO_ENCODER_SUCCESS: u32 = 0;
pub const AUDIO_ENCODER_ERROR_NOMEM: u32 = 1;
pub const AUDIO_ENCODER_ERROR_BW: u32 = 2;
pub const AUDIO_ENCODER_ERROR_CYCLE: u32 = 3;
pub const AUDIO_ENCODER_ERROR_FRAME: u32 = 4;
pub const AUDIO_ENCODER_ERROR_TOOSMALL: u32 = 5;
pub const AUDIO_ENCODER_ERROR_TOOBIG: u32 = 6;
pub const AUDIO_ENCODER_ERROR_BADFORMAT: u32 = 7;
pub const AUDIO_ENCODER_ERROR_NCHAN: u32 = 8;
pub const AUDIO_ENCODER_ERROR_RATE: u32 = 9;
pub const AUDIO_ENCODER_ERROR_BITRATE: u32 = 10;
pub const AUDIO_ENCODER_ERROR_PARMS: u32 = 11;
pub const AUDIO_ENCODER_ERROR_NOTREADY: u32 = 12;
pub const AUDIO_ENCODER_ERROR_BUSY: u32 = 13;
pub const AUDIO_FORMAT_TYPE_UNDEF: u32 = 0;
pub const AUDIO_FORMAT_TYPEI: u32 = 1;
pub const AUDIO_FORMAT_TYPEII: u32 = 2;
pub const AUDIO_FORMAT_TYPEIII: u32 = 3;
pub const AUDIO_FORMAT_TYPEIV: u32 = 4;
pub const AUDIO_FORMAT_EXT_TYPEI: u32 = 129;
pub const AUDIO_FORMAT_EXT_TYPEII: u32 = 130;
pub const AUDIO_FORMAT_EXT_TYPEIII: u32 = 131;
pub const AUDIO_FORMAT_TYPEI_PCM: u32 = 1;
pub const AUDIO_FORMAT_TYPEI_PCM8: u32 = 2;
pub const AUDIO_FORMAT_TYPEI_IEEEFLOAT: u32 = 4;
pub const AUDIO_FORMAT_TYPEI_ALAW: u32 = 8;
pub const AUDIO_FORMAT_TYPEI_MULAW: u32 = 16;
pub const AUDIO_FORMAT_TYPEI_RAWDATA: u32 = 2147483648;
pub const AUDIO_FORMAT_TYPEII_MPEG: u32 = 1;
pub const AUDIO_FORMAT_TYPEII_AC3: u32 = 2;
pub const AUDIO_FORMAT_TYPEII_WMA: u32 = 4;
pub const AUDIO_FORMAT_TYPEII_DTS: u32 = 8;
pub const AUDIO_FORMAT_TYPEII_RAWDATA: u32 = 2147483648;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_AC3: u32 = 1;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG1_L1: u32 = 2;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG1_L2_3: u32 = 2;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG2_NOEXT: u32 = 4;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG2_EXT: u32 = 8;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG2_AAC_ADTS: u32 = 16;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG2_L1_LS: u32 = 32;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_MPEG2_L2_3_LS: u32 = 64;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_DTS_I: u32 = 128;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_DTS_II: u32 = 256;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_DTS_III: u32 = 512;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_ATRAC: u32 = 1024;
pub const AUDIO_FORMAT_TYPEIII_IEC61937_ATRAC2_3: u32 = 2048;
pub const AUDIO_FORMAT_TYPEIII_WMA: u32 = 4096;
pub const AUDIO_FORMAT_TYPEIV_PCM: u32 = 1;
pub const AUDIO_FORMAT_TYPEIV_PCM8: u32 = 2;
pub const AUDIO_FORMAT_TYPEIV_IEEE_FLOAT: u32 = 4;
pub const AUDIO_FORMAT_TYPEIV_ALAW: u32 = 8;
pub const AUDIO_FORMAT_TYPEIV_MULAW: u32 = 16;
pub const AUDIO_FORMAT_TYPEIV_MPEG: u32 = 32;
pub const AUDIO_FORMAT_TYPEIV_AC3: u32 = 64;
pub const AUDIO_FORMAT_TYPEIV_WMA: u32 = 128;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_AC3: u32 = 256;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG1_L1: u32 = 512;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG1_L2_3: u32 = 1024;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG2_NOEXT: u32 = 1024;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG2_EXT: u32 = 2048;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG2_AAC_ADTS: u32 = 4096;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG2_L1_LS: u32 = 8192;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_MPEG2_L2_3_LS: u32 = 16384;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_DTS_I: u32 = 32768;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_DTS_II: u32 = 65536;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_DTS_III: u32 = 131072;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_ATRAC: u32 = 262144;
pub const AUDIO_FORMAT_TYPEIV_IEC61937_ATRAC2_3: u32 = 524288;
pub const AUDIO_FORMAT_TYPEIV_TYPE_III_WMA: u32 = 1048576;
pub const AUDIO_FORMAT_TYPEIV_IEC60958_PCM: u32 = 2097152;
pub const AUDIO_SIDEBAND_PROTOCOL_UNDEF: u32 = 0;
pub const AUDIO_PRES_TIMESTAMP_PROTOCOL: u32 = 1;
pub const AUDIO_TERMINAL_UNDEF: u32 = 256;
pub const AUDIO_TERMINAL_STREAMING: u32 = 257;
pub const AUDIO_TERMINAL_VENDOR: u32 = 511;
pub const AUDIO_INTERM_UNDEF: u32 = 512;
pub const AUDIO_INTERM_MIC: u32 = 513;
pub const AUDIO_INTERM_DESKTOP_MIC: u32 = 514;
pub const AUDIO_INTERM_PERSONAL_MIC: u32 = 515;
pub const AUDIO_INTERM_OMNI_MIC: u32 = 516;
pub const AUDIO_INTERM_MIC_ARRAY: u32 = 517;
pub const AUDIO_INTERM_PROC_MIC_ARRAY: u32 = 518;
pub const AUDIO_OUTTERM_UNDEF: u32 = 768;
pub const AUDIO_OUTTERM_SPEAKER: u32 = 769;
pub const AUDIO_OUTTERM_HEADPHONES: u32 = 770;
pub const AUDIO_OUTTERM_HEADDISPLAY: u32 = 771;
pub const AUDIO_OUTTERM_DESKTOP: u32 = 772;
pub const AUDIO_OUTTERM_ROOM: u32 = 773;
pub const AUDIO_OUTTERM_COMMS: u32 = 774;
pub const AUDIO_OUTTERM_LOFREQ: u32 = 775;
pub const AUDIO_BIDITERM_UNDEF: u32 = 1024;
pub const AUDIO_BIDITERM_HANDSET: u32 = 1025;
pub const AUDIO_BIDITERM_HEADSET: u32 = 1026;
pub const AUDIO_BIDITERM_SPEAKERPHONE: u32 = 1027;
pub const AUDIO_BIDITERM_ECHOSUPPRESS: u32 = 1028;
pub const AUDIO_BIDITERM_ECHOCANCEL: u32 = 1029;
pub const AUDIO_TELETERM_UNDEF: u32 = 1280;
pub const AUDIO_TELETERM_PHONELINE: u32 = 1281;
pub const AUDIO_TELETERM_TELEPHONE: u32 = 1282;
pub const AUDIO_TELETERM_DOWNLINE: u32 = 1283;
pub const AUDIO_EXTTERM_UNDEF: u32 = 1536;
pub const AUDIO_EXTTERM_ANALOG: u32 = 1537;
pub const AUDIO_EXTTERM_DIGITAL: u32 = 1538;
pub const AUDIO_EXTTERM_LINE: u32 = 1539;
pub const AUDIO_EXTTERM_LEGACY: u32 = 1540;
pub const AUDIO_EXTTERM_SPDIF: u32 = 1541;
pub const AUDIO_EXTTERM_1394DA: u32 = 1542;
pub const AUDIO_EXTTERM_1394DV: u32 = 1543;
pub const AUDIO_EXTTERM_ADAT: u32 = 1544;
pub const AUDIO_EXTTERM_TDIF: u32 = 1545;
pub const AUDIO_EXTTERM_MADI: u32 = 1546;
pub const AUDIO_EMBEDTERM_UNDEF: u32 = 1792;
pub const AUDIO_EMBEDTERM_CALIBRATION: u32 = 1793;
pub const AUDIO_EMBEDTERM_EQUALIZATION: u32 = 1794;
pub const AUDIO_EMBEDTERM_CD: u32 = 1795;
pub const AUDIO_EMBEDTERM_DAT: u32 = 1796;
pub const AUDIO_EMBEDTERM_DCC: u32 = 1797;
pub const AUDIO_EMBEDTERM_COMPRESSED: u32 = 1798;
pub const AUDIO_EMBEDTERM_TAPE: u32 = 1799;
pub const AUDIO_EMBEDTERM_PHONOGRAPH: u32 = 1800;
pub const AUDIO_EMBEDTERM_VCR: u32 = 1801;
pub const AUDIO_EMBEDTERM_VIDDISC: u32 = 1802;
pub const AUDIO_EMBEDTERM_DVD: u32 = 1803;
pub const AUDIO_EMBEDTERM_TVTUNER: u32 = 1804;
pub const AUDIO_EMBEDTERM_SATELLITE: u32 = 1805;
pub const AUDIO_EMBEDTERM_CABLETUNER: u32 = 1806;
pub const AUDIO_EMBEDTERM_DSS: u32 = 1807;
pub const AUDIO_EMBEDTERM_RADIO: u32 = 1808;
pub const AUDIO_EMBEDTERM_TRANSMITTER: u32 = 1809;
pub const AUDIO_EMBEDTERM_MULTITRACK: u32 = 1810;
pub const AUDIO_EMBEDTERM_SYNTHESIZER: u32 = 1811;
pub const AUDIO_EMBEDTERM_PIANO: u32 = 1812;
pub const AUDIO_EMBEDTERM_GUITAR: u32 = 1813;
pub const AUDIO_EMBEDTERM_PERCUSSON: u32 = 1814;
pub const AUDIO_EMBEDTERM_INSTRUMENT: u32 = 1815;
pub const AUDIO_FORMAT_TYPE_I: u32 = 1;
pub const AUDIO_FORMAT_TYPE_II: u32 = 2;
pub const AUDIO_FORMAT_TYPE_III: u32 = 3;
pub const AUDIO_SIZEOF_AC_INPUT_TERMINAL_DESC: u32 = 12;
pub const AUDIO_SIZEOF_AC_OUTPUT_TERMINAL_DESC: u32 = 9;
pub const AUDIO_SIZEOF_AS_GENERAL_DESC: u32 = 7;
pub const AUDIO_SIZEOF_EP_DESC: u32 = 9;
pub const AUDIO_SIZEOF_CS_EP_GENERAL_DESC: u32 = 7;
pub const AUDIO_MS_STANDARD_DESCRIPTOR_INIT_LEN: u32 = 9;
pub const AUDIO_V2_SIZEOF_CHANNEL_CLUSTER_DESC: u32 = 6;
pub const AUDIO_V2_SIZEOF_AC_HEADER_DESC: u32 = 9;
pub const AUDIO_V2_SIZEOF_AC_CLOCK_SOURCE_DESC: u32 = 8;
pub const AUDIO_V2_SIZEOF_AC_INPUT_TERMINAL_DESC: u32 = 17;
pub const AUDIO_V2_SIZEOF_AC_OUTPUT_TERMINAL_DESC: u32 = 12;
pub const AUDIO_V2_SIZEOF_AS_GENERAL_DESC: u32 = 16;
pub const AUDIO_V2_AC_DESCRIPTOR_INIT_LEN: u32 = 26;
pub const AUDIO_V2_AS_DESCRIPTOR_INIT_LEN: u32 = 55;
pub const AUDIO_V2_AS_FEEDBACK_DESCRIPTOR_INIT_LEN: u32 = 62;
pub const CDC_V1_10: u32 = 272;
pub const CDC_V1_2_0: u32 = 288;
pub const CDC_COMMUNICATION_INTERFACE_CLASS: u32 = 2;
pub const CDC_SUBCLASS_NONE: u32 = 0;
pub const CDC_SUBCLASS_DLC: u32 = 1;
pub const CDC_SUBCLASS_ACM: u32 = 2;
pub const CDC_SUBCLASS_TCM: u32 = 3;
pub const CDC_SUBCLASS_MCM: u32 = 4;
pub const CDC_SUBCLASS_CAPI: u32 = 5;
pub const CDC_SUBCLASS_ECM: u32 = 6;
pub const CDC_SUBCLASS_ATM: u32 = 7;
pub const CDC_SUBCLASS_MBIM: u32 = 14;
pub const CDC_DIRECT_LINE_CONTROL_MODEL: u32 = 1;
pub const CDC_ABSTRACT_CONTROL_MODEL: u32 = 2;
pub const CDC_TELEPHONE_CONTROL_MODEL: u32 = 3;
pub const CDC_MULTI_CHANNEL_CONTROL_MODEL: u32 = 4;
pub const CDC_CAPI_CONTROL_MODEL: u32 = 5;
pub const CDC_ETHERNET_NETWORKING_CONTROL_MODEL: u32 = 6;
pub const CDC_ATM_NETWORKING_CONTROL_MODEL: u32 = 7;
pub const CDC_WIRELESS_HANDSET_CONTROL_MODEL: u32 = 8;
pub const CDC_DEVICE_MANAGEMENT: u32 = 9;
pub const CDC_MOBILE_DIRECT_LINE_MODEL: u32 = 10;
pub const CDC_OBEX: u32 = 11;
pub const CDC_ETHERNET_EMULATION_MODEL: u32 = 12;
pub const CDC_NETWORK_CONTROL_MODEL: u32 = 13;
pub const CDC_COMMON_PROTOCOL_NONE: u32 = 0;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS: u32 = 1;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS_PCCA_101: u32 = 2;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS_PCCA_101_AND_ANNEXO: u32 = 3;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS_GSM_707: u32 = 4;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS_3GPP_27007: u32 = 5;
pub const CDC_COMMON_PROTOCOL_AT_COMMANDS_CDMA: u32 = 6;
pub const CDC_COMMON_PROTOCOL_ETHERNET_EMULATION_MODEL: u32 = 7;
pub const CDC_NCM_PROTOCOL_NONE: u32 = 0;
pub const CDC_NCM_PROTOCOL_OEM: u32 = 254;
pub const CDC_DATA_INTERFACE_CLASS: u32 = 10;
pub const CDC_DATA_SUBCLASS_NONE: u32 = 0;
pub const CDC_DATA_PROTOCOL_ISDN_BRI: u32 = 48;
pub const CDC_DATA_PROTOCOL_HDLC: u32 = 49;
pub const CDC_DATA_PROTOCOL_TRANSPARENT: u32 = 50;
pub const CDC_DATA_PROTOCOL_Q921_MANAGEMENT: u32 = 80;
pub const CDC_DATA_PROTOCOL_Q921_DATA_LINK: u32 = 81;
pub const CDC_DATA_PROTOCOL_Q921_MULTIPLEXOR: u32 = 82;
pub const CDC_DATA_PROTOCOL_V42: u32 = 144;
pub const CDC_DATA_PROTOCOL_EURO_ISDN: u32 = 145;
pub const CDC_DATA_PROTOCOL_V24_RATE_ADAPTATION: u32 = 146;
pub const CDC_DATA_PROTOCOL_CAPI: u32 = 147;
pub const CDC_DATA_PROTOCOL_HOST_BASED_DRIVER: u32 = 253;
pub const CDC_DATA_PROTOCOL_DESCRIBED_IN_PUFD: u32 = 254;
pub const CDC_CS_INTERFACE: u32 = 36;
pub const CDC_CS_ENDPOINT: u32 = 37;
pub const CDC_FUNC_DESC_HEADER: u32 = 0;
pub const CDC_FUNC_DESC_CALL_MANAGEMENT: u32 = 1;
pub const CDC_FUNC_DESC_ABSTRACT_CONTROL_MANAGEMENT: u32 = 2;
pub const CDC_FUNC_DESC_DIRECT_LINE_MANAGEMENT: u32 = 3;
pub const CDC_FUNC_DESC_TELEPHONE_RINGER: u32 = 4;
pub const CDC_FUNC_DESC_REPORTING_CAPABILITIES: u32 = 5;
pub const CDC_FUNC_DESC_UNION: u32 = 6;
pub const CDC_FUNC_DESC_COUNTRY_SELECTION: u32 = 7;
pub const CDC_FUNC_DESC_TELEPHONE_OPERATIONAL_MODES: u32 = 8;
pub const CDC_FUNC_DESC_USB_TERMINAL: u32 = 9;
pub const CDC_FUNC_DESC_NETWORK_CHANNEL: u32 = 10;
pub const CDC_FUNC_DESC_PROTOCOL_UNIT: u32 = 11;
pub const CDC_FUNC_DESC_EXTENSION_UNIT: u32 = 12;
pub const CDC_FUNC_DESC_MULTI_CHANNEL_MANAGEMENT: u32 = 13;
pub const CDC_FUNC_DESC_CAPI_CONTROL_MANAGEMENT: u32 = 14;
pub const CDC_FUNC_DESC_ETHERNET_NETWORKING: u32 = 15;
pub const CDC_FUNC_DESC_ATM_NETWORKING: u32 = 16;
pub const CDC_FUNC_DESC_WIRELESS_HANDSET_CONTROL_MODEL: u32 = 17;
pub const CDC_FUNC_DESC_MOBILE_DIRECT_LINE_MODEL: u32 = 18;
pub const CDC_FUNC_DESC_MOBILE_DIRECT_LINE_MODEL_DETAIL: u32 = 19;
pub const CDC_FUNC_DESC_DEVICE_MANAGEMENT_MODEL: u32 = 20;
pub const CDC_FUNC_DESC_OBEX: u32 = 21;
pub const CDC_FUNC_DESC_COMMAND_SET: u32 = 22;
pub const CDC_FUNC_DESC_COMMAND_SET_DETAIL: u32 = 23;
pub const CDC_FUNC_DESC_TELEPHONE_CONTROL_MODEL: u32 = 24;
pub const CDC_FUNC_DESC_OBEX_SERVICE_IDENTIFIER: u32 = 25;
pub const CDC_FUNC_DESC_NCM: u32 = 26;
pub const CDC_REQUEST_SEND_ENCAPSULATED_COMMAND: u32 = 0;
pub const CDC_REQUEST_GET_ENCAPSULATED_RESPONSE: u32 = 1;
pub const CDC_REQUEST_SET_COMM_FEATURE: u32 = 2;
pub const CDC_REQUEST_GET_COMM_FEATURE: u32 = 3;
pub const CDC_REQUEST_CLEAR_COMM_FEATURE: u32 = 4;
pub const CDC_REQUEST_SET_AUX_LINE_STATE: u32 = 16;
pub const CDC_REQUEST_SET_HOOK_STATE: u32 = 17;
pub const CDC_REQUEST_PULSE_SETUP: u32 = 18;
pub const CDC_REQUEST_SEND_PULSE: u32 = 19;
pub const CDC_REQUEST_SET_PULSE_TIME: u32 = 20;
pub const CDC_REQUEST_RING_AUX_JACK: u32 = 21;
pub const CDC_REQUEST_SET_LINE_CODING: u32 = 32;
pub const CDC_REQUEST_GET_LINE_CODING: u32 = 33;
pub const CDC_REQUEST_SET_CONTROL_LINE_STATE: u32 = 34;
pub const CDC_REQUEST_SEND_BREAK: u32 = 35;
pub const CDC_REQUEST_SET_RINGER_PARMS: u32 = 48;
pub const CDC_REQUEST_GET_RINGER_PARMS: u32 = 49;
pub const CDC_REQUEST_SET_OPERATION_PARMS: u32 = 50;
pub const CDC_REQUEST_GET_OPERATION_PARMS: u32 = 51;
pub const CDC_REQUEST_SET_LINE_PARMS: u32 = 52;
pub const CDC_REQUEST_GET_LINE_PARMS: u32 = 53;
pub const CDC_REQUEST_DIAL_DIGITS: u32 = 54;
pub const CDC_REQUEST_SET_UNIT_PARAMETER: u32 = 55;
pub const CDC_REQUEST_GET_UNIT_PARAMETER: u32 = 56;
pub const CDC_REQUEST_CLEAR_UNIT_PARAMETER: u32 = 57;
pub const CDC_REQUEST_GET_PROFILE: u32 = 58;
pub const CDC_REQUEST_SET_ETHERNET_MULTICAST_FILTERS: u32 = 64;
pub const CDC_REQUEST_SET_ETHERNET_PMP_FILTER: u32 = 65;
pub const CDC_REQUEST_GET_ETHERNET_PMP_FILTER: u32 = 66;
pub const CDC_REQUEST_SET_ETHERNET_PACKET_FILTER: u32 = 67;
pub const CDC_REQUEST_GET_ETHERNET_STATISTIC: u32 = 68;
pub const CDC_REQUEST_SET_ATM_DATA_FORMAT: u32 = 80;
pub const CDC_REQUEST_GET_ATM_DEVICE_STATISTICS: u32 = 81;
pub const CDC_REQUEST_SET_ATM_DEFAULT_VC: u32 = 82;
pub const CDC_REQUEST_GET_ATM_VC_STATISTICS: u32 = 83;
pub const CDC_REQUEST_GET_NTB_PARAMETERS: u32 = 128;
pub const CDC_REQUEST_GET_NET_ADDRESS: u32 = 129;
pub const CDC_REQUEST_SET_NET_ADDRESS: u32 = 130;
pub const CDC_REQUEST_GET_NTB_FORMAT: u32 = 131;
pub const CDC_REQUEST_SET_NTB_FORMAT: u32 = 132;
pub const CDC_REQUEST_GET_NTB_INPUT_SIZE: u32 = 133;
pub const CDC_REQUEST_SET_NTB_INPUT_SIZE: u32 = 134;
pub const CDC_REQUEST_GET_MAX_DATAGRAM_SIZE: u32 = 135;
pub const CDC_REQUEST_SET_MAX_DATAGRAM_SIZE: u32 = 136;
pub const CDC_REQUEST_GET_CRC_MODE: u32 = 137;
pub const CDC_REQUEST_SET_CRC_MODE: u32 = 144;
pub const CDC_ABSTRACT_STATE: u32 = 1;
pub const CDC_COUNTRY_SETTING: u32 = 2;
pub const SET_CONTROL_LINE_STATE_RTS: u32 = 2;
pub const SET_CONTROL_LINE_STATE_DTR: u32 = 1;
pub const CDC_IDLE_SETTING: u32 = 1;
pub const CDC_DATA_MULTPLEXED_STATE: u32 = 2;
pub const CDC_DTE_PRESENT: u32 = 1;
pub const CDC_ACTIVATE_CARRIER: u32 = 2;
pub const CDC_NOTIFICATION_NETWORK_CONNECTION: u32 = 0;
pub const CDC_RESPONSE_AVAILABLE: u32 = 1;
pub const CDC_AUX_JACK_HOOK_STATE: u32 = 8;
pub const CDC_RING_DETECT: u32 = 9;
pub const CDC_NOTIFICATION_SERIAL_STATE: u32 = 32;
pub const CDC_CALL_STATE_CHANGE: u32 = 40;
pub const CDC_LINE_STATE_CHANGE: u32 = 41;
pub const CDC_CONNECTION_SPEED_CHANGE: u32 = 42;
pub const CDC_SERIAL_STATE_OVERRUN: u32 = 64;
pub const CDC_SERIAL_STATE_OVERRUN_Pos: u32 = 6;
pub const CDC_SERIAL_STATE_OVERRUN_Msk: u32 = 64;
pub const CDC_SERIAL_STATE_PARITY: u32 = 32;
pub const CDC_SERIAL_STATE_PARITY_Pos: u32 = 5;
pub const CDC_SERIAL_STATE_PARITY_Msk: u32 = 32;
pub const CDC_SERIAL_STATE_FRAMING: u32 = 16;
pub const CDC_SERIAL_STATE_FRAMING_Pos: u32 = 4;
pub const CDC_SERIAL_STATE_FRAMING_Msk: u32 = 16;
pub const CDC_SERIAL_STATE_RING: u32 = 8;
pub const CDC_SERIAL_STATE_RING_Pos: u32 = 3;
pub const CDC_SERIAL_STATE_RING_Msk: u32 = 8;
pub const CDC_SERIAL_STATE_BREAK: u32 = 4;
pub const CDC_SERIAL_STATE_BREAK_Pos: u32 = 2;
pub const CDC_SERIAL_STATE_BREAK_Msk: u32 = 4;
pub const CDC_SERIAL_STATE_TX_CARRIER: u32 = 2;
pub const CDC_SERIAL_STATE_TX_CARRIER_Pos: u32 = 1;
pub const CDC_SERIAL_STATE_TX_CARRIER_Msk: u32 = 2;
pub const CDC_SERIAL_STATE_RX_CARRIER: u32 = 1;
pub const CDC_SERIAL_STATE_RX_CARRIER_Pos: u32 = 0;
pub const CDC_SERIAL_STATE_RX_CARRIER_Msk: u32 = 1;
pub const CDC_ECM_XMIT_OK: u32 = 1;
pub const CDC_ECM_RVC_OK: u32 = 2;
pub const CDC_ECM_XMIT_ERROR: u32 = 4;
pub const CDC_ECM_RCV_ERROR: u32 = 8;
pub const CDC_ECM_RCV_NO_BUFFER: u32 = 16;
pub const CDC_ECM_DIRECTED_BYTES_XMIT: u32 = 32;
pub const CDC_ECM_DIRECTED_FRAMES_XMIT: u32 = 64;
pub const CDC_ECM_MULTICAST_BYTES_XMIT: u32 = 128;
pub const CDC_ECM_MULTICAST_FRAMES_XMIT: u32 = 256;
pub const CDC_ECM_BROADCAST_BYTES_XMIT: u32 = 512;
pub const CDC_ECM_BROADCAST_FRAMES_XMIT: u32 = 1024;
pub const CDC_ECM_DIRECTED_BYTES_RCV: u32 = 2048;
pub const CDC_ECM_DIRECTED_FRAMES_RCV: u32 = 4096;
pub const CDC_ECM_MULTICAST_BYTES_RCV: u32 = 8192;
pub const CDC_ECM_MULTICAST_FRAMES_RCV: u32 = 16384;
pub const CDC_ECM_BROADCAST_BYTES_RCV: u32 = 32768;
pub const CDC_ECM_BROADCAST_FRAMES_RCV: u32 = 65536;
pub const CDC_ECM_RCV_CRC_ERROR: u32 = 131072;
pub const CDC_ECM_TRANSMIT_QUEUE_LENGTH: u32 = 262144;
pub const CDC_ECM_RCV_ERROR_ALIGNMENT: u32 = 524288;
pub const CDC_ECM_XMIT_ONE_COLLISION: u32 = 1048576;
pub const CDC_ECM_XMIT_MORE_COLLISIONS: u32 = 2097152;
pub const CDC_ECM_XMIT_DEFERRED: u32 = 4194304;
pub const CDC_ECM_XMIT_MAX_COLLISIONS: u32 = 8388608;
pub const CDC_ECM_RCV_OVERRUN: u32 = 16777216;
pub const CDC_ECM_XMIT_UNDERRUN: u32 = 33554432;
pub const CDC_ECM_XMIT_HEARTBEAT_FAILURE: u32 = 67108864;
pub const CDC_ECM_XMIT_TIMES_CRS_LOST: u32 = 134217728;
pub const CDC_ECM_XMIT_LATE_COLLISIONS: u32 = 268435456;
pub const CDC_ECM_MAC_ADDR0: u32 = 0;
pub const CDC_ECM_MAC_ADDR1: u32 = 2;
pub const CDC_ECM_MAC_ADDR2: u32 = 2;
pub const CDC_ECM_MAC_ADDR3: u32 = 3;
pub const CDC_ECM_MAC_ADDR4: u32 = 0;
pub const CDC_ECM_MAC_ADDR5: u32 = 0;
pub const CDC_ECM_NET_DISCONNECTED: u32 = 0;
pub const CDC_ECM_NET_CONNECTED: u32 = 1;
pub const CDC_ECM_ETH_STATS_RESERVED: u32 = 224;
pub const CDC_ECM_BMREQUEST_TYPE_ECM: u32 = 161;
pub const CDC_ECM_CONNECT_SPEED_UPSTREAM: u32 = 5000000;
pub const CDC_ECM_CONNECT_SPEED_DOWNSTREAM: u32 = 5000000;
pub const CDC_ECM_NOTIFY_CODE_NETWORK_CONNECTION: u32 = 0;
pub const CDC_ECM_NOTIFY_CODE_RESPONSE_AVAILABLE: u32 = 1;
pub const CDC_ECM_NOTIFY_CODE_CONNECTION_SPEED_CHANGE: u32 = 42;
pub const CDC_NCM_NTH16_SIGNATURE: u32 = 1213023054;
pub const CDC_NCM_NDP16_SIGNATURE_NCM0: u32 = 810369870;
pub const CDC_NCM_NDP16_SIGNATURE_NCM1: u32 = 827147086;
pub const CDC_ACM_DESCRIPTOR_LEN: u32 = 66;
pub const CDC_RNDIS_DESCRIPTOR_LEN: u32 = 66;
pub const CDC_ECM_DESCRIPTOR_LEN: u32 = 70;
pub const CDC_NCM_DESCRIPTOR_LEN: u32 = 76;
pub const CONFIG_CDC_ECM_ETH_MAX_SEGSZE: u32 = 1514;
pub const DFU_VERSION: u32 = 272;
pub const DFU_SUBCLASS_DFU: u32 = 1;
pub const DFU_PROTOCOL_RUNTIME: u32 = 1;
pub const DFU_PROTOCOL_MODE: u32 = 2;
pub const DFU_REQUEST_DETACH: u32 = 0;
pub const DFU_REQUEST_DNLOAD: u32 = 1;
pub const DFU_REQUEST_UPLOAD: u32 = 2;
pub const DFU_REQUEST_GETSTATUS: u32 = 3;
pub const DFU_REQUEST_CLRSTATUS: u32 = 4;
pub const DFU_REQUEST_GETSTATE: u32 = 5;
pub const DFU_REQUEST_ABORT: u32 = 6;
pub const DFU_FUNC_DESC: u32 = 33;
pub const DFU_ATTR_WILL_DETACH: u32 = 8;
pub const DFU_ATTR_MANIFESTATION_TOLERANT: u32 = 4;
pub const DFU_ATTR_CAN_UPLOAD: u32 = 2;
pub const DFU_ATTR_CAN_DNLOAD: u32 = 1;
pub const DFU_STATUS_OK: u32 = 0;
pub const DFU_STATUS_ERR_TARGET: u32 = 1;
pub const DFU_STATUS_ERR_FILE: u32 = 2;
pub const DFU_STATUS_ERR_WRITE: u32 = 3;
pub const DFU_STATUS_ERR_ERASE: u32 = 4;
pub const DFU_STATUS_ERR_CHECK_ERASED: u32 = 5;
pub const DFU_STATUS_ERR_PROG: u32 = 6;
pub const DFU_STATUS_ERR_VERIFY: u32 = 7;
pub const DFU_STATUS_ERR_ADDRESS: u32 = 8;
pub const DFU_STATUS_ERR_NOTDONE: u32 = 9;
pub const DFU_STATUS_ERR_FIRMWARE: u32 = 10;
pub const DFU_STATUS_ERR_VENDOR: u32 = 11;
pub const DFU_STATUS_ERR_USB: u32 = 12;
pub const DFU_STATUS_ERR_POR: u32 = 13;
pub const DFU_STATUS_ERR_UNKNOWN: u32 = 14;
pub const DFU_STATUS_ERR_STALLEDPKT: u32 = 15;
pub const DFU_STATE_APP_IDLE: u32 = 0;
pub const DFU_STATE_APP_DETACH: u32 = 1;
pub const DFU_STATE_DFU_IDLE: u32 = 2;
pub const DFU_STATE_DFU_DNLOAD_SYNC: u32 = 3;
pub const DFU_STATE_DFU_DNLOAD_BUSY: u32 = 4;
pub const DFU_STATE_DFU_DNLOAD_IDLE: u32 = 5;
pub const DFU_STATE_DFU_MANIFEST_SYNC: u32 = 6;
pub const DFU_STATE_DFU_MANIFEST: u32 = 7;
pub const DFU_STATE_DFU_MANIFEST_WAIT_RESET: u32 = 8;
pub const DFU_STATE_DFU_UPLOAD_IDLE: u32 = 9;
pub const DFU_STATE_DFU_ERROR: u32 = 10;
pub const DFU_MANIFEST_COMPLETE: u32 = 0;
pub const DFU_MANIFEST_IN_PROGRESS: u32 = 1;
pub const DFU_CMD_GETCOMMANDS: u32 = 0;
pub const DFU_CMD_SETADDRESSPOINTER: u32 = 33;
pub const DFU_CMD_ERASE: u32 = 65;
pub const DFU_MEDIA_ERASE: u32 = 0;
pub const DFU_MEDIA_PROGRAM: u32 = 1;
pub const DFU_DETACH_MASK: u32 = 8;
pub const DFU_MANIFEST_MASK: u32 = 4;
pub const HID_SUBCLASS_NONE: u32 = 0;
pub const HID_SUBCLASS_BOOTIF: u32 = 1;
pub const HID_PROTOCOL_NONE: u32 = 0;
pub const HID_PROTOCOL_BOOT: u32 = 0;
pub const HID_PROTOCOL_KEYBOARD: u32 = 1;
pub const HID_PROTOCOL_REPORT: u32 = 1;
pub const HID_PROTOCOL_MOUSE: u32 = 2;
pub const HID_DESCRIPTOR_TYPE_HID: u32 = 33;
pub const HID_DESCRIPTOR_TYPE_HID_REPORT: u32 = 34;
pub const HID_DESCRIPTOR_TYPE_HID_PHYSICAL: u32 = 35;
pub const HID_REQUEST_GET_REPORT: u32 = 1;
pub const HID_REQUEST_GET_IDLE: u32 = 2;
pub const HID_REQUEST_GET_PROTOCOL: u32 = 3;
pub const HID_REQUEST_SET_REPORT: u32 = 9;
pub const HID_REQUEST_SET_IDLE: u32 = 10;
pub const HID_REQUEST_SET_PROTOCOL: u32 = 11;
pub const HID_REPORT_INPUT: u32 = 1;
pub const HID_REPORT_OUTPUT: u32 = 2;
pub const HID_REPORT_FEATURE: u32 = 3;
pub const HID_COUNTRY_NONE: u32 = 0;
pub const HID_COUNTRY_ARABIC: u32 = 1;
pub const HID_COUNTRY_BELGIAN: u32 = 2;
pub const HID_COUNTRY_CANADA: u32 = 3;
pub const HID_COUNTRY_CANADRFR: u32 = 4;
pub const HID_COUNTRY_CZECH: u32 = 5;
pub const HID_COUNTRY_DANISH: u32 = 6;
pub const HID_COUNTRY_FINNISH: u32 = 7;
pub const HID_COUNTRY_FRENCH: u32 = 8;
pub const HID_COUNTRY_GERMAN: u32 = 9;
pub const HID_COUNTRY_GREEK: u32 = 16;
pub const HID_COUNTRY_HEBREW: u32 = 17;
pub const HID_COUNTRY_HUNGARY: u32 = 18;
pub const HID_COUNTRY_ISO: u32 = 19;
pub const HID_COUNTRY_ITALIAN: u32 = 20;
pub const HID_COUNTRY_JAPAN: u32 = 21;
pub const HID_COUNTRY_KOREAN: u32 = 22;
pub const HID_COUNTRY_LATINAM: u32 = 23;
pub const HID_COUNTRY_DUTCH: u32 = 24;
pub const HID_COUNTRY_NORWEGIAN: u32 = 25;
pub const HID_COUNTRY_PERSIAN: u32 = 32;
pub const HID_COUNTRY_POLAND: u32 = 33;
pub const HID_COUNTRY_PORTUGUESE: u32 = 34;
pub const HID_COUNTRY_RUSSIA: u32 = 35;
pub const HID_COUNTRY_SLOVAKIA: u32 = 36;
pub const HID_COUNTRY_SPANISH: u32 = 37;
pub const HID_COUNTRY_SWEDISH: u32 = 38;
pub const HID_COUNTRY_SWISSFR: u32 = 39;
pub const HID_COUNTRY_SWISSGR: u32 = 40;
pub const HID_COUNTRY_SWITZERLAND: u32 = 41;
pub const HID_COUNTRY_TAIWAN: u32 = 48;
pub const HID_COUNTRY_TURKISHQ: u32 = 49;
pub const HID_COUNTRY_UK: u32 = 50;
pub const HID_COUNTRY_US: u32 = 51;
pub const HID_COUNTRY_YUGOSLAVIA: u32 = 52;
pub const HID_COUNTRY_TURKISHF: u32 = 53;
pub const HID_REPORT_ITEM_SIZE_MASK: u32 = 3;
pub const HID_REPORT_ITEM_SIZE_0: u32 = 0;
pub const HID_REPORT_ITEM_SIZE_1: u32 = 1;
pub const HID_REPORT_ITEM_SIZE_2: u32 = 2;
pub const HID_REPORT_ITEM_SIZE_4: u32 = 3;
pub const HID_REPORT_ITEM_TYPE_MASK: u32 = 12;
pub const HID_REPORT_ITEM_TYPE_MAIN: u32 = 0;
pub const HID_REPORT_ITEM_TYPE_GLOBAL: u32 = 4;
pub const HID_REPORT_ITEM_TYPE_LOCAL: u32 = 8;
pub const HID_REPORT_ITEM_TAG_MASK: u32 = 240;
pub const HID_MAIN_ITEM_CONSTANT: u32 = 1;
pub const HID_MAIN_ITEM_VARIABLE: u32 = 2;
pub const HID_MAIN_ITEM_RELATIVE: u32 = 4;
pub const HID_MAIN_ITEM_WRAP: u32 = 8;
pub const HID_MAIN_ITEM_NONLINEAR: u32 = 16;
pub const HID_MAIN_ITEM_NOPREFERRED: u32 = 32;
pub const HID_MAIN_ITEM_NULLSTATE: u32 = 64;
pub const HID_MAIN_ITEM_VOLATILE: u32 = 128;
pub const HID_MAIN_ITEM_BUFFEREDBYTES: u32 = 256;
pub const HID_MAIN_ITEM_INPUT_PREFIX: u32 = 128;
pub const HID_MAIN_ITEM_INPUT_CONSTANT: u32 = 1;
pub const HID_MAIN_ITEM_INPUT_VARIABLE: u32 = 2;
pub const HID_MAIN_ITEM_INPUT_RELATIVE: u32 = 4;
pub const HID_MAIN_ITEM_INPUT_WRAP: u32 = 8;
pub const HID_MAIN_ITEM_INPUT_NONLINEAR: u32 = 16;
pub const HID_MAIN_ITEM_INPUT_NOPREFERRED: u32 = 32;
pub const HID_MAIN_ITEM_INPUT_NULLSTATE: u32 = 64;
pub const HID_MAIN_ITEM_INPUT_BUFFEREDBYTES: u32 = 256;
pub const HID_MAIN_ITEM_OUTPUT_PREFIX: u32 = 144;
pub const HID_MAIN_ITEM_OUTPUT_CONSTANT: u32 = 1;
pub const HID_MAIN_ITEM_OUTPUT_VARIABLE: u32 = 2;
pub const HID_MAIN_ITEM_OUTPUT_RELATIVE: u32 = 4;
pub const HID_MAIN_ITEM_OUTPUT_WRAP: u32 = 8;
pub const HID_MAIN_ITEM_OUTPUT_NONLINEAR: u32 = 16;
pub const HID_MAIN_ITEM_OUTPUT_NOPREFERRED: u32 = 32;
pub const HID_MAIN_ITEM_OUTPUT_NULLSTATE: u32 = 64;
pub const HID_MAIN_ITEM_OUTPUT_VOLATILE: u32 = 128;
pub const HID_MAIN_ITEM_OUTPUT_BUFFEREDBYTES: u32 = 256;
pub const HID_MAIN_ITEM_FEATURE_PREFIX: u32 = 176;
pub const HID_MAIN_ITEM_FEATURE_CONSTANT: u32 = 1;
pub const HID_MAIN_ITEM_FEATURE_VARIABLE: u32 = 2;
pub const HID_MAIN_ITEM_FEATURE_RELATIVE: u32 = 4;
pub const HID_MAIN_ITEM_FEATURE_WRAP: u32 = 8;
pub const HID_MAIN_ITEM_FEATURE_NONLINEAR: u32 = 16;
pub const HID_MAIN_ITEM_FEATURE_NOPREFERRED: u32 = 32;
pub const HID_MAIN_ITEM_FEATURE_NULLSTATE: u32 = 64;
pub const HID_MAIN_ITEM_FEATURE_VOLATILE: u32 = 128;
pub const HID_MAIN_ITEM_FEATURE_BUFFEREDBYTES: u32 = 256;
pub const HID_MAIN_ITEM_COLLECTION_PREFIX: u32 = 160;
pub const HID_MAIN_ITEM_COLLECTION_PHYSICAL: u32 = 0;
pub const HID_MAIN_ITEM_COLLECTION_APPL: u32 = 1;
pub const HID_MAIN_ITEM_COLLECTION_LOGICAL: u32 = 2;
pub const HID_MAIN_ITEM_COLLECTION_REPORT: u32 = 3;
pub const HID_MAIN_ITEM_COLLECTION_ARRAY: u32 = 4;
pub const HID_MAIN_ITEM_COLLECTION_SWITCH: u32 = 5;
pub const HID_MAIN_ITEM_COLLECTION_MODIFIER: u32 = 6;
pub const HID_MAIN_ITEM_ENDCOLLECTION_PREFIX: u32 = 192;
pub const HID_GLOBAL_ITEM_USAGEPAGE_PREFIX: u32 = 4;
pub const HID_GLOBAL_ITEM_LOGICALMIN_PREFIX: u32 = 20;
pub const HID_GLOBAL_ITEM_LOGICALMAX_PREFIX: u32 = 36;
pub const HID_GLOBAL_ITEM_PHYSICALMIN_PREFIX: u32 = 52;
pub const HID_GLOBAL_ITEM_PHYSMICALAX_PREFIX: u32 = 68;
pub const HID_GLOBAL_ITEM_UNITEXP_PREFIX: u32 = 84;
pub const HID_GLOBAL_ITEM_UNIT_PREFIX: u32 = 100;
pub const HID_GLOBAL_ITEM_REPORTSIZE_PREFIX: u32 = 116;
pub const HID_GLOBAL_ITEM_REPORTID_PREFIX: u32 = 132;
pub const HID_GLOBAL_ITEM_REPORTCOUNT_PREFIX: u32 = 148;
pub const HID_GLOBAL_ITEM_PUSH_PREFIX: u32 = 164;
pub const HID_GLOBAL_ITEM_POP_PREFIX: u32 = 180;
pub const HID_LOCAL_ITEM_USAGE_PREFIX: u32 = 8;
pub const HID_LOCAL_ITEM_USAGEMIN_PREFIX: u32 = 24;
pub const HID_LOCAL_ITEM_USAGEMAX_PREFIX: u32 = 40;
pub const HID_LOCAL_ITEM_DESIGNATORIDX_PREFIX: u32 = 56;
pub const HID_LOCAL_ITEM_DESIGNATORMIN_PREFIX: u32 = 72;
pub const HID_LOCAL_ITEM_DESIGNATORMAX_PREFIX: u32 = 88;
pub const HID_LOCAL_ITEM_STRINGIDX_PREFIX: u32 = 120;
pub const HID_LOCAL_ITEM_STRINGMIN_PREFIX: u32 = 136;
pub const HID_LOCAL_ITEM_STRINGMAX_PREFIX: u32 = 152;
pub const HID_LOCAL_ITEM_DELIMITER_PREFIX: u32 = 168;
pub const HID_MODIFER_LCTRL: u32 = 1;
pub const HID_MODIFER_LSHIFT: u32 = 2;
pub const HID_MODIFER_LALT: u32 = 4;
pub const HID_MODIFER_LGUI: u32 = 8;
pub const HID_MODIFER_RCTRL: u32 = 16;
pub const HID_MODIFER_RSHIFT: u32 = 32;
pub const HID_MODIFER_RALT: u32 = 64;
pub const HID_MODIFER_RGUI: u32 = 128;
pub const HID_KBD_OUTPUT_REPORT_NUMLOCK: u32 = 1;
pub const HID_KBD_OUTPUT_REPORT_CAPSLOCK: u32 = 2;
pub const HID_KBD_OUTPUT_REPORT_SCROLLLOCK: u32 = 4;
pub const HID_KBD_OUTPUT_REPORT_COMPOSE: u32 = 8;
pub const HID_KBD_OUTPUT_REPORT_KANA: u32 = 16;
pub const HID_MOUSE_INPUT_REPORT_BUTTON1: u32 = 1;
pub const HID_MOUSE_INPUT_REPORT_BUTTON2: u32 = 2;
pub const HID_MOUSE_INPUT_REPORT_BUTTON3: u32 = 4;
pub const HID_MOUSE_INPUT_REPORT_BUTTON_MASK: u32 = 7;
pub const HID_MOUSE_INPUT_BUTTON_LEFT: u32 = 1;
pub const HID_MOUSE_INPUT_BUTTON_RIGHT: u32 = 2;
pub const HID_MOUSE_INPUT_BUTTON_MIDDLE: u32 = 4;
pub const HID_MOUSE_INPUT_BUTTON_BACKWARD: u32 = 8;
pub const HID_MOUSE_INPUT_BUTTON_FORWARD: u32 = 16;
pub const HID_JS_INPUT_REPORT_HATSWITCH_SHIFT: u32 = 0;
pub const HID_JS_INPUT_REPORT_BUTTON1: u32 = 16;
pub const HID_JS_INPUT_REPORT_BUTTON2: u32 = 32;
pub const HID_JS_INPUT_REPORT_BUTTON3: u32 = 64;
pub const HID_JS_INPUT_REPORT_BUTTON4: u32 = 128;
pub const HID_USAGE_PAGE_UNDEFINED: u32 = 0;
pub const HID_USAGE_PAGE_GENERIC_DCTRL: u32 = 1;
pub const HID_USAGE_PAGE_SIMCTRL: u32 = 2;
pub const HID_USAGE_PAGE_VRCTRL: u32 = 3;
pub const HID_USAGE_PAGE_SPORTCTRL: u32 = 4;
pub const HID_USAGE_PAGE_GAMECTRL: u32 = 5;
pub const HID_USAGE_PAGE_GENERIC_DEVCTRL: u32 = 6;
pub const HID_USAGE_PAGE_KBD: u32 = 7;
pub const HID_USAGE_PAGE_LEDS: u32 = 8;
pub const HID_USAGE_PAGE_BUTTON: u32 = 9;
pub const HID_USAGE_PAGE_ORDINAL: u32 = 10;
pub const HID_USAGE_PAGE_TELEPHONY: u32 = 11;
pub const HID_USAGE_PAGE_CONSUMER: u32 = 12;
pub const HID_USAGE_PAGE_DIGITIZER: u32 = 13;
pub const HID_USAGE_PAGE_PIDPAGE: u32 = 15;
pub const HID_USAGE_PAGE_UNICODE: u32 = 16;
pub const HID_USAGE_PAGE_ALPHA_DISPLAY: u32 = 20;
pub const HID_USAGE_PAGE_MEDICAL: u32 = 64;
pub const HID_USAGE_PAGE_BARCODE_SCANNER: u32 = 140;
pub const HID_USAGE_PAGE_SCALE: u32 = 141;
pub const HID_USAGE_PAGE_MSR: u32 = 142;
pub const HID_USAGE_PAGE_POS: u32 = 143;
pub const HID_USAGE_PAGE_CAMERA_CTRL: u32 = 144;
pub const HID_DESKTOP_USAGE_UNDEFINED: u32 = 0;
pub const HID_DESKTOP_USAGE_POINTER: u32 = 1;
pub const HID_DESKTOP_USAGE_MOUSE: u32 = 2;
pub const HID_DESKTOP_USAGE_JOYSTICK: u32 = 4;
pub const HID_DESKTOP_USAGE_GAMEPAD: u32 = 5;
pub const HID_DESKTOP_USAGE_KEYBOARD: u32 = 6;
pub const HID_DESKTOP_USAGE_KEYPAD: u32 = 7;
pub const HID_DESKTOP_USAGE_MULTIAXIS: u32 = 8;
pub const HID_DESKTOP_USAGE_TABLET: u32 = 9;
pub const HID_DESKTOP_USAGE_X: u32 = 48;
pub const HID_DESKTOP_USAGE_Y: u32 = 49;
pub const HID_DESKTOP_USAGE_Z: u32 = 50;
pub const HID_DESKTOP_USAGE_RX: u32 = 51;
pub const HID_DESKTOP_USAGE_RY: u32 = 52;
pub const HID_DESKTOP_USAGE_RZ: u32 = 53;
pub const HID_DESKTOP_USAGE_SLIDER: u32 = 54;
pub const HID_DESKTOP_USAGE_DIAL: u32 = 55;
pub const HID_DESKTOP_USAGE_WHEEL: u32 = 56;
pub const HID_DESKTOP_USAGE_HATSWITCH: u32 = 57;
pub const HID_DESKTOP_USAGE_COUNTED: u32 = 58;
pub const HID_DESKTOP_USAGE_BYTECOUNT: u32 = 59;
pub const HID_DESKTOP_USAGE_MOTION: u32 = 60;
pub const HID_DESKTOP_USAGE_START: u32 = 61;
pub const HID_DESKTOP_USAGE_SELECT: u32 = 62;
pub const HID_DESKTOP_USAGE_VX: u32 = 64;
pub const HID_DESKTOP_USAGE_VY: u32 = 65;
pub const HID_DESKTOP_USAGE_VZ: u32 = 66;
pub const HID_DESKTOP_USAGE_VBRX: u32 = 67;
pub const HID_DESKTOP_USAGE_VBRY: u32 = 68;
pub const HID_DESKTOP_USAGE_VBRZ: u32 = 69;
pub const HID_DESKTOP_USAGE_VNO: u32 = 70;
pub const HID_DESKTOP_USAGE_FEATURE: u32 = 71;
pub const HID_DESKTOP_USAGE_RESOLUTION: u32 = 72;
pub const HID_DESKTOP_USAGE_CONTROL: u32 = 128;
pub const HID_DESKTOP_USAGE_POWERDOWN: u32 = 129;
pub const HID_DESKTOP_USAGE_SLEEP: u32 = 130;
pub const HID_DESKTOP_USAGE_WAKEUP: u32 = 131;
pub const HID_DESKTOP_USAGE_CONTEXT_MENU: u32 = 132;
pub const HID_DESKTOP_USAGE_MAIN_MENU: u32 = 133;
pub const HID_DESKTOP_USAGE_APP_MENU: u32 = 134;
pub const HID_DESKTOP_USAGE_MENU_HELP: u32 = 135;
pub const HID_DESKTOP_USAGE_MENU_EXIT: u32 = 136;
pub const HID_DESKTOP_USAGE_MENU_SELECT: u32 = 137;
pub const HID_DESKTOP_USAGE_MENU_RIGHT: u32 = 138;
pub const HID_DESKTOP_USAGE_MENU_LEFT: u32 = 139;
pub const HID_DESKTOP_USAGE_MENU_UP: u32 = 140;
pub const HID_DESKTOP_USAGE_MENU_DOWN: u32 = 141;
pub const HID_DESKTOP_USAGE_COLD_RESTART: u32 = 142;
pub const HID_DESKTOP_USAGE_WARM_RESTART: u32 = 143;
pub const HID_DESKTOP_USAGE_DPAD_UP: u32 = 144;
pub const HID_DESKTOP_USAGE_DPAD_DOWN: u32 = 145;
pub const HID_DESKTOP_USAGE_DPAD_RIGHT: u32 = 146;
pub const HID_DESKTOP_USAGE_DPAD_LEFT: u32 = 147;
pub const HID_DESKTOP_USAGE_DOCK: u32 = 160;
pub const HID_DESKTOP_USAGE_UNDOCK: u32 = 161;
pub const HID_DESKTOP_USAGE_SETUP: u32 = 162;
pub const HID_DESKTOP_USAGE_BREAK: u32 = 163;
pub const HID_DESKTOP_USAGE_DEBUG_BREAK: u32 = 164;
pub const HID_DESKTOP_USAGE_APP_BREAK: u32 = 165;
pub const HID_DESKTOP_USAGE_APP_DEBUG_BREAK: u32 = 166;
pub const HID_DESKTOP_USAGE_MUTE: u32 = 167;
pub const HID_DESKTOP_USAGE_HIBERNATE: u32 = 168;
pub const HID_DESKTOP_USAGE_DISPLAY_INVERT: u32 = 176;
pub const HID_DESKTOP_USAGE_DISPALY_INTERNAL: u32 = 177;
pub const HID_DESKTOP_USAGE_DISPLAY_EXTERNAL: u32 = 178;
pub const HID_DESKTOP_USAGE_DISPLAY_BOTH: u32 = 179;
pub const HID_DESKTOP_USAGE_DISPLAY_DUAL: u32 = 180;
pub const HID_DESKTOP_USAGE_DISPLAY_TOGGLE: u32 = 181;
pub const HID_DESKTOP_USAGE_DISPLAY_SWAP: u32 = 182;
pub const HID_DESKTOP_USAGE_: u32 = 183;
pub const HID_KBD_USAGE_NONE: u32 = 0;
pub const HID_KBD_USAGE_ERRORROLLOVER: u32 = 1;
pub const HID_KBD_USAGE_POSTFAIL: u32 = 2;
pub const HID_KBD_USAGE_ERRUNDEF: u32 = 3;
pub const HID_KBD_USAGE_A: u32 = 4;
pub const HID_KBD_USAGE_1: u32 = 30;
pub const HID_KBD_USAGE_EXCLAM: u32 = 30;
pub const HID_KBD_USAGE_AT: u32 = 31;
pub const HID_KBD_USAGE_POUND: u32 = 32;
pub const HID_KBD_USAGE_DOLLAR: u32 = 33;
pub const HID_KBD_USAGE_PERCENT: u32 = 34;
pub const HID_KBD_USAGE_CARAT: u32 = 35;
pub const HID_KBD_USAGE_AMPERSAND: u32 = 36;
pub const HID_KBD_USAGE_ASTERISK: u32 = 37;
pub const HID_KBD_USAGE_LPAREN: u32 = 38;
pub const HID_KBD_USAGE_0: u32 = 39;
pub const HID_KBD_USAGE_RPAREN: u32 = 39;
pub const HID_KBD_USAGE_ENTER: u32 = 40;
pub const HID_KBD_USAGE_ESCAPE: u32 = 41;
pub const HID_KBD_USAGE_DELETE: u32 = 42;
pub const HID_KBD_USAGE_TAB: u32 = 43;
pub const HID_KBD_USAGE_SPACE: u32 = 44;
pub const HID_KBD_USAGE_HYPHEN: u32 = 45;
pub const HID_KBD_USAGE_UNDERSCORE: u32 = 45;
pub const HID_KBD_USAGE_EQUAL: u32 = 46;
pub const HID_KBD_USAGE_PLUS: u32 = 46;
pub const HID_KBD_USAGE_LBRACKET: u32 = 47;
pub const HID_KBD_USAGE_LBRACE: u32 = 47;
pub const HID_KBD_USAGE_RBRACKET: u32 = 48;
pub const HID_KBD_USAGE_RBRACE: u32 = 48;
pub const HID_KBD_USAGE_BSLASH: u32 = 49;
pub const HID_KBD_USAGE_VERTBAR: u32 = 49;
pub const HID_KBD_USAGE_NONUSPOUND: u32 = 50;
pub const HID_KBD_USAGE_TILDE: u32 = 50;
pub const HID_KBD_USAGE_SEMICOLON: u32 = 51;
pub const HID_KBD_USAGE_COLON: u32 = 51;
pub const HID_KBD_USAGE_SQUOTE: u32 = 52;
pub const HID_KBD_USAGE_DQUOUTE: u32 = 52;
pub const HID_KBD_USAGE_GACCENT: u32 = 53;
pub const HID_KBD_USAGE_GTILDE: u32 = 53;
pub const HID_KBD_USAGE_COMMON: u32 = 54;
pub const HID_KBD_USAGE_LT: u32 = 54;
pub const HID_KBD_USAGE_PERIOD: u32 = 55;
pub const HID_KBD_USAGE_GT: u32 = 55;
pub const HID_KBD_USAGE_DIV: u32 = 56;
pub const HID_KBD_USAGE_QUESTION: u32 = 56;
pub const HID_KBD_USAGE_CAPSLOCK: u32 = 57;
pub const HID_KBD_USAGE_F1: u32 = 58;
pub const HID_KBD_USAGE_F2: u32 = 59;
pub const HID_KBD_USAGE_F3: u32 = 60;
pub const HID_KBD_USAGE_F4: u32 = 61;
pub const HID_KBD_USAGE_F5: u32 = 62;
pub const HID_KBD_USAGE_F6: u32 = 63;
pub const HID_KBD_USAGE_F7: u32 = 64;
pub const HID_KBD_USAGE_F8: u32 = 65;
pub const HID_KBD_USAGE_F9: u32 = 66;
pub const HID_KBD_USAGE_F10: u32 = 67;
pub const HID_KBD_USAGE_F11: u32 = 68;
pub const HID_KBD_USAGE_F12: u32 = 69;
pub const HID_KBD_USAGE_PRINTSCN: u32 = 70;
pub const HID_KBD_USAGE_SCROLLLOCK: u32 = 71;
pub const HID_KBD_USAGE_PAUSE: u32 = 72;
pub const HID_KBD_USAGE_INSERT: u32 = 73;
pub const HID_KBD_USAGE_HOME: u32 = 74;
pub const HID_KBD_USAGE_PAGEUP: u32 = 75;
pub const HID_KBD_USAGE_DELFWD: u32 = 76;
pub const HID_KBD_USAGE_END: u32 = 77;
pub const HID_KBD_USAGE_PAGEDOWN: u32 = 78;
pub const HID_KBD_USAGE_RIGHT: u32 = 79;
pub const HID_KBD_USAGE_LEFT: u32 = 80;
pub const HID_KBD_USAGE_DOWN: u32 = 81;
pub const HID_KBD_USAGE_UP: u32 = 82;
pub const HID_KBD_USAGE_KPDNUMLOCK: u32 = 83;
pub const HID_KBD_USAGE_KPDNUMLOCKCLEAR: u32 = 83;
pub const HID_KBD_USAGE_KPDDIV: u32 = 84;
pub const HID_KBD_USAGE_KPDMUL: u32 = 85;
pub const HID_KBD_USAGE_KPDHMINUS: u32 = 86;
pub const HID_KBD_USAGE_KPDPLUS: u32 = 87;
pub const HID_KBD_USAGE_KPDEMTER: u32 = 88;
pub const HID_KBD_USAGE_KPD1: u32 = 89;
pub const HID_KBD_USAGE_KPDEND: u32 = 89;
pub const HID_KBD_USAGE_KPDDOWN: u32 = 90;
pub const HID_KBD_USAGE_KPDPAGEDN: u32 = 91;
pub const HID_KBD_USAGE_KPDLEFT: u32 = 92;
pub const HID_KBD_USAGE_KPDRIGHT: u32 = 94;
pub const HID_KBD_USAGE_KPDHOME: u32 = 95;
pub const HID_KBD_USAGE_KPDUP: u32 = 96;
pub const HID_KBD_USAGE_KPDPAGEUP: u32 = 97;
pub const HID_KBD_USAGE_KPD0: u32 = 98;
pub const HID_KBD_USAGE_KPDINSERT: u32 = 98;
pub const HID_KBD_USAGE_KPDDECIMALPT: u32 = 99;
pub const HID_KBD_USAGE_KPDDELETE: u32 = 99;
pub const HID_KBD_USAGE_NONSLASH: u32 = 100;
pub const HID_KBD_USAGE_NONUSVERT: u32 = 100;
pub const HID_KBD_USAGE_APPLICATION: u32 = 101;
pub const HID_KBD_USAGE_POWER: u32 = 102;
pub const HID_KBD_USAGE_KPDEQUAL: u32 = 103;
pub const HID_KBD_USAGE_F13: u32 = 104;
pub const HID_KBD_USAGE_F14: u32 = 105;
pub const HID_KBD_USAGE_F15: u32 = 106;
pub const HID_KBD_USAGE_F16: u32 = 107;
pub const HID_KBD_USAGE_F17: u32 = 108;
pub const HID_KBD_USAGE_F18: u32 = 109;
pub const HID_KBD_USAGE_F19: u32 = 110;
pub const HID_KBD_USAGE_F20: u32 = 111;
pub const HID_KBD_USAGE_F21: u32 = 112;
pub const HID_KBD_USAGE_F22: u32 = 113;
pub const HID_KBD_USAGE_F23: u32 = 114;
pub const HID_KBD_USAGE_F24: u32 = 115;
pub const HID_KBD_USAGE_EXECUTE: u32 = 116;
pub const HID_KBD_USAGE_HELP: u32 = 117;
pub const HID_KBD_USAGE_MENU: u32 = 118;
pub const HID_KBD_USAGE_SELECT: u32 = 119;
pub const HID_KBD_USAGE_STOP: u32 = 120;
pub const HID_KBD_USAGE_AGAIN: u32 = 121;
pub const HID_KBD_USAGE_UNDO: u32 = 122;
pub const HID_KBD_USAGE_CUT: u32 = 123;
pub const HID_KBD_USAGE_COPY: u32 = 124;
pub const HID_KBD_USAGE_PASTE: u32 = 125;
pub const HID_KBD_USAGE_FIND: u32 = 126;
pub const HID_KBD_USAGE_MUTE: u32 = 127;
pub const HID_KBD_USAGE_VOLUP: u32 = 128;
pub const HID_KBD_USAGE_VOLDOWN: u32 = 129;
pub const HID_KBD_USAGE_LCAPSLOCK: u32 = 130;
pub const HID_KBD_USAGE_LNUMLOCK: u32 = 131;
pub const HID_KBD_USAGE_LSCROLLLOCK: u32 = 132;
pub const HID_KBD_USAGE_KPDCOMMA: u32 = 133;
pub const HID_KBD_USAGE_KPDEQUALSIGN: u32 = 134;
pub const HID_KBD_USAGE_INTERNATIONAL1: u32 = 135;
pub const HID_KBD_USAGE_INTERNATIONAL2: u32 = 136;
pub const HID_KBD_USAGE_INTERNATIONAL3: u32 = 137;
pub const HID_KBD_USAGE_INTERNATIONAL4: u32 = 138;
pub const HID_KBD_USAGE_INTERNATIONAL5: u32 = 139;
pub const HID_KBD_USAGE_INTERNATIONAL6: u32 = 140;
pub const HID_KBD_USAGE_INTERNATIONAL7: u32 = 141;
pub const HID_KBD_USAGE_INTERNATIONAL8: u32 = 142;
pub const HID_KBD_USAGE_INTERNATIONAL9: u32 = 143;
pub const HID_KBD_USAGE_LANG1: u32 = 144;
pub const HID_KBD_USAGE_LANG2: u32 = 145;
pub const HID_KBD_USAGE_LANG3: u32 = 146;
pub const HID_KBD_USAGE_LANG4: u32 = 147;
pub const HID_KBD_USAGE_LANG5: u32 = 148;
pub const HID_KBD_USAGE_LANG6: u32 = 149;
pub const HID_KBD_USAGE_LANG7: u32 = 150;
pub const HID_KBD_USAGE_LANG8: u32 = 151;
pub const HID_KBD_USAGE_LANG9: u32 = 152;
pub const HID_KBD_USAGE_ALTERASE: u32 = 153;
pub const HID_KBD_USAGE_SYSREQ: u32 = 154;
pub const HID_KBD_USAGE_CANCEL: u32 = 155;
pub const HID_KBD_USAGE_CLEAR: u32 = 156;
pub const HID_KBD_USAGE_PRIOR: u32 = 157;
pub const HID_KBD_USAGE_RETURN: u32 = 158;
pub const HID_KBD_USAGE_SEPARATOR: u32 = 159;
pub const HID_KBD_USAGE_OUT: u32 = 160;
pub const HID_KBD_USAGE_OPER: u32 = 161;
pub const HID_KBD_USAGE_CLEARAGAIN: u32 = 162;
pub const HID_KBD_USAGE_CLRSEL: u32 = 163;
pub const HID_KBD_USAGE_EXSEL: u32 = 164;
pub const HID_KBD_USAGE_KPD00: u32 = 176;
pub const HID_KBD_USAGE_KPD000: u32 = 177;
pub const HID_KBD_USAGE_THOUSEPARATOR: u32 = 178;
pub const HID_KBD_USAGE_DECSEPARATOR: u32 = 179;
pub const HID_KBD_USAGE_CURRUNIT: u32 = 180;
pub const HID_KBD_USAGE_CURRSUBUNIT: u32 = 181;
pub const HID_KBD_USAGE_KPDLPAREN: u32 = 182;
pub const HID_KBD_USAGE_KPDRPAREN: u32 = 183;
pub const HID_KBD_USAGE_KPDLBRACE: u32 = 184;
pub const HID_KBD_USAGE_KPDRBRACE: u32 = 185;
pub const HID_KBD_USAGE_KPDTAB: u32 = 186;
pub const HID_KBD_USAGE_KPDBACKSPACE: u32 = 187;
pub const HID_KBD_USAGE_KPDA: u32 = 188;
pub const HID_KBD_USAGE_KPDXOR: u32 = 194;
pub const HID_KBD_USAGE_KPDEXP: u32 = 195;
pub const HID_KBD_USAGE_KPDPERCENT: u32 = 196;
pub const HID_KBD_USAGE_KPDLT: u32 = 197;
pub const HID_KBD_USAGE_KPDGT: u32 = 198;
pub const HID_KBD_USAGE_KPDAMPERSAND: u32 = 199;
pub const HID_KBD_USAGE_KPDAND: u32 = 200;
pub const HID_KBD_USAGE_KPDVERT: u32 = 201;
pub const HID_KBD_USAGE_KPDOR: u32 = 202;
pub const HID_KBD_USAGE_KPDCOLON: u32 = 203;
pub const HID_KBD_USAGE_KPDPOUND: u32 = 204;
pub const HID_KBD_USAGE_KPDSPACE: u32 = 205;
pub const HID_KBD_USAGE_KPDAT: u32 = 206;
pub const HID_KBD_USAGE_KPDEXCLAM: u32 = 207;
pub const HID_KBD_USAGE_KPDMEMSTORE: u32 = 208;
pub const HID_KBD_USAGE_KPDMEMRECALL: u32 = 209;
pub const HID_KBD_USAGE_KPDMEMCLEAR: u32 = 210;
pub const HID_KBD_USAGE_KPDMEMADD: u32 = 211;
pub const HID_KBD_USAGE_KPDMEMSUB: u32 = 212;
pub const HID_KBD_USAGE_KPDMEMMULT: u32 = 213;
pub const HID_KBD_USAGE_KPDMEMDIV: u32 = 214;
pub const HID_KBD_USAGE_KPDPLUSMINUS: u32 = 215;
pub const HID_KBD_USAGE_KPDCLEAR: u32 = 216;
pub const HID_KBD_USAGE_KPDCLEARENTRY: u32 = 217;
pub const HID_KBD_USAGE_KPDBINARY: u32 = 218;
pub const HID_KBD_USAGE_KPDOCTAL: u32 = 219;
pub const HID_KBD_USAGE_KPDDECIMAL: u32 = 220;
pub const HID_KBD_USAGE_KPDHEXADECIMAL: u32 = 221;
pub const HID_KBD_USAGE_LCTRL: u32 = 224;
pub const HID_KBD_USAGE_LSHIFT: u32 = 225;
pub const HID_KBD_USAGE_LALT: u32 = 226;
pub const HID_KBD_USAGE_LGUI: u32 = 227;
pub const HID_KBD_USAGE_RCTRL: u32 = 228;
pub const HID_KBD_USAGE_RSHIFT: u32 = 229;
pub const HID_KBD_USAGE_RALT: u32 = 230;
pub const HID_KBD_USAGE_RGUI: u32 = 231;
pub const HID_KBD_USAGE_MAX: u32 = 231;
pub const MIDI_VC_HEADER_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const MIDI_MS_HEADER_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const MIDI_MS_GENERAL_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const MIDI_MIDI_IN_JACK_DESCRIPTOR_SUBTYPE: u32 = 2;
pub const MIDI_MIDI_OUT_JACK_DESCRIPTOR_SUBTYPE: u32 = 3;
pub const MIDI_JACK_TYPE_EMBEDDED: u32 = 1;
pub const MIDI_JACK_TYPE_EXTERNAL: u32 = 2;
pub const MIDI_CHANNEL_OMNI: u32 = 0;
pub const MIDI_CHANNEL_OFF: u32 = 17;
pub const MIDI_PITCHBEND_MIN: i32 = -8192;
pub const MIDI_PITCHBEND_MAX: u32 = 8191;
pub const MIDI_SIZEOF_MS_HEADER_DESC: u32 = 7;
pub const MIDI_SIZEOF_IN_JACK_DESC: u32 = 6;
pub const MIDI_SIZEOF_OUT_JACK_DESC: u32 = 9;
pub const MIDI_SIZEOF_JACK_DESC: u32 = 30;
pub const MSC_SUBCLASS_RBC: u32 = 1;
pub const MSC_SUBCLASS_SFF8020I_MMC2: u32 = 2;
pub const MSC_SUBCLASS_QIC157: u32 = 3;
pub const MSC_SUBCLASS_UFI: u32 = 4;
pub const MSC_SUBCLASS_SFF8070I: u32 = 5;
pub const MSC_SUBCLASS_SCSI: u32 = 6;
pub const MSC_PROTOCOL_CBI_INT: u32 = 0;
pub const MSC_PROTOCOL_CBI_NOINT: u32 = 1;
pub const MSC_PROTOCOL_BULK_ONLY: u32 = 80;
pub const MSC_REQUEST_RESET: u32 = 255;
pub const MSC_REQUEST_GET_MAX_LUN: u32 = 254;
pub const MSC_CBW_Signature: u32 = 1128420181;
pub const MSC_CSW_Signature: u32 = 1396855637;
pub const CSW_STATUS_CMD_PASSED: u32 = 0;
pub const CSW_STATUS_CMD_FAILED: u32 = 1;
pub const CSW_STATUS_PHASE_ERROR: u32 = 2;
pub const MSC_MAX_CDB_LEN: u32 = 16;
pub const USB_SIZEOF_MSC_CBW: u32 = 31;
pub const USB_SIZEOF_MSC_CSW: u32 = 13;
pub const MSC_DESCRIPTOR_LEN: u32 = 23;
pub const SCSI_CMD_TESTUNITREADY: u32 = 0;
pub const SCSI_CMD_REZEROUNIT: u32 = 1;
pub const SCSI_CMD_REQUESTSENSE: u32 = 3;
pub const SCSI_CMD_FORMAT_UNIT: u32 = 4;
pub const SCSI_CMD_REASSIGNBLOCKS: u32 = 7;
pub const SCSI_CMD_READ6: u32 = 8;
pub const SCSI_CMD_WRITE6: u32 = 10;
pub const SCSI_CMD_SEEK6: u32 = 11;
pub const SCSI_CMD_SPACE6: u32 = 17;
pub const SCSI_CMD_INQUIRY: u32 = 18;
pub const SCSI_CMD_MODESELECT6: u32 = 21;
pub const SCSI_CMD_RESERVE6: u32 = 22;
pub const SCSI_CMD_RELEASE6: u32 = 23;
pub const SCSI_CMD_COPY: u32 = 24;
pub const SCSI_CMD_MODESENSE6: u32 = 26;
pub const SCSI_CMD_STARTSTOPUNIT: u32 = 27;
pub const SCSI_CMD_RECEIVEDIAGNOSTICRESULTS: u32 = 28;
pub const SCSI_CMD_SENDDIAGNOSTIC: u32 = 29;
pub const SCSI_CMD_PREVENTMEDIAREMOVAL: u32 = 30;
pub const SCSI_CMD_READFORMATCAPACITIES: u32 = 35;
pub const SCSI_CMD_READCAPACITY10: u32 = 37;
pub const SCSI_CMD_READ10: u32 = 40;
pub const SCSI_CMD_WRITE10: u32 = 42;
pub const SCSI_CMD_SEEK10: u32 = 43;
pub const SCSI_CMD_WRITEANDVERIFY: u32 = 46;
pub const SCSI_CMD_VERIFY10: u32 = 47;
pub const SCSI_CMD_SEARCHDATAHIGH: u32 = 48;
pub const SCSI_CMD_SEARCHDATAEQUAL: u32 = 49;
pub const SCSI_CMD_SEARCHDATALOW: u32 = 50;
pub const SCSI_CMD_SETLIMITS10: u32 = 51;
pub const SCSI_CMD_PREFETCH10: u32 = 52;
pub const SCSI_CMD_SYNCHCACHE10: u32 = 53;
pub const SCSI_CMD_LOCKCACHE: u32 = 54;
pub const SCSI_CMD_READDEFECTDATA10: u32 = 55;
pub const SCSI_CMD_COMPARE: u32 = 57;
pub const SCSI_CMD_COPYANDVERIFY: u32 = 58;
pub const SCSI_CMD_WRITEBUFFER: u32 = 59;
pub const SCSI_CMD_READBUFFER: u32 = 60;
pub const SCSI_CMD_READLONG10: u32 = 62;
pub const SCSI_CMD_WRITELONG10: u32 = 63;
pub const SCSI_CMD_CHANGEDEFINITION: u32 = 64;
pub const SCSI_CMD_WRITESAME10: u32 = 65;
pub const SCSI_CMD_LOGSELECT: u32 = 76;
pub const SCSI_CMD_LOGSENSE: u32 = 77;
pub const SCSI_CMD_XDWRITE10: u32 = 80;
pub const SCSI_CMD_XPWRITE10: u32 = 81;
pub const SCSI_CMD_XDREAD10: u32 = 82;
pub const SCSI_CMD_MODESELECT10: u32 = 85;
pub const SCSI_CMD_RESERVE10: u32 = 86;
pub const SCSI_CMD_RELEASE10: u32 = 87;
pub const SCSI_CMD_MODESENSE10: u32 = 90;
pub const SCSI_CMD_PERSISTENTRESERVEIN: u32 = 94;
pub const SCSI_CMD_PERSISTENTRESERVEOUT: u32 = 95;
pub const SCSI_CMD_32: u32 = 127;
pub const SCSI_CMD_XDWRITEEXTENDED: u32 = 128;
pub const SCSI_CMD_REBUILD: u32 = 130;
pub const SCSI_CMD_REGENERATE: u32 = 130;
pub const SCSI_CMD_EXTENDEDCOPY: u32 = 131;
pub const SCSI_CMD_COPYRESULTS: u32 = 132;
pub const SCSI_CMD_ACCESSCONTROLIN: u32 = 134;
pub const SCSI_CMD_ACCESSCONTROLOUT: u32 = 135;
pub const SCSI_CMD_READ16: u32 = 136;
pub const SCSI_CMD_WRITE16: u32 = 138;
pub const SCSI_CMD_READATTRIBUTE: u32 = 140;
pub const SCSI_CMD_WRITEATTRIBUTE: u32 = 141;
pub const SCSI_CMD_WRITEANDVERIFY16: u32 = 142;
pub const SCSI_CMD_PREFETCH16: u32 = 144;
pub const SCSI_CMD_SYNCHCACHE16: u32 = 145;
pub const SCSI_CMD_LOCKUNLOCKACACHE: u32 = 146;
pub const SCSI_CMD_WRITESAME16: u32 = 147;
pub const SCSI_CMD_READCAPACITY16: u32 = 158;
pub const SCSI_CMD_READLONG16: u32 = 158;
pub const SCSI_CMD_WRITELONG106: u32 = 159;
pub const SCSI_CMD_REPORTLUNS: u32 = 160;
pub const SCSI_CMD_MAINTENANCEIN: u32 = 163;
pub const SCSI_CMD_MAINTENANCEOUT: u32 = 164;
pub const SCSI_CMD_MOVEMEDIUM: u32 = 165;
pub const SCSI_CMD_MOVEMEDIUMATTACHED: u32 = 167;
pub const SCSI_CMD_READ12: u32 = 168;
pub const SCSI_CMD_WRITE12: u32 = 170;
pub const SCSI_CMD_READMEDIASERIALNUMBER: u32 = 171;
pub const SCSI_CMD_WRITEANDVERIFY12: u32 = 174;
pub const SCSI_CMD_VERIFY12: u32 = 175;
pub const SCSI_CMD_SETLIMITS12: u32 = 179;
pub const SCSI_CMD_READELEMENTSTATUS: u32 = 180;
pub const SCSI_CMD_READDEFECTDATA12: u32 = 183;
pub const SCSI_CMD_REDUNDANCYGROUPIN: u32 = 186;
pub const SCSI_CMD_REDUNDANCYGROUPOUT: u32 = 187;
pub const SCSI_CMD_SPAREIN: u32 = 188;
pub const SCSI_CMD_SPAREOUT: u32 = 189;
pub const SCSI_CMD_VOLUMESETIN: u32 = 190;
pub const SCSI_CMD_VOLUMESETOUT: u32 = 191;
pub const SCSI_KCQ_NOSENSE: u32 = 0;
pub const SCSI_KCQ_PFATHRESHOLDREACHED: u32 = 23552;
pub const SCSI_KCQSE_RWENOINDEX: u32 = 65792;
pub const SCSI_KCQSE_RECOVEREDNOSEEKCOMPLETION: u32 = 66048;
pub const SCSI_KCQSE_RWEWRITEFAULT: u32 = 66304;
pub const SCSI_KCQSE_TRACKFOLLOWINGERROR: u32 = 67840;
pub const SCSI_KCQSE_TEMPERATUREWARNING: u32 = 68353;
pub const SCSI_KCQSE_RWEWARREALLOCATED: u32 = 68609;
pub const SCSI_KCQSE_RWERECOMMENDREASSIGN: u32 = 68611;
pub const SCSI_KCQSE_RDWOEUSINGPREVLBI: u32 = 70145;
pub const SCSI_KCQSE_RDWEUSINGPREVLBI: u32 = 70146;
pub const SCSI_KCQSE_RECOVEREDRECORDNOTFOUND: u32 = 70657;
pub const SCSI_KCQSE_RWEDSME: u32 = 71168;
pub const SCSI_KCQSE_RWEDSEDATAREWRITTEN: u32 = 71169;
pub const SCSI_KCQSE_RWEDSERECOMMENDREWRITE: u32 = 71170;
pub const SCSI_KCQSE_RWEDSEDATAAUTOREALLOCATED: u32 = 71171;
pub const SCSI_KCQSE_RWEDSERECOMMENDREASSIGNMENT: u32 = 71172;
pub const SCSI_KCQSE_RDWNECORRECTIONAPPLIED: u32 = 71424;
pub const SCSI_KCQSE_RREWITHRETRIES: u32 = 71425;
pub const SCSI_KCQSE_RDUSINGPOSITIVEOFFSET: u32 = 71426;
pub const SCSI_KCQSE_RDUSINGNEGATIVEOFFSET: u32 = 71427;
pub const SCSI_KCQSE_RDUSINGPREVIOUSLBI: u32 = 71429;
pub const SCSI_KCQSE_RREWOEAUTOREALLOCATED: u32 = 71430;
pub const SCSI_KCQSE_RREWOERECOMMENDREASSIGN: u32 = 71431;
pub const SCSI_KCQSE_RREWOERECOMMENDREWRITE: u32 = 71432;
pub const SCSI_KCQSE_RREWOEDATAREWRITTEN: u32 = 71433;
pub const SCSI_KCQSE_RREWE: u32 = 71680;
pub const SCSI_KCQSE_RDWEANDRETRIES: u32 = 71681;
pub const SCSI_KCQSE_RREWEAUTOREALLOCATED: u32 = 71682;
pub const SCSI_KCQSE_RREWERECOMMENDREASSIGN: u32 = 71685;
pub const SCSI_KCQSE_RDUSINGECCANDOFFSETS: u32 = 71686;
pub const SCSI_KCQSE_RREWEDATAREWRITTEN: u32 = 71687;
pub const SCSI_KCQSE_DLNOTFOUND: u32 = 72704;
pub const SCSI_KCQSE_PRIMARYDLNOTFOUND: u32 = 72705;
pub const SCSI_KCQSE_GROWNDLNOTFOUND: u32 = 72706;
pub const SCSI_KCQSE_PARTIALDLTRANSFERRED: u32 = 73472;
pub const SCSI_KCQSE_INTERNALTARGETFAILURE: u32 = 82944;
pub const SCSI_KCQSE_PFATHRESHOLDREACHED: u32 = 89344;
pub const SCSI_KCQSE_PFATESTWARNING: u32 = 89599;
pub const SCSI_KCQSE_INTERNALLOGICFAILURE: u32 = 98560;
pub const SCSI_KCQNR_CAUSENOTREPORTABLE: u32 = 132096;
pub const SCSI_KCQNR_BECOMINGREADY: u32 = 132097;
pub const SCSI_KCQNR_NEEDINITIALIZECOMMAND: u32 = 132098;
pub const SCSI_KCQNR_MANUALINTERVENTIONREQUIRED: u32 = 132099;
pub const SCSI_KCQNR_FORMATINPROGRESS: u32 = 132100;
pub const SCSI_KCQNR_SELFTESTINPROGRESS: u32 = 132105;
pub const SCSI_KCQNR_MEDIUMFORMATCORRUPTED: u32 = 143616;
pub const SCSI_KCQNR_FORMATCOMMANDFAILED: u32 = 143617;
pub const SCSI_KCQNR_ESUNAVAILABLE: u32 = 144642;
pub const SCSI_KCQNR_MEDIANOTPRESENT: u32 = 145920;
pub const SCSI_KCQDF_BRINGUPFAILORDEGRADEDMODE: u32 = 147584;
pub const SCSI_KCQDF_HARDDISKCONTROLLER: u32 = 147585;
pub const SCSI_KCQDF_RAMMICROCODENOTLOADED: u32 = 147589;
pub const SCSI_KCQDF_RROCALIBRATION: u32 = 147600;
pub const SCSI_KCQDF_CHANNELCALIBRATION: u32 = 147601;
pub const SCSI_KCQDF_HEADLOAD: u32 = 147602;
pub const SCSI_KCQDF_WRITEAE: u32 = 147603;
pub const SCSI_KCQDF_12VOVERCURRENT: u32 = 147604;
pub const SCSI_KCQDF_OTHERSPINDLEFAILURE: u32 = 147605;
pub const SCSI_KCQDF_SELFRESET: u32 = 147632;
pub const SCSI_KCQDF_CONFIGNOTLOADED: u32 = 150528;
pub const SCSI_KCQME_WRITEFAULT: u32 = 197376;
pub const SCSI_KCQME_WRITEFAULTAUTOREALLOCFAILED: u32 = 199682;
pub const SCSI_KCQME_WRITERTLIMITEXCEEDED: u32 = 199867;
pub const SCSI_KCQME_IDCRCERROR: u32 = 200704;
pub const SCSI_KCQME_UNRRE1: u32 = 200960;
pub const SCSI_KCQME_READRETRIESEXHAUSTED: u32 = 200961;
pub const SCSI_KCQME_ERRORTOOLONGTOCORRECT: u32 = 200962;
pub const SCSI_KCQME_UREAUTOREALLOCFAILED: u32 = 200964;
pub const SCSI_KCQME_URERECOMMENDREASSIGN: u32 = 200971;
pub const SCSI_KCQME_READRTLIMITEXCEEDED: u32 = 201215;
pub const SCSI_KCQME_RECORDNOTFOUND: u32 = 201729;
pub const SCSI_KCQME_DSME: u32 = 202240;
pub const SCSI_KCQME_DSERECOMMENDREASSIGN: u32 = 202244;
pub const SCSI_KCQME_DLE: u32 = 203008;
pub const SCSI_KCQME_DLNOTAVAILABLE: u32 = 203009;
pub const SCSI_KCQME_DLEINPRIMARYLIST: u32 = 203010;
pub const SCSI_KCQME_DLEINGROWNLIST: u32 = 203011;
pub const SCSI_KCQME_FEWERTHAN50PCTDLCOPIES: u32 = 203022;
pub const SCSI_KCQME_MEDIUMFORMATCORRUPTED: u32 = 209152;
pub const SCSI_KCQME_FORMATCOMMANDFAILED: u32 = 209153;
pub const SCSI_KCQME_DATAAUTOREALLOCATED: u32 = 229376;
pub const SCSI_KCQHE_NOINDEXORSECTOR: u32 = 262400;
pub const SCSI_KCQHE_NOSEEKCOMPLETE: u32 = 262656;
pub const SCSI_KCQHE_WRITEFAULT: u32 = 262912;
pub const SCSI_KCQHE_COMMUNICATIONFAILURE: u32 = 264192;
pub const SCSI_KCQHE_TRACKFOLLOWINGERROR: u32 = 264448;
pub const SCSI_KCQHE_UREINRESERVEDAREA: u32 = 266496;
pub const SCSI_KCQHE_DSMEINRESERVEDAREA: u32 = 267776;
pub const SCSI_KCQHE_DLE: u32 = 268544;
pub const SCSI_KCQHE_DLEINPRIMARYLIST: u32 = 268546;
pub const SCSI_KCQHE_DLEINGROWNLIST: u32 = 268547;
pub const SCSI_KCQHE_REASSIGNFAILED: u32 = 274688;
pub const SCSI_KCQHE_NODEFECTSPAREAVAILABLE: u32 = 274944;
pub const SCSI_KCQHE_UNSUPPORTEDENCLOSUREFUNCTION: u32 = 275713;
pub const SCSI_KCQHE_ESUNAVAILABLE: u32 = 275714;
pub const SCSI_KCQHE_ESTRANSFERFAILURE: u32 = 275715;
pub const SCSI_KCQHE_ESREFUSED: u32 = 275716;
pub const SCSI_KCQHE_SELFTESTFAILED: u32 = 278019;
pub const SCSI_KCQHE_UNABLETOUPDATESELFTEST: u32 = 278020;
pub const SCSI_KCQHE_DMDIAGNOSTICFAIL: u32 = 278656;
pub const SCSI_KCQHE_DMHWERROR: u32 = 278657;
pub const SCSI_KCQHE_DMRAMMICROCODENOTLOADED: u32 = 278661;
pub const SCSI_KCQHE_SEEKTESTFAILURE: u32 = 278672;
pub const SCSI_KCQHE_READWRITETESTFAILURE: u32 = 278688;
pub const SCSI_KCQHE_DEVICESELFRESET: u32 = 278704;
pub const SCSI_KCQHE_COMPONENTMISMATCH: u32 = 278736;
pub const SCSI_KCQHE_INTERNALTARGETFAILURE: u32 = 279552;
pub const SCSI_KCQHE_INTERNALLOGICERROR: u32 = 295168;
pub const SCSI_KCQHE_COMMANDTIMEOUT: u32 = 295424;
pub const SCSI_KCQIR_PARMLISTLENGTHERROR: u32 = 334336;
pub const SCSI_KCQIR_INVALIDCOMMAND: u32 = 335872;
pub const SCSI_KCQIR_LBAOUTOFRANGE: u32 = 336128;
pub const SCSI_KCQIR_INVALIDFIELDINCBA: u32 = 336896;
pub const SCSI_KCQIR_INVALIDLUN: u32 = 337152;
pub const SCSI_KCQIR_INVALIDFIELDSINPARMLIST: u32 = 337408;
pub const SCSI_KCQIR_PARAMETERNOTSUPPORTED: u32 = 337409;
pub const SCSI_KCQIR_INVALIDPARMVALUE: u32 = 337410;
pub const SCSI_KCQIR_IFPTHRESHOLDPARAMETER: u32 = 337411;
pub const SCSI_KCQIR_INVALIDRELEASEOFPR: u32 = 337412;
pub const SCSI_KCQIR_IFPTMSFIRMWARETAG: u32 = 337559;
pub const SCSI_KCQIR_IFPCHECKSUM: u32 = 337560;
pub const SCSI_KCQIR_IFPFIRMWARETAG: u32 = 337561;
pub const SCSI_KCQIR_COMMANDSEQUENCEERROR: u32 = 338944;
pub const SCSI_KCQIR_UNSUPPORTEDENCLOSUREFUNCTION: u32 = 341249;
pub const SCSI_KCQIR_SAVINGPARMSNOTSUPPORTED: u32 = 342272;
pub const SCSI_KCQIR_INVALIDMESSAGE: u32 = 346368;
pub const SCSI_KCQIR_MEDIALOADOREJECTFAILED: u32 = 348928;
pub const SCSI_KCQIR_UNLOADTAPEFAILURE: u32 = 348929;
pub const SCSI_KCQIR_MEDIUMREMOVALPREVENTED: u32 = 348930;
pub const SCSI_KCQIR_SYSTEMRESOURCEFAILURE: u32 = 349440;
pub const SCSI_KCQIR_SYSTEMBUFFERFULL: u32 = 349441;
pub const SCSI_KCQIR_INSUFFICIENTRR: u32 = 349444;
pub const SCSI_KCQUA_NOTREADYTOTRANSITION: u32 = 403456;
pub const SCSI_KCQUA_DEVICERESETOCCURRED: u32 = 403712;
pub const SCSI_KCQUA_POROCCURRED: u32 = 403713;
pub const SCSI_KCQUA_SCSIBUSRESETOCCURRED: u32 = 403714;
pub const SCSI_KCQUA_TARGETRESETOCCURRED: u32 = 403715;
pub const SCSI_KCQUA_SELFINITIATEDRESETOCCURRED: u32 = 403716;
pub const SCSI_KCQUA_TRANSCEIVERMODECHANGETOSE: u32 = 403717;
pub const SCSI_KCQUA_TRANSCEIVERMODECHANGETOLVD: u32 = 403718;
pub const SCSI_KCQUA_PARAMETERSCHANGED: u32 = 403968;
pub const SCSI_KCQUA_MODEPARAMETERSCHANGED: u32 = 403969;
pub const SCSI_KCQUA_LOGSELECTPARMSCHANGED: u32 = 403970;
pub const SCSI_KCQUA_RESERVATIONSPREEMPTED: u32 = 403971;
pub const SCSI_KCQUA_RESERVATIONSRELEASED: u32 = 403972;
pub const SCSI_KCQUA_REGISTRATIONSPREEMPTED: u32 = 403973;
pub const SCSI_KCQUA_COMMANDSCLEARED: u32 = 405248;
pub const SCSI_KCQUA_OPERATINGCONDITIONSCHANGED: u32 = 409344;
pub const SCSI_KCQUA_MICROCODECHANGED: u32 = 409345;
pub const SCSI_KCQUA_CHANGEDOPERATINGDEFINITION: u32 = 409346;
pub const SCSI_KCQUA_INQUIRYPARAMETERSCHANGED: u32 = 409347;
pub const SCSI_KCQUA_DEVICEIDENTIFIERCHANGED: u32 = 409349;
pub const SCSI_KCQUA_INVALIDAPMPARAMETERS: u32 = 409488;
pub const SCSI_KCQUA_WORLDWIDENAMEMISMATCH: u32 = 409489;
pub const SCSI_KCQUA_PFATHRESHOLDREACHED: u32 = 417024;
pub const SCSI_KCQUA_PFATHRESHOLDEXCEEDED: u32 = 417279;
pub const SCSI_KCQWP_COMMANDNOTALLOWED: u32 = 468736;
pub const SCSI_KCQAC_NOADDITIONALSENSECODE: u32 = 720896;
pub const SCSI_KCQAC_SYNCDATATRANSFERERROR: u32 = 727808;
pub const SCSI_KCQAC_UNSUPPORTEDLUN: u32 = 730368;
pub const SCSI_KCQAC_ECHOBUFFEROVERWRITTEN: u32 = 737039;
pub const SCSI_KCQAC_MESSAGEREJECTERROR: u32 = 738048;
pub const SCSI_KCQAC_INTERNALTARGETFAILURE: u32 = 738304;
pub const SCSI_KCQAC_SELECTIONFAILURE: u32 = 738560;
pub const SCSI_KCQAC_SCSIPARITYERROR: u32 = 739072;
pub const SCSI_KCQAC_INITIATORDETECTEDERRORECEIVED: u32 = 739328;
pub const SCSI_KCQAC_ILLEGALMESSAGE: u32 = 739584;
pub const SCSI_KCQAC_DATAPHASEERROR: u32 = 740096;
pub const SCSI_KCQAC_OVERLAPPEDCOMMANDSATTEMPTED: u32 = 740864;
pub const SCSI_KCQAC_LOOPINITIALIZATION: u32 = 741120;
pub const SCSO_KCQOTHER_MISCOMPARE: u32 = 924928;
pub const SCSI_STATUS_OK: u32 = 0;
pub const SCSI_STATUS_CHECKCONDITION: u32 = 2;
pub const SCSI_STATUS_CONDITIONMET: u32 = 4;
pub const SCSI_STATUS_BUSY: u32 = 8;
pub const SCSI_STATUS_INTERMEDIATE: u32 = 16;
pub const SCSI_STATUS_DATAOVERUNDERRUN: u32 = 18;
pub const SCSI_STATUS_INTERMEDIATECONDITIONMET: u32 = 20;
pub const SCSI_STATUS_RESERVATIONCONFLICT: u32 = 24;
pub const SCSI_STATUS_COMMANDTERMINATED: u32 = 34;
pub const SCSI_STATUS_QUEUEFULL: u32 = 40;
pub const SCSI_STATUS_ACAACTIVE: u32 = 48;
pub const SCSI_STATUS_TASKABORTED: u32 = 64;
pub const SCSICMD_INQUIRYFLAGS_EVPD: u32 = 1;
pub const SCSIRESP_INQUIRYPQ_CONNECTED: u32 = 0;
pub const SCSIRESP_INQUIRYPQ_NOTCONNECTED: u32 = 32;
pub const SCSIRESP_INQUIRYPQ_NOTCAPABLE: u32 = 96;
pub const SCSIRESP_INQUIRYPD_DIRECTACCESS: u32 = 0;
pub const SCSIRESP_INQUIRYPD_SEQUENTIALACCESS: u32 = 1;
pub const SCSIRESP_INQUIRYPD_PRINTER: u32 = 2;
pub const SCSIRESP_INQUIRYPD_PROCESSOR: u32 = 3;
pub const SCSIRESP_INQUIRYPD_WRONCE: u32 = 4;
pub const SCSIRESP_INQUIRYPD_CDDVD: u32 = 5;
pub const SCSIRESP_INQUIRYPD_SCANNER: u32 = 6;
pub const SCSIRESP_INQUIRYPD_OPTICAL: u32 = 7;
pub const SCSIRESP_INQUIRYPD_MEDIUMCHANGER: u32 = 8;
pub const SCSIRESP_INQUIRYPD_COMMUNICATIONS: u32 = 9;
pub const SCSIRESP_INQUIRYPD_STORAGEARRAY: u32 = 12;
pub const SCSIRESP_INQUIRYPD_ENCLOSURESERVICES: u32 = 13;
pub const SCSIRESP_INQUIRYPD_RBC: u32 = 14;
pub const SCSIRESP_INQUIRYPD_OCRW: u32 = 15;
pub const SCSIRESP_INQUIRYPD_BCC: u32 = 16;
pub const SCSIRESP_INQUIRYPD_OSD: u32 = 17;
pub const SCSIRESP_INQUIRYPD_ADC: u32 = 18;
pub const SCSIRESP_INQUIRYPD_WKLU: u32 = 30;
pub const SCSIRESP_INQUIRYPD_UNKNOWN: u32 = 31;
pub const SCSIRESP_INQUIRYFLAGS1_RMB: u32 = 128;
pub const SCSIRESP_INQUIRYFLAGS2_NORMACA: u32 = 32;
pub const SCSIRESP_INQUIRYFLAGS2_HISUP: u32 = 16;
pub const SCSIRESP_INQUIRYFLAGS2_FMTMASK: u32 = 15;
pub const SCSIRESP_INQUIRYFLAGS3_SCCS: u32 = 128;
pub const SCSIRESP_INQUIRYFLAGS3_ACC: u32 = 64;
pub const SCSIRESP_INQUIRYFLAGS3_TPGSMASK: u32 = 48;
pub const SCSIRESP_INQUIRYFLAGS3_3PC: u32 = 8;
pub const SCSIRESP_INQUIRYFLAGS3_PROTECT: u32 = 1;
pub const SCSIRESP_INQUIRYFLAGS4_BQUE: u32 = 128;
pub const SCSIRESP_INQUIRYFLAGS4_ENCSERV: u32 = 64;
pub const SCSIRESP_INQUIRYFLAGS4_VS: u32 = 32;
pub const SCSIRESP_INQUIRYFLAGS4_MULTIP: u32 = 16;
pub const SCSIRESP_INQUIRYFLAGS4_MCHNGR: u32 = 8;
pub const SCSIRESP_INQUIRYFLAGS4_ADDR16: u32 = 1;
pub const SCSIRESP_INQUIRYFLAGS5_WBUS16: u32 = 32;
pub const SCSIRESP_INQUIRYFLAGS5_SYNC: u32 = 16;
pub const SCSIRESP_INQUIRYFLAGS5_LINKED: u32 = 8;
pub const SCSIRESP_INQUIRYFLAGS5_CMDQUEUE: u32 = 2;
pub const SCSIRESP_INQUIRYFLAGS5_VS: u32 = 1;
pub const SCSIRESP_INQUIRYFLAGS6_CLOCKINGMASK: u32 = 192;
pub const SCSIRESP_INQUIRYFLAGS6_QAS: u32 = 2;
pub const SCSIRESP_INQUIRYFLAGS6_IUS: u32 = 1;
pub const SCSIRESP_SENSEDATA_CURRENTFIXED: u32 = 112;
pub const SCSIRESP_SENSEDATA_DEFERREDFIXED: u32 = 113;
pub const SCSIRESP_SENSEDATA_CURRENTDESC: u32 = 114;
pub const SCSIRESP_SENSEDATA_DEFERREDDESC: u32 = 115;
pub const SCSIRESP_SENSEDATA_RESPVALID: u32 = 128;
pub const SCSIRESP_SENSEDATA_FILEMARK: u32 = 128;
pub const SCSIRESP_SENSEDATA_EOM: u32 = 64;
pub const SCSIRESP_SENSEDATA_ILI: u32 = 32;
pub const SCSIRESP_SENSEDATA_SENSEKEYMASK: u32 = 15;
pub const SCSIRESP_SENSEDATA_NOSENSE: u32 = 0;
pub const SCSIRESP_SENSEDATA_RECOVEREDERROR: u32 = 1;
pub const SCSIRESP_SENSEDATA_NOTREADY: u32 = 2;
pub const SCSIRESP_SENSEDATA_MEDIUMERROR: u32 = 3;
pub const SCSIRESP_SENSEDATA_HARDWAREERROR: u32 = 4;
pub const SCSIRESP_SENSEDATA_ILLEGALREQUEST: u32 = 5;
pub const SCSIRESP_SENSEDATA_UNITATTENTION: u32 = 6;
pub const SCSIRESP_SENSEDATA_DATAPROTECT: u32 = 7;
pub const SCSIRESP_SENSEDATA_BLANKCHECK: u32 = 8;
pub const SCSIRESP_SENSEDATA_VENDORSPECIFIC: u32 = 9;
pub const SCSIRESP_SENSEDATA_ABORTEDCOMMAND: u32 = 11;
pub const SCSIRESP_SENSEDATA_KEYVALID: u32 = 128;
pub const SCSICMD_MODESELECT6_PF: u32 = 16;
pub const SCSICMD_MODESELECT6_SP: u32 = 1;
pub const SCSICMD_MODESENSE6_DBD: u32 = 8;
pub const SCSICMD_MODESENSE_PCMASK: u32 = 192;
pub const SCSICMD_MODESENSE_PCCURRENT: u32 = 0;
pub const SCSICMD_MODESENSE_PCCHANGEABLE: u32 = 64;
pub const SCSICMD_MODESENSE_PCDEFAULT: u32 = 128;
pub const SCSICMD_MODESENSE_PCSAVED: u32 = 192;
pub const SCSICMD_MODESENSE_PGCODEMASK: u32 = 63;
pub const SCSICMD_MODESENSE6_PCDEFAULT: u32 = 128;
pub const SCSIRESP_MODESENSE_PGCCODE_VENDOR: u32 = 0;
pub const SCSIRESP_MODESENSE_PGCCODE_RWERROR: u32 = 1;
pub const SCSIRESP_MODESENSE_PGCCODE_RECONNECT: u32 = 2;
pub const SCSIRESP_MODESENSE_PGCCODE_FORMATDEV: u32 = 3;
pub const SCSIRESP_MODESENSE_PGCCODE_RIGID: u32 = 4;
pub const SCSIRESP_MODESENSE_PGCCODE_FLEXIBLE: u32 = 5;
pub const SCSIRESP_MODESENSE_PGCCODE_VERIFY: u32 = 7;
pub const SCSIRESP_MODESENSE_PGCCODE_CACHING: u32 = 8;
pub const SCSIRESP_MODESENSE_PGCCODE_CONTROL: u32 = 10;
pub const SCSIRESP_MODESENSE_PGCCODE_CONTROLEXT: u32 = 10;
pub const SCSIRESP_MODESENSE_PGCCODE_MEDIUMTYPES: u32 = 11;
pub const SCSIRESP_MODESENSE_PGCCODE_NP: u32 = 12;
pub const SCSIRESP_MODESENSE_PGCCODE_XOR: u32 = 16;
pub const SCSIRESP_MODESENSE_PGCCODE_ES: u32 = 20;
pub const SCSIRESP_MODESENSE_PGCCODE_PSLUN: u32 = 24;
pub const SCSIRESP_MODESENSE_PGCCODE_PSPORT: u32 = 25;
pub const SCSIRESP_MODESENSE_PGCCODE_POWER: u32 = 26;
pub const SCSIRESP_MODESENSE_PGCCODE_IE: u32 = 28;
pub const SCSIRESP_MODESENSE_PGCCODE_BC: u32 = 28;
pub const SCSIRESP_MODESENSE_PGCCODE_RETURNALL: u32 = 63;
pub const SCSIRESP_CACHINGMODEPG_PS: u32 = 128;
pub const SCSIRESP_CACHINGMODEPG_SPF: u32 = 96;
pub const SCSIRESP_CACHINGMODEPG_IC: u32 = 128;
pub const SCSIRESP_CACHINGMODEPG_ABPF: u32 = 64;
pub const SCSIRESP_CACHINGMODEPG_CAP: u32 = 32;
pub const SCSIRESP_CACHINGMODEPG_DISC: u32 = 16;
pub const SCSIRESP_CACHINGMODEPG_SIZE: u32 = 8;
pub const SCSIRESP_CACHINGMODEPG_WCE: u32 = 4;
pub const SCSIRESP_CACHINGMODEPG_MF: u32 = 2;
pub const SCSIRESP_CACHINGMODEPG_RCD: u32 = 1;
pub const SCSIRESP_MODEPARMHDR_DAPARM_WP: u32 = 128;
pub const SCSIRESP_MODEPARMHDR_DAPARM_DBPFUA: u32 = 16;
pub const SCSIRESP_PAGEFMT_PS: u32 = 128;
pub const SCSIRESP_PAGEFMT_SPF: u32 = 64;
pub const SCSIRESP_PAGEFMT_PGCODEMASK: u32 = 63;
pub const SCSICMD_PREVENTMEDIUMREMOVAL_TRANSPORT: u32 = 1;
pub const SCSICMD_PREVENTMEDIUMREMOVAL_MCHANGER: u32 = 2;
pub const SCIRESP_RDFMTCAPACITIES_UNFORMATED: u32 = 1;
pub const SCIRESP_RDFMTCAPACITIES_FORMATED: u32 = 2;
pub const SCIRESP_RDFMTCAPACITIES_NOMEDIA: u32 = 3;
pub const SCSICMD_READ6_MSLBAMASK: u32 = 31;
pub const SCSICMD_WRITE6_MSLBAMASK: u32 = 31;
pub const SCSICMD_MODESELECT10_PF: u32 = 16;
pub const SCSICMD_MODESELECT10_SP: u32 = 1;
pub const SCSICMD_MODESENSE10_LLBAA: u32 = 16;
pub const SCSICMD_MODESENSE10_DBD: u32 = 8;
pub const SCSICMD_READ10FLAGS_RDPROTECTMASK: u32 = 224;
pub const SCSICMD_READ10FLAGS_DPO: u32 = 16;
pub const SCSICMD_READ10FLAGS_FUA: u32 = 8;
pub const SCSICMD_READ10FLAGS_FUANV: u32 = 2;
pub const SCSICMD_WRITE10FLAGS_WRPROTECTMASK: u32 = 224;
pub const SCSICMD_WRITE10FLAGS_DPO: u32 = 16;
pub const SCSICMD_WRITE10FLAGS_FUA: u32 = 8;
pub const SCSICMD_WRITE10FLAGS_FUANV: u32 = 2;
pub const SCSICMD_VERIFY10_VRPROTECTMASK: u32 = 224;
pub const SCSICMD_VERIFY10_DPO: u32 = 16;
pub const SCSICMD_VERIFY10_BYTCHK: u32 = 2;
pub const SCSICMD_READ12FLAGS_RDPROTECTMASK: u32 = 224;
pub const SCSICMD_READ12FLAGS_DPO: u32 = 16;
pub const SCSICMD_READ12FLAGS_FUA: u32 = 8;
pub const SCSICMD_READ12FLAGS_FUANV: u32 = 2;
pub const SCSICMD_WRITE12FLAGS_WRPROTECTMASK: u32 = 224;
pub const SCSICMD_WRITE12FLAGS_DPO: u32 = 16;
pub const SCSICMD_WRITE12FLAGS_FUA: u32 = 8;
pub const SCSICMD_WRITE12FLAGS_FUANV: u32 = 2;
pub const SCSICMD_VERIFY12_VRPROTECTMASK: u32 = 224;
pub const SCSICMD_VERIFY12_DPO: u32 = 16;
pub const SCSICMD_VERIFY12_BYTCHK: u32 = 2;
pub const SCSICMD_TESTUNITREADY_SIZEOF: u32 = 6;
pub const SCSICMD_REQUESTSENSE_SIZEOF: u32 = 6;
pub const SCSICMD_REQUESTSENSE_MSSIZEOF: u32 = 12;
pub const SCSIRESP_FIXEDSENSEDATA_SIZEOF: u32 = 18;
pub const SCSICMD_INQUIRY_SIZEOF: u32 = 6;
pub const SCSIRESP_INQUIRY_SIZEOF: u32 = 36;
pub const SCSICMD_MODESELECT6_SIZEOF: u32 = 6;
pub const SCSICMD_MODESENSE6_SIZEOF: u32 = 6;
pub const SCSIRESP_MODEPARAMETERHDR6_SIZEOF: u32 = 4;
pub const SCSIRESP_BLOCKDESC_SIZEOF: u32 = 8;
pub const SCSICMD_READ6_SIZEOF: u32 = 6;
pub const SCSICMD_WRITE6_SIZEOF: u32 = 6;
pub const SCSICMD_STARTSTOPUNIT_SIZEOF: u32 = 6;
pub const SCSICMD_PREVENTMEDIUMREMOVAL_SIZEOF: u32 = 6;
pub const SCSICMD_READFORMATCAPACITIES_SIZEOF: u32 = 10;
pub const SCSIRESP_READFORMATCAPACITIES_SIZEOF: u32 = 12;
pub const SCSIRESP_CURRCAPACITYDESC_SIZEOF: u32 = 8;
pub const SCSIRESP_FORMATTEDCAPACITYDESC_SIZEOF: u32 = 8;
pub const SCSICMD_READCAPACITY10_SIZEOF: u32 = 10;
pub const SCSIRESP_READCAPACITY10_SIZEOF: u32 = 8;
pub const SCSICMD_READ10_SIZEOF: u32 = 10;
pub const SCSICMD_WRITE10_SIZEOF: u32 = 10;
pub const SCSICMD_VERIFY10_SIZEOF: u32 = 10;
pub const SCSICMD_SYNCHRONIZECACHE10_SIZEOF: u32 = 10;
pub const SCSICMD_MODESELECT10_SIZEOF: u32 = 10;
pub const SCSIRESP_MODEPARAMETERHDR10_SIZEOF: u32 = 8;
pub const SCSICMD_MODESENSE10_SIZEOF: u32 = 10;
pub const SCSICMD_READCAPACITY16_SIZEOF: u32 = 16;
pub const SCSICMD_READ12_SIZEOF: u32 = 12;
pub const SCSICMD_WRITE12_SIZEOF: u32 = 12;
pub const SCSICMD_VERIFY12_SIZEOF: u32 = 12;
pub const AX_CMD_SET_SW_MII: u32 = 6;
pub const AX_CMD_READ_MII_REG: u32 = 7;
pub const AX_CMD_WRITE_MII_REG: u32 = 8;
pub const AX_CMD_STATMNGSTS_REG: u32 = 9;
pub const AX_CMD_SET_HW_MII: u32 = 10;
pub const AX_CMD_READ_EEPROM: u32 = 11;
pub const AX_CMD_WRITE_EEPROM: u32 = 12;
pub const AX_CMD_WRITE_ENABLE: u32 = 13;
pub const AX_CMD_WRITE_DISABLE: u32 = 14;
pub const AX_CMD_READ_RX_CTL: u32 = 15;
pub const AX_CMD_WRITE_RX_CTL: u32 = 16;
pub const AX_CMD_READ_IPG012: u32 = 17;
pub const AX_CMD_WRITE_IPG0: u32 = 18;
pub const AX_CMD_WRITE_IPG1: u32 = 19;
pub const AX_CMD_READ_NODE_ID: u32 = 19;
pub const AX_CMD_WRITE_NODE_ID: u32 = 20;
pub const AX_CMD_WRITE_IPG2: u32 = 20;
pub const AX_CMD_WRITE_MULTI_FILTER: u32 = 22;
pub const AX88172_CMD_READ_NODE_ID: u32 = 23;
pub const AX_CMD_READ_PHY_ID: u32 = 25;
pub const AX_CMD_READ_MEDIUM_STATUS: u32 = 26;
pub const AX_CMD_WRITE_MEDIUM_MODE: u32 = 27;
pub const AX_CMD_READ_MONITOR_MODE: u32 = 28;
pub const AX_CMD_WRITE_MONITOR_MODE: u32 = 29;
pub const AX_CMD_READ_GPIOS: u32 = 30;
pub const AX_CMD_WRITE_GPIOS: u32 = 31;
pub const AX_CMD_SW_RESET: u32 = 32;
pub const AX_CMD_SW_PHY_STATUS: u32 = 33;
pub const AX_CMD_SW_PHY_SELECT: u32 = 34;
pub const AX_QCTCTRL: u32 = 42;
pub const AX_CHIPCODE_MASK: u32 = 112;
pub const AX_AX88772_CHIPCODE: u32 = 0;
pub const AX_AX88772A_CHIPCODE: u32 = 16;
pub const AX_AX88772B_CHIPCODE: u32 = 32;
pub const AX_HOST_EN: u32 = 1;
pub const AX_PHYSEL_PSEL: u32 = 1;
pub const AX_PHYSEL_SSMII: u32 = 0;
pub const AX_PHYSEL_SSEN: u32 = 16;
pub const AX_PHY_SELECT_INTERNAL: u32 = 0;
pub const AX_MONITOR_MODE: u32 = 1;
pub const AX_MONITOR_LINK: u32 = 2;
pub const AX_MONITOR_MAGIC: u32 = 4;
pub const AX_MONITOR_HSFS: u32 = 16;
pub const AX88172_MEDIUM_FD: u32 = 2;
pub const AX88172_MEDIUM_TX: u32 = 4;
pub const AX88172_MEDIUM_FC: u32 = 16;
pub const AX88172_MEDIUM_DEFAULT: u32 = 22;
pub const AX_MCAST_FILTER_SIZE: u32 = 8;
pub const AX_MAX_MCAST: u32 = 64;
pub const AX_SWRESET_CLEAR: u32 = 0;
pub const AX_SWRESET_RR: u32 = 1;
pub const AX_SWRESET_RT: u32 = 2;
pub const AX_SWRESET_PRTE: u32 = 4;
pub const AX_SWRESET_PRL: u32 = 8;
pub const AX_SWRESET_BZ: u32 = 16;
pub const AX_SWRESET_IPRL: u32 = 32;
pub const AX_SWRESET_IPPD: u32 = 64;
pub const AX88772_IPG0_DEFAULT: u32 = 21;
pub const AX88772_IPG1_DEFAULT: u32 = 12;
pub const AX88772_IPG2_DEFAULT: u32 = 18;
pub const AX_MEDIUM_PF: u32 = 128;
pub const AX_MEDIUM_JFE: u32 = 64;
pub const AX_MEDIUM_TFC: u32 = 32;
pub const AX_MEDIUM_RFC: u32 = 16;
pub const AX_MEDIUM_ENCK: u32 = 8;
pub const AX_MEDIUM_AC: u32 = 4;
pub const AX_MEDIUM_FD: u32 = 2;
pub const AX_MEDIUM_GM: u32 = 1;
pub const AX_MEDIUM_SM: u32 = 4096;
pub const AX_MEDIUM_SBP: u32 = 2048;
pub const AX_MEDIUM_PS: u32 = 512;
pub const AX_MEDIUM_RE: u32 = 256;
pub const AX88178_MEDIUM_DEFAULT: u32 = 886;
pub const AX88772_MEDIUM_DEFAULT: u32 = 774;
pub const AX_RX_CTL_SO: u32 = 128;
pub const AX_RX_CTL_AP: u32 = 32;
pub const AX_RX_CTL_AM: u32 = 16;
pub const AX_RX_CTL_AB: u32 = 8;
pub const AX_RX_CTL_SEP: u32 = 4;
pub const AX_RX_CTL_AMALL: u32 = 2;
pub const AX_RX_CTL_PRO: u32 = 1;
pub const AX_RX_CTL_MFB_2048: u32 = 0;
pub const AX_RX_CTL_MFB_4096: u32 = 256;
pub const AX_RX_CTL_MFB_8192: u32 = 512;
pub const AX_RX_CTL_MFB_16384: u32 = 768;
pub const AX_DEFAULT_RX_CTL: u32 = 136;
pub const AX_GPIO_GPO0EN: u32 = 1;
pub const AX_GPIO_GPO_0: u32 = 2;
pub const AX_GPIO_GPO1EN: u32 = 4;
pub const AX_GPIO_GPO_1: u32 = 8;
pub const AX_GPIO_GPO2EN: u32 = 16;
pub const AX_GPIO_GPO_2: u32 = 32;
pub const AX_GPIO_RESERVED: u32 = 64;
pub const AX_GPIO_RSE: u32 = 128;
pub const AX_EEPROM_MAGIC: u32 = 3735928559;
pub const AX_EEPROM_LEN: u32 = 512;
pub const AX_EMBD_PHY_ADDR: u32 = 16;
pub const CH34X_READ_VERSION: u32 = 95;
pub const CH34X_WRITE_REG: u32 = 154;
pub const CH34X_READ_REG: u32 = 149;
pub const CH34X_SERIAL_INIT: u32 = 161;
pub const CH34X_MODEM_CTRL: u32 = 164;
pub const CH34X_BIT_RTS: u32 = 64;
pub const CH34X_BIT_DTR: u32 = 32;
pub const CH341_CTO_O: u32 = 16;
pub const CH341_CTO_D: u32 = 32;
pub const CH341_CTO_R: u32 = 64;
pub const CH341_CTI_C: u32 = 1;
pub const CH341_CTI_DS: u32 = 2;
pub const CH341_CTRL_RI: u32 = 4;
pub const CH341_CTI_DC: u32 = 8;
pub const CH341_CTI_ST: u32 = 15;
pub const CH341_L_ER: u32 = 128;
pub const CH341_L_ET: u32 = 64;
pub const CH341_L_PS: u32 = 56;
pub const CH341_L_PM: u32 = 40;
pub const CH341_L_PE: u32 = 24;
pub const CH341_L_PO: u32 = 8;
pub const CH341_L_SB: u32 = 4;
pub const CH341_L_D8: u32 = 3;
pub const CH341_L_D7: u32 = 2;
pub const CH341_L_D6: u32 = 1;
pub const CH341_L_D5: u32 = 0;
pub const CP210X_IFC_ENABLE: u32 = 0;
pub const CP210X_SET_BAUDDIV: u32 = 1;
pub const CP210X_GET_BAUDDIV: u32 = 2;
pub const CP210X_SET_LINE_CTL: u32 = 3;
pub const CP210X_GET_LINE_CTL: u32 = 4;
pub const CP210X_SET_BREAK: u32 = 5;
pub const CP210X_IMM_CHAR: u32 = 6;
pub const CP210X_SET_MHS: u32 = 7;
pub const CP210X_GET_MDMSTS: u32 = 8;
pub const CP210X_SET_XON: u32 = 9;
pub const CP210X_SET_XOFF: u32 = 10;
pub const CP210X_SET_EVENTMASK: u32 = 11;
pub const CP210X_GET_EVENTMASK: u32 = 12;
pub const CP210X_SET_CHAR: u32 = 13;
pub const CP210X_GET_CHARS: u32 = 14;
pub const CP210X_GET_PROPS: u32 = 15;
pub const CP210X_GET_COMM_STATUS: u32 = 16;
pub const CP210X_RESET: u32 = 17;
pub const CP210X_PURGE: u32 = 18;
pub const CP210X_SET_FLOW: u32 = 19;
pub const CP210X_GET_FLOW: u32 = 20;
pub const CP210X_EMBED_EVENTS: u32 = 21;
pub const CP210X_GET_EVENTSTATE: u32 = 22;
pub const CP210X_SET_CHARS: u32 = 25;
pub const CP210X_GET_BAUDRATE: u32 = 29;
pub const CP210X_SET_BAUDRATE: u32 = 30;
pub const CP210X_VENDOR_SPECIFIC: u32 = 255;
pub const SIO_RESET_REQUEST: u32 = 0;
pub const SIO_SET_MODEM_CTRL_REQUEST: u32 = 1;
pub const SIO_SET_FLOW_CTRL_REQUEST: u32 = 2;
pub const SIO_SET_BAUDRATE_REQUEST: u32 = 3;
pub const SIO_SET_DATA_REQUEST: u32 = 4;
pub const SIO_POLL_MODEM_STATUS_REQUEST: u32 = 5;
pub const SIO_SET_EVENT_CHAR_REQUEST: u32 = 6;
pub const SIO_SET_ERROR_CHAR_REQUEST: u32 = 7;
pub const SIO_SET_LATENCY_TIMER_REQUEST: u32 = 9;
pub const SIO_GET_LATENCY_TIMER_REQUEST: u32 = 10;
pub const SIO_SET_BITMODE_REQUEST: u32 = 11;
pub const SIO_READ_PINS_REQUEST: u32 = 12;
pub const SIO_READ_EEPROM_REQUEST: u32 = 144;
pub const SIO_WRITE_EEPROM_REQUEST: u32 = 145;
pub const SIO_ERASE_EEPROM_REQUEST: u32 = 146;
pub const SIO_DISABLE_FLOW_CTRL: u32 = 0;
pub const SIO_RTS_CTS_HS: u32 = 256;
pub const SIO_DTR_DSR_HS: u32 = 512;
pub const SIO_XON_XOFF_HS: u32 = 1024;
pub const SIO_SET_DTR_MASK: u32 = 1;
pub const SIO_SET_DTR_HIGH: u32 = 257;
pub const SIO_SET_DTR_LOW: u32 = 256;
pub const SIO_SET_RTS_MASK: u32 = 2;
pub const SIO_SET_RTS_HIGH: u32 = 514;
pub const SIO_SET_RTS_LOW: u32 = 512;
pub const PL2303_SET_REQUEST: u32 = 1;
pub const PL2303_SET_REQUEST_PL2303HXN: u32 = 128;
pub const PL2303_SET_CRTSCTS: u32 = 65;
pub const PL2303_SET_CRTSCTS_PL2303X: u32 = 97;
pub const PL2303_SET_CRTSCTS_PL2303HXN: u32 = 250;
pub const PL2303_CLEAR_CRTSCTS_PL2303HXN: u32 = 255;
pub const PL2303_CRTSCTS_REG_PL2303HXN: u32 = 10;
pub const PL2303_STATUS_REG_PL2303HX: u32 = 32896;
pub const USBH_PL2303_TYPE_UNKNOWN: u32 = 0;
pub const USBH_PL2303_TYPE_PL2303: u32 = 1;
pub const USBH_PL2303_TYPE_PL2303HX: u32 = 2;
pub const USBH_PL2303_TYPE_PL2303HXD: u32 = 3;
pub const USBH_PL2303_TYPE_PL2303HXN: u32 = 4;
pub const USB_DEVICE_VIDEO_CLASS_VERSION_1_5: u32 = 0;
pub const VIDEO_SC_UNDEFINED: u32 = 0;
pub const VIDEO_SC_VIDEOCONTROL: u32 = 1;
pub const VIDEO_SC_VIDEOSTREAMING: u32 = 2;
pub const VIDEO_SC_VIDEO_INTERFACE_COLLECTION: u32 = 3;
pub const VIDEO_PC_PROTOCOL_UNDEFINED: u32 = 0;
pub const VIDEO_PC_PROTOCOL_15: u32 = 1;
pub const VIDEO_CS_UNDEFINED_DESCRIPTOR_TYPE: u32 = 32;
pub const VIDEO_CS_DEVICE_DESCRIPTOR_TYPE: u32 = 33;
pub const VIDEO_CS_CONFIGURATION_DESCRIPTOR_TYPE: u32 = 34;
pub const VIDEO_CS_STRING_DESCRIPTOR_TYPE: u32 = 35;
pub const VIDEO_CS_INTERFACE_DESCRIPTOR_TYPE: u32 = 36;
pub const VIDEO_CS_ENDPOINT_DESCRIPTOR_TYPE: u32 = 37;
pub const VIDEO_VC_DESCRIPTOR_UNDEFINED_DESCRIPTOR_SUBTYPE: u32 = 0;
pub const VIDEO_VC_HEADER_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const VIDEO_VC_INPUT_TERMINAL_DESCRIPTOR_SUBTYPE: u32 = 2;
pub const VIDEO_VC_OUTPUT_TERMINAL_DESCRIPTOR_SUBTYPE: u32 = 3;
pub const VIDEO_VC_SELECTOR_UNIT_DESCRIPTOR_SUBTYPE: u32 = 4;
pub const VIDEO_VC_PROCESSING_UNIT_DESCRIPTOR_SUBTYPE: u32 = 5;
pub const VIDEO_VC_EXTENSION_UNIT_DESCRIPTOR_SUBTYPE: u32 = 6;
pub const VIDEO_VC_ENCODING_UNIT_DESCRIPTOR_SUBTYPE: u32 = 7;
pub const VIDEO_VS_UNDEFINED_DESCRIPTOR_SUBTYPE: u32 = 0;
pub const VIDEO_VS_INPUT_HEADER_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const VIDEO_VS_OUTPUT_HEADER_DESCRIPTOR_SUBTYPE: u32 = 2;
pub const VIDEO_VS_STILL_IMAGE_FRAME_DESCRIPTOR_SUBTYPE: u32 = 3;
pub const VIDEO_VS_FORMAT_UNCOMPRESSED_DESCRIPTOR_SUBTYPE: u32 = 4;
pub const VIDEO_VS_FRAME_UNCOMPRESSED_DESCRIPTOR_SUBTYPE: u32 = 5;
pub const VIDEO_VS_FORMAT_MJPEG_DESCRIPTOR_SUBTYPE: u32 = 6;
pub const VIDEO_VS_FRAME_MJPEG_DESCRIPTOR_SUBTYPE: u32 = 7;
pub const VIDEO_VS_FORMAT_MPEG2TS_DESCRIPTOR_SUBTYPE: u32 = 10;
pub const VIDEO_VS_FORMAT_DV_DESCRIPTOR_SUBTYPE: u32 = 12;
pub const VIDEO_VS_COLORFORMAT_DESCRIPTOR_SUBTYPE: u32 = 13;
pub const VIDEO_VS_FORMAT_FRAME_BASED_DESCRIPTOR_SUBTYPE: u32 = 16;
pub const VIDEO_VS_FRAME_FRAME_BASED_DESCRIPTOR_SUBTYPE: u32 = 17;
pub const VIDEO_VS_FORMAT_STREAM_BASED_DESCRIPTOR_SUBTYPE: u32 = 18;
pub const VIDEO_VS_FORMAT_H264_DESCRIPTOR_SUBTYPE: u32 = 19;
pub const VIDEO_VS_FRAME_H264_DESCRIPTOR_SUBTYPE: u32 = 20;
pub const VIDEO_VS_FORMAT_H264_SIMULCAST_DESCRIPTOR_SUBTYPE: u32 = 21;
pub const VIDEO_VS_FORMAT_VP8_DESCRIPTOR_SUBTYPE: u32 = 22;
pub const VIDEO_VS_FRAME_VP8_DESCRIPTOR_SUBTYPE: u32 = 23;
pub const VIDEO_VS_FORMAT_VP8_SIMULCAST_DESCRIPTOR_SUBTYPE: u32 = 24;
pub const VIDEO_EP_UNDEFINED_DESCRIPTOR_SUBTYPE: u32 = 0;
pub const VIDEO_EP_GENERAL_DESCRIPTOR_SUBTYPE: u32 = 1;
pub const VIDEO_EP_ENDPOINT_DESCRIPTOR_SUBTYPE: u32 = 2;
pub const VIDEO_EP_INTERRUPT_DESCRIPTOR_SUBTYPE: u32 = 3;
pub const VIDEO_REQUEST_UNDEFINED: u32 = 0;
pub const VIDEO_REQUEST_SET_CUR: u32 = 1;
pub const VIDEO_REQUEST_SET_CUR_ALL: u32 = 17;
pub const VIDEO_REQUEST_GET_CUR: u32 = 129;
pub const VIDEO_REQUEST_GET_MIN: u32 = 130;
pub const VIDEO_REQUEST_GET_MAX: u32 = 131;
pub const VIDEO_REQUEST_GET_RES: u32 = 132;
pub const VIDEO_REQUEST_GET_LEN: u32 = 133;
pub const VIDEO_REQUEST_GET_INFO: u32 = 134;
pub const VIDEO_REQUEST_GET_DEF: u32 = 135;
pub const VIDEO_REQUEST_GET_CUR_ALL: u32 = 145;
pub const VIDEO_REQUEST_GET_MIN_ALL: u32 = 146;
pub const VIDEO_REQUEST_GET_MAX_ALL: u32 = 147;
pub const VIDEO_REQUEST_GET_RES_ALL: u32 = 148;
pub const VIDEO_REQUEST_GET_DEF_ALL: u32 = 151;
pub const VIDEO_VC_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_VC_VIDEO_POWER_MODE_CONTROL: u32 = 1;
pub const VIDEO_VC_REQUEST_ERROR_CODE_CONTROL: u32 = 2;
pub const VIDEO_TE_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_SU_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_SU_INPUT_SELECT_CONTROL: u32 = 1;
pub const VIDEO_CT_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_CT_SCANNING_MODE_CONTROL: u32 = 1;
pub const VIDEO_CT_AE_MODE_CONTROL: u32 = 2;
pub const VIDEO_CT_AE_PRIORITY_CONTROL: u32 = 3;
pub const VIDEO_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 4;
pub const VIDEO_CT_EXPOSURE_TIME_RELATIVE_CONTROL: u32 = 5;
pub const VIDEO_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 6;
pub const VIDEO_CT_FOCUS_RELATIVE_CONTROL: u32 = 7;
pub const VIDEO_CT_FOCUS_AUTO_CONTROL: u32 = 8;
pub const VIDEO_CT_IRIS_ABSOLUTE_CONTROL: u32 = 9;
pub const VIDEO_CT_IRIS_RELATIVE_CONTROL: u32 = 10;
pub const VIDEO_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 11;
pub const VIDEO_CT_ZOOM_RELATIVE_CONTROL: u32 = 12;
pub const VIDEO_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 13;
pub const VIDEO_CT_PANTILT_RELATIVE_CONTROL: u32 = 14;
pub const VIDEO_CT_ROLL_ABSOLUTE_CONTROL: u32 = 15;
pub const VIDEO_CT_ROLL_RELATIVE_CONTROL: u32 = 16;
pub const VIDEO_CT_PRIVACY_CONTROL: u32 = 17;
pub const VIDEO_CT_FOCUS_SIMPLE_CONTROL: u32 = 18;
pub const VIDEO_CT_WINDOW_CONTROL: u32 = 19;
pub const VIDEO_CT_REGION_OF_INTEREST_CONTROL: u32 = 20;
pub const VIDEO_PU_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 1;
pub const VIDEO_PU_BRIGHTNESS_CONTROL: u32 = 2;
pub const VIDEO_PU_CONTRAST_CONTROL: u32 = 3;
pub const VIDEO_PU_GAIN_CONTROL: u32 = 4;
pub const VIDEO_PU_POWER_LINE_FREQUENCY_CONTROL: u32 = 5;
pub const VIDEO_PU_HUE_CONTROL: u32 = 6;
pub const VIDEO_PU_SATURATION_CONTROL: u32 = 7;
pub const VIDEO_PU_SHARPNESS_CONTROL: u32 = 8;
pub const VIDEO_PU_GAMMA_CONTROL: u32 = 9;
pub const VIDEO_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 10;
pub const VIDEO_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL: u32 = 11;
pub const VIDEO_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 12;
pub const VIDEO_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL: u32 = 13;
pub const VIDEO_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 14;
pub const VIDEO_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 15;
pub const VIDEO_PU_HUE_AUTO_CONTROL: u32 = 16;
pub const VIDEO_PU_ANALOG_VIDEO_STANDARD_CONTROL: u32 = 17;
pub const VIDEO_PU_ANALOG_LOCK_STATUS_CONTROL: u32 = 18;
pub const VIDEO_PU_CONTRAST_AUTO_CONTROL: u32 = 19;
pub const VIDEO_EU_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_EU_SELECT_LAYER_CONTROL: u32 = 1;
pub const VIDEO_EU_PROFILE_TOOLSET_CONTROL: u32 = 2;
pub const VIDEO_EU_VIDEO_RESOLUTION_CONTROL: u32 = 3;
pub const VIDEO_EU_MIN_FRAME_INTERVAL_CONTROL: u32 = 4;
pub const VIDEO_EU_SLICE_MODE_CONTROL: u32 = 5;
pub const VIDEO_EU_RATE_CONTROL_MODE_CONTROL: u32 = 6;
pub const VIDEO_EU_AVERAGE_BITRATE_CONTROL: u32 = 7;
pub const VIDEO_EU_CPB_SIZE_CONTROL: u32 = 8;
pub const VIDEO_EU_PEAK_BIT_RATE_CONTROL: u32 = 9;
pub const VIDEO_EU_QUANTIZATION_PARAMS_CONTROL: u32 = 10;
pub const VIDEO_EU_SYNC_REF_FRAME_CONTROL: u32 = 11;
pub const VIDEO_EU_LTR_BUFFER_CONTROL: u32 = 12;
pub const VIDEO_EU_LTR_PICTURE_CONTROL: u32 = 13;
pub const VIDEO_EU_LTR_VALIDATION_CONTROL: u32 = 14;
pub const VIDEO_EU_LEVEL_IDC_LIMIT_CONTROL: u32 = 15;
pub const VIDEO_EU_SEI_PAYLOADTYPE_CONTROL: u32 = 16;
pub const VIDEO_EU_QP_RANGE_CONTROL: u32 = 17;
pub const VIDEO_EU_PRIORITY_CONTROL: u32 = 18;
pub const VIDEO_EU_START_OR_STOP_LAYER_CONTROL: u32 = 19;
pub const VIDEO_EU_ERROR_RESILIENCY_CONTROL: u32 = 20;
pub const VIDEO_XU_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_VS_CONTROL_UNDEFINED: u32 = 0;
pub const VIDEO_VS_PROBE_CONTROL: u32 = 1;
pub const VIDEO_VS_COMMIT_CONTROL: u32 = 2;
pub const VIDEO_VS_STILL_PROBE_CONTROL: u32 = 3;
pub const VIDEO_VS_STILL_COMMIT_CONTROL: u32 = 4;
pub const VIDEO_VS_STILL_IMAGE_TRIGGER_CONTROL: u32 = 5;
pub const VIDEO_VS_STREAM_ERROR_CODE_CONTROL: u32 = 6;
pub const VIDEO_VS_GENERATE_KEY_FRAME_CONTROL: u32 = 7;
pub const VIDEO_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 8;
pub const VIDEO_VS_SYNCH_DELAY_CONTROL: u32 = 9;
pub const VIDEO_TT_VENDOR_SPECIFIC: u32 = 256;
pub const VIDEO_TT_STREAMING: u32 = 257;
pub const VIDEO_ITT_VENDOR_SPECIFIC: u32 = 512;
pub const VIDEO_ITT_CAMERA: u32 = 513;
pub const VIDEO_ITT_MEDIA_TRANSPORT_INPUT: u32 = 514;
pub const VIDEO_OTT_VENDOR_SPECIFIC: u32 = 768;
pub const VIDEO_OTT_DISPLAY: u32 = 769;
pub const VIDEO_OTT_MEDIA_TRANSPORT_OUTPUT: u32 = 770;
pub const VIDEO_ET_VENDOR_SPECIFIC: u32 = 1024;
pub const VIDEO_ET_COMPOSITE_CONNECTOR: u32 = 1025;
pub const VIDEO_ET_SVIDEO_CONNECTOR: u32 = 1026;
pub const VIDEO_ET_COMPONENT_CONNECTOR: u32 = 1027;
pub const VIDEO_SET_REQUEST_INTERFACE: u32 = 33;
pub const VIDEO_SET_REQUEST_ENDPOINT: u32 = 34;
pub const VIDEO_GET_REQUEST_INTERFACE: u32 = 161;
pub const VIDEO_GET_REQUEST_ENDPOINT: u32 = 162;
pub const VIDEO_STILL_IMAGE_TRIGGER_NORMAL_OPERATION: u32 = 0;
pub const VIDEO_STILL_IMAGE_TRIGGER_TRANSMIT_STILL_IMAGE: u32 = 1;
pub const VIDEO_STILL_IMAGE_TRIGGER_TRANSMIT_STILL_IMAGE_VS_DEDICATED_BULK_PIPE: u32 = 2;
pub const VIDEO_STILL_IMAGE_TRIGGER_ABORT_STILL_IMAGE_TRANSMISSION: u32 = 3;
pub const VIDEO_GET_CUR_VC_POWER_MODE_CONTROL: u32 = 33025;
pub const VIDEO_GET_CUR_VC_ERROR_CODE_CONTROL: u32 = 33026;
pub const VIDEO_GET_CUR_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 33057;
pub const VIDEO_GET_CUR_PU_BRIGHTNESS_CONTROL: u32 = 33058;
pub const VIDEO_GET_CUR_PU_CONTRACT_CONTROL: u32 = 33059;
pub const VIDEO_GET_CUR_PU_GAIN_CONTROL: u32 = 33060;
pub const VIDEO_GET_CUR_PU_POWER_LINE_FREQUENCY_CONTROL: u32 = 33061;
pub const VIDEO_GET_CUR_PU_HUE_CONTROL: u32 = 33062;
pub const VIDEO_GET_CUR_PU_SATURATION_CONTROL: u32 = 33063;
pub const VIDEO_GET_CUR_PU_SHARRNESS_CONTROL: u32 = 33064;
pub const VIDEO_GET_CUR_PU_GAMMA_CONTROL: u32 = 33065;
pub const VIDEO_GET_CUR_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 33066;
pub const VIDEO_GET_CUR_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL: u32 = 33067;
pub const VIDEO_GET_CUR_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 33068;
pub const VIDEO_GET_CUR_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL: u32 = 33069;
pub const VIDEO_GET_CUR_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 33070;
pub const VIDEO_GET_CUR_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 33071;
pub const VIDEO_GET_CUR_PU_HUE_AUTO_CONTROL: u32 = 33072;
pub const VIDEO_GET_CUR_PU_ANALOG_VIDEO_STANDARD_CONTROL: u32 = 33073;
pub const VIDEO_GET_CUR_PU_ANALOG_LOCK_STATUS_CONTROL: u32 = 33074;
pub const VIDEO_GET_CUR_CT_SCANNING_MODE_CONTROL: u32 = 33089;
pub const VIDEO_GET_CUR_CT_AE_MODE_CONTROL: u32 = 33090;
pub const VIDEO_GET_CUR_CT_AE_PRIORITY_CONTROL: u32 = 33091;
pub const VIDEO_GET_CUR_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 33092;
pub const VIDEO_GET_CUR_CT_EXPOSURE_TIME_RELATIVE_CONTROL: u32 = 33093;
pub const VIDEO_GET_CUR_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 33094;
pub const VIDEO_GET_CUR_CT_FOCUS_RELATIVE_CONTROL: u32 = 33095;
pub const VIDEO_GET_CUR_CT_FOCUS_AUTO_CONTROL: u32 = 33096;
pub const VIDEO_GET_CUR_CT_IRIS_ABSOLUTE_CONTROL: u32 = 33097;
pub const VIDEO_GET_CUR_CT_IRIS_RELATIVE_CONTROL: u32 = 33098;
pub const VIDEO_GET_CUR_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 33099;
pub const VIDEO_GET_CUR_CT_ZOOM_RELATIVE_CONTROL: u32 = 33100;
pub const VIDEO_GET_CUR_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 33101;
pub const VIDEO_GET_CUR_CT_PANTILT_RELATIVE_CONTROL: u32 = 33102;
pub const VIDEO_GET_CUR_CT_ROLL_ABSOLUTE_CONTROL: u32 = 33103;
pub const VIDEO_GET_CUR_CT_ROLL_RELATIVE_CONTROL: u32 = 33104;
pub const VIDEO_GET_CUR_CT_PRIVACY_CONTROL: u32 = 33105;
pub const VIDEO_GET_CUR_VS_PROBE_CONTROL: u32 = 33121;
pub const VIDEO_GET_CUR_VS_COMMIT_CONTROL: u32 = 33122;
pub const VIDEO_GET_CUR_VS_STILL_PROBE_CONTROL: u32 = 33123;
pub const VIDEO_GET_CUR_VS_STILL_COMMIT_CONTROL: u32 = 33124;
pub const VIDEO_GET_CUR_VS_STILL_IMAGE_TRIGGER_CONTROL: u32 = 33125;
pub const VIDEO_GET_CUR_VS_STREAM_ERROR_CODE_CONTROL: u32 = 33126;
pub const VIDEO_GET_CUR_VS_GENERATE_KEY_FRAME_CONTROL: u32 = 33127;
pub const VIDEO_GET_CUR_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 33128;
pub const VIDEO_GET_CUR_VS_SYNCH_DELAY_CONTROL: u32 = 33129;
pub const VIDEO_GET_MIN_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 33313;
pub const VIDEO_GET_MIN_PU_BRIGHTNESS_CONTROL: u32 = 33314;
pub const VIDEO_GET_MIN_PU_CONTRACT_CONTROL: u32 = 33315;
pub const VIDEO_GET_MIN_PU_GAIN_CONTROL: u32 = 33316;
pub const VIDEO_GET_MIN_PU_HUE_CONTROL: u32 = 33318;
pub const VIDEO_GET_MIN_PU_SATURATION_CONTROL: u32 = 33319;
pub const VIDEO_GET_MIN_PU_SHARRNESS_CONTROL: u32 = 33320;
pub const VIDEO_GET_MIN_PU_GAMMA_CONTROL: u32 = 33321;
pub const VIDEO_GET_MIN_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 33322;
pub const VIDEO_GET_MIN_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 33324;
pub const VIDEO_GET_MIN_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 33326;
pub const VIDEO_GET_MIN_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 33327;
pub const VIDEO_GET_MIN_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 33348;
pub const VIDEO_GET_MIN_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 33350;
pub const VIDEO_GET_MIN_CT_FOCUS_RELATIVE_CONTROL: u32 = 33351;
pub const VIDEO_GET_MIN_CT_IRIS_ABSOLUTE_CONTROL: u32 = 33353;
pub const VIDEO_GET_MIN_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 33355;
pub const VIDEO_GET_MIN_CT_ZOOM_RELATIVE_CONTROL: u32 = 33356;
pub const VIDEO_GET_MIN_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 33357;
pub const VIDEO_GET_MIN_CT_PANTILT_RELATIVE_CONTROL: u32 = 33358;
pub const VIDEO_GET_MIN_CT_ROLL_ABSOLUTE_CONTROL: u32 = 33359;
pub const VIDEO_GET_MIN_CT_ROLL_RELATIVE_CONTROL: u32 = 33360;
pub const VIDEO_GET_MIN_VS_PROBE_CONTROL: u32 = 33377;
pub const VIDEO_GET_MIN_VS_STILL_PROBE_CONTROL: u32 = 33379;
pub const VIDEO_GET_MIN_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 33384;
pub const VIDEO_GET_MIN_VS_SYNCH_DELAY_CONTROL: u32 = 33385;
pub const VIDEO_GET_MAX_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 33569;
pub const VIDEO_GET_MAX_PU_BRIGHTNESS_CONTROL: u32 = 33570;
pub const VIDEO_GET_MAX_PU_CONTRACT_CONTROL: u32 = 33571;
pub const VIDEO_GET_MAX_PU_GAIN_CONTROL: u32 = 33572;
pub const VIDEO_GET_MAX_PU_HUE_CONTROL: u32 = 33574;
pub const VIDEO_GET_MAX_PU_SATURATION_CONTROL: u32 = 33575;
pub const VIDEO_GET_MAX_PU_SHARRNESS_CONTROL: u32 = 33576;
pub const VIDEO_GET_MAX_PU_GAMMA_CONTROL: u32 = 33577;
pub const VIDEO_GET_MAX_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 33578;
pub const VIDEO_GET_MAX_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 33580;
pub const VIDEO_GET_MAX_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 33582;
pub const VIDEO_GET_MAX_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 33583;
pub const VIDEO_GET_MAX_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 33604;
pub const VIDEO_GET_MAX_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 33606;
pub const VIDEO_GET_MAX_CT_FOCUS_RELATIVE_CONTROL: u32 = 33607;
pub const VIDEO_GET_MAX_CT_IRIS_ABSOLUTE_CONTROL: u32 = 33609;
pub const VIDEO_GET_MAX_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 33611;
pub const VIDEO_GET_MAX_CT_ZOOM_RELATIVE_CONTROL: u32 = 33612;
pub const VIDEO_GET_MAX_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 33613;
pub const VIDEO_GET_MAX_CT_PANTILT_RELATIVE_CONTROL: u32 = 33614;
pub const VIDEO_GET_MAX_CT_ROLL_ABSOLUTE_CONTROL: u32 = 33615;
pub const VIDEO_GET_MAX_CT_ROLL_RELATIVE_CONTROL: u32 = 33616;
pub const VIDEO_GET_MAX_VS_PROBE_CONTROL: u32 = 33633;
pub const VIDEO_GET_MAX_VS_STILL_PROBE_CONTROL: u32 = 33635;
pub const VIDEO_GET_MAX_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 33640;
pub const VIDEO_GET_MAX_VS_SYNCH_DELAY_CONTROL: u32 = 33641;
pub const VIDEO_GET_RES_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 33825;
pub const VIDEO_GET_RES_PU_BRIGHTNESS_CONTROL: u32 = 33826;
pub const VIDEO_GET_RES_PU_CONTRACT_CONTROL: u32 = 33827;
pub const VIDEO_GET_RES_PU_GAIN_CONTROL: u32 = 33828;
pub const VIDEO_GET_RES_PU_HUE_CONTROL: u32 = 33830;
pub const VIDEO_GET_RES_PU_SATURATION_CONTROL: u32 = 33831;
pub const VIDEO_GET_RES_PU_SHARRNESS_CONTROL: u32 = 33832;
pub const VIDEO_GET_RES_PU_GAMMA_CONTROL: u32 = 33833;
pub const VIDEO_GET_RES_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 33834;
pub const VIDEO_GET_RES_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 33836;
pub const VIDEO_GET_RES_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 33838;
pub const VIDEO_GET_RES_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 33839;
pub const VIDEO_GET_RES_CT_AE_MODE_CONTROL: u32 = 33858;
pub const VIDEO_GET_RES_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 33860;
pub const VIDEO_GET_RES_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 33862;
pub const VIDEO_GET_RES_CT_FOCUS_RELATIVE_CONTROL: u32 = 33863;
pub const VIDEO_GET_RES_CT_IRIS_ABSOLUTE_CONTROL: u32 = 33865;
pub const VIDEO_GET_RES_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 33867;
pub const VIDEO_GET_RES_CT_ZOOM_RELATIVE_CONTROL: u32 = 33868;
pub const VIDEO_GET_RES_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 33869;
pub const VIDEO_GET_RES_CT_PANTILT_RELATIVE_CONTROL: u32 = 33870;
pub const VIDEO_GET_RES_CT_ROLL_ABSOLUTE_CONTROL: u32 = 33871;
pub const VIDEO_GET_RES_CT_ROLL_RELATIVE_CONTROL: u32 = 33872;
pub const VIDEO_GET_RES_VS_PROBE_CONTROL: u32 = 33889;
pub const VIDEO_GET_RES_VS_STILL_PROBE_CONTROL: u32 = 33891;
pub const VIDEO_GET_RES_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 33896;
pub const VIDEO_GET_RES_VS_SYNCH_DELAY_CONTROL: u32 = 33897;
pub const VIDEO_GET_LEN_VS_PROBE_CONTROL: u32 = 34145;
pub const VIDEO_GET_LEN_VS_COMMIT_CONTROL: u32 = 34146;
pub const VIDEO_GET_LEN_VS_STILL_PROBE_CONTROL: u32 = 34147;
pub const VIDEO_GET_LEN_VS_STILL_COMMIT_CONTROL: u32 = 34148;
pub const VIDEO_GET_INFO_VC_POWER_MODE_CONTROL: u32 = 34305;
pub const VIDEO_GET_INFO_VC_ERROR_CODE_CONTROL: u32 = 34306;
pub const VIDEO_GET_INFO_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 34337;
pub const VIDEO_GET_INFO_PU_BRIGHTNESS_CONTROL: u32 = 34338;
pub const VIDEO_GET_INFO_PU_CONTRACT_CONTROL: u32 = 34339;
pub const VIDEO_GET_INFO_PU_GAIN_CONTROL: u32 = 34340;
pub const VIDEO_GET_INFO_PU_POWER_LINE_FREQUENCY_CONTROL: u32 = 34341;
pub const VIDEO_GET_INFO_PU_HUE_CONTROL: u32 = 34342;
pub const VIDEO_GET_INFO_PU_SATURATION_CONTROL: u32 = 34343;
pub const VIDEO_GET_INFO_PU_SHARRNESS_CONTROL: u32 = 34344;
pub const VIDEO_GET_INFO_PU_GAMMA_CONTROL: u32 = 34345;
pub const VIDEO_GET_INFO_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 34346;
pub const VIDEO_GET_INFO_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL: u32 = 34347;
pub const VIDEO_GET_INFO_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 34348;
pub const VIDEO_GET_INFO_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL: u32 = 34349;
pub const VIDEO_GET_INFO_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 34350;
pub const VIDEO_GET_INFO_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 34351;
pub const VIDEO_GET_INFO_PU_HUE_AUTO_CONTROL: u32 = 34352;
pub const VIDEO_GET_INFO_PU_ANALOG_VIDEO_STANDARD_CONTROL: u32 = 34353;
pub const VIDEO_GET_INFO_PU_ANALOG_LOCK_STATUS_CONTROL: u32 = 34354;
pub const VIDEO_GET_INFO_CT_SCANNING_MODE_CONTROL: u32 = 34369;
pub const VIDEO_GET_INFO_CT_AE_MODE_CONTROL: u32 = 34370;
pub const VIDEO_GET_INFO_CT_AE_PRIORITY_CONTROL: u32 = 34371;
pub const VIDEO_GET_INFO_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 34372;
pub const VIDEO_GET_INFO_CT_EXPOSURE_TIME_RELATIVE_CONTROL: u32 = 34373;
pub const VIDEO_GET_INFO_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 34374;
pub const VIDEO_GET_INFO_CT_FOCUS_RELATIVE_CONTROL: u32 = 34375;
pub const VIDEO_GET_INFO_CT_FOCUS_AUTO_CONTROL: u32 = 34376;
pub const VIDEO_GET_INFO_CT_IRIS_ABSOLUTE_CONTROL: u32 = 34377;
pub const VIDEO_GET_INFO_CT_IRIS_RELATIVE_CONTROL: u32 = 34378;
pub const VIDEO_GET_INFO_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 34379;
pub const VIDEO_GET_INFO_CT_ZOOM_RELATIVE_CONTROL: u32 = 34380;
pub const VIDEO_GET_INFO_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 34381;
pub const VIDEO_GET_INFO_CT_PANTILT_RELATIVE_CONTROL: u32 = 34382;
pub const VIDEO_GET_INFO_CT_ROLL_ABSOLUTE_CONTROL: u32 = 34383;
pub const VIDEO_GET_INFO_CT_ROLL_RELATIVE_CONTROL: u32 = 34384;
pub const VIDEO_GET_INFO_CT_PRIVACY_CONTROL: u32 = 34385;
pub const VIDEO_GET_INFO_VS_PROBE_CONTROL: u32 = 34401;
pub const VIDEO_GET_INFO_VS_COMMIT_CONTROL: u32 = 34402;
pub const VIDEO_GET_INFO_VS_STILL_PROBE_CONTROL: u32 = 34403;
pub const VIDEO_GET_INFO_VS_STILL_COMMIT_CONTROL: u32 = 34404;
pub const VIDEO_GET_INFO_VS_STILL_IMAGE_TRIGGER_CONTROL: u32 = 34405;
pub const VIDEO_GET_INFO_VS_STREAM_ERROR_CODE_CONTROL: u32 = 34406;
pub const VIDEO_GET_INFO_VS_GENERATE_KEY_FRAME_CONTROL: u32 = 34407;
pub const VIDEO_GET_INFO_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 34408;
pub const VIDEO_GET_INFO_VS_SYNCH_DELAY_CONTROL: u32 = 34409;
pub const VIDEO_GET_DEF_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 34593;
pub const VIDEO_GET_DEF_PU_BRIGHTNESS_CONTROL: u32 = 34594;
pub const VIDEO_GET_DEF_PU_CONTRACT_CONTROL: u32 = 34595;
pub const VIDEO_GET_DEF_PU_GAIN_CONTROL: u32 = 34596;
pub const VIDEO_GET_DEF_PU_POWER_LINE_FREQUENCY_CONTROL: u32 = 34597;
pub const VIDEO_GET_DEF_PU_HUE_CONTROL: u32 = 34598;
pub const VIDEO_GET_DEF_PU_SATURATION_CONTROL: u32 = 34599;
pub const VIDEO_GET_DEF_PU_SHARRNESS_CONTROL: u32 = 34600;
pub const VIDEO_GET_DEF_PU_GAMMA_CONTROL: u32 = 34601;
pub const VIDEO_GET_DEF_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 34602;
pub const VIDEO_GET_DEF_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL: u32 = 34603;
pub const VIDEO_GET_DEF_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 34604;
pub const VIDEO_GET_DEF_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL: u32 = 34605;
pub const VIDEO_GET_DEF_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 34606;
pub const VIDEO_GET_DEF_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 34607;
pub const VIDEO_GET_DEF_PU_HUE_AUTO_CONTROL: u32 = 34608;
pub const VIDEO_GET_DEF_CT_AE_MODE_CONTROL: u32 = 34626;
pub const VIDEO_GET_DEF_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 34628;
pub const VIDEO_GET_DEF_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 34630;
pub const VIDEO_GET_DEF_CT_FOCUS_RELATIVE_CONTROL: u32 = 34631;
pub const VIDEO_GET_DEF_CT_FOCUS_AUTO_CONTROL: u32 = 34632;
pub const VIDEO_GET_DEF_CT_IRIS_ABSOLUTE_CONTROL: u32 = 34633;
pub const VIDEO_GET_DEF_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 34635;
pub const VIDEO_GET_DEF_CT_ZOOM_RELATIVE_CONTROL: u32 = 34636;
pub const VIDEO_GET_DEF_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 34637;
pub const VIDEO_GET_DEF_CT_PANTILT_RELATIVE_CONTROL: u32 = 34638;
pub const VIDEO_GET_DEF_CT_ROLL_ABSOLUTE_CONTROL: u32 = 34639;
pub const VIDEO_GET_DEF_CT_ROLL_RELATIVE_CONTROL: u32 = 34640;
pub const VIDEO_GET_DEF_VS_PROBE_CONTROL: u32 = 34657;
pub const VIDEO_GET_DEF_VS_STILL_PROBE_CONTROL: u32 = 34659;
pub const VIDEO_GET_DEF_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 34664;
pub const VIDEO_GET_DEF_VS_SYNCH_DELAY_CONTROL: u32 = 34665;
pub const VIDEO_SET_CUR_VC_POWER_MODE_CONTROL: u32 = 257;
pub const VIDEO_SET_CUR_PU_BACKLIGHT_COMPENSATION_CONTROL: u32 = 289;
pub const VIDEO_SET_CUR_PU_BRIGHTNESS_CONTROL: u32 = 290;
pub const VIDEO_SET_CUR_PU_CONTRACT_CONTROL: u32 = 291;
pub const VIDEO_SET_CUR_PU_GAIN_CONTROL: u32 = 292;
pub const VIDEO_SET_CUR_PU_POWER_LINE_FREQUENCY_CONTROL: u32 = 293;
pub const VIDEO_SET_CUR_PU_HUE_CONTROL: u32 = 294;
pub const VIDEO_SET_CUR_PU_SATURATION_CONTROL: u32 = 295;
pub const VIDEO_SET_CUR_PU_SHARRNESS_CONTROL: u32 = 296;
pub const VIDEO_SET_CUR_PU_GAMMA_CONTROL: u32 = 297;
pub const VIDEO_SET_CUR_PU_WHITE_BALANCE_TEMPERATURE_CONTROL: u32 = 298;
pub const VIDEO_SET_CUR_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL: u32 = 299;
pub const VIDEO_SET_CUR_PU_WHITE_BALANCE_COMPONENT_CONTROL: u32 = 300;
pub const VIDEO_SET_CUR_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL: u32 = 301;
pub const VIDEO_SET_CUR_PU_DIGITAL_MULTIPLIER_CONTROL: u32 = 302;
pub const VIDEO_SET_CUR_PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL: u32 = 303;
pub const VIDEO_SET_CUR_PU_HUE_AUTO_CONTROL: u32 = 304;
pub const VIDEO_SET_CUR_CT_SCANNING_MODE_CONTROL: u32 = 321;
pub const VIDEO_SET_CUR_CT_AE_MODE_CONTROL: u32 = 322;
pub const VIDEO_SET_CUR_CT_AE_PRIORITY_CONTROL: u32 = 323;
pub const VIDEO_SET_CUR_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL: u32 = 324;
pub const VIDEO_SET_CUR_CT_EXPOSURE_TIME_RELATIVE_CONTROL: u32 = 325;
pub const VIDEO_SET_CUR_CT_FOCUS_ABSOLUTE_CONTROL: u32 = 326;
pub const VIDEO_SET_CUR_CT_FOCUS_RELATIVE_CONTROL: u32 = 327;
pub const VIDEO_SET_CUR_CT_FOCUS_AUTO_CONTROL: u32 = 328;
pub const VIDEO_SET_CUR_CT_IRIS_ABSOLUTE_CONTROL: u32 = 329;
pub const VIDEO_SET_CUR_CT_IRIS_RELATIVE_CONTROL: u32 = 330;
pub const VIDEO_SET_CUR_CT_ZOOM_ABSOLUTE_CONTROL: u32 = 331;
pub const VIDEO_SET_CUR_CT_ZOOM_RELATIVE_CONTROL: u32 = 332;
pub const VIDEO_SET_CUR_CT_PANTILT_ABSOLUTE_CONTROL: u32 = 333;
pub const VIDEO_SET_CUR_CT_PANTILT_RELATIVE_CONTROL: u32 = 334;
pub const VIDEO_SET_CUR_CT_ROLL_ABSOLUTE_CONTROL: u32 = 335;
pub const VIDEO_SET_CUR_CT_ROLL_RELATIVE_CONTROL: u32 = 336;
pub const VIDEO_SET_CUR_CT_PRIVACY_CONTROL: u32 = 337;
pub const VIDEO_SET_CUR_VS_PROBE_CONTROL: u32 = 353;
pub const VIDEO_SET_CUR_VS_COMMIT_CONTROL: u32 = 354;
pub const VIDEO_SET_CUR_VS_STILL_PROBE_CONTROL: u32 = 355;
pub const VIDEO_SET_CUR_VS_STILL_COMMIT_CONTROL: u32 = 356;
pub const VIDEO_SET_CUR_VS_STILL_IMAGE_TRIGGER_CONTROL: u32 = 357;
pub const VIDEO_SET_CUR_VS_STREAM_ERROR_CODE_CONTROL: u32 = 358;
pub const VIDEO_SET_CUR_VS_GENERATE_KEY_FRAME_CONTROL: u32 = 359;
pub const VIDEO_SET_CUR_VS_UPDATE_FRAME_SEGMENT_CONTROL: u32 = 360;
pub const VIDEO_SET_CUR_VS_SYNCH_DELAY_CONTROL: u32 = 361;
pub const VIDEO_SIZEOF_VC_OUTPUT_TERMINAL_DESC: u32 = 9;
pub const VIDEO_SIZEOF_VC_EP_DESC: u32 = 5;
pub const VIDEO_SIZEOF_VS_FORMAT_UNCOMPRESSED_DESC: u32 = 27;
pub const VIDEO_SIZEOF_VS_FORMAT_MJPEG_DESC: u32 = 11;
pub const VIDEO_SIZEOF_VS_FORMAT_H264_DESC: u32 = 28;
pub const VIDEO_SIZEOF_VS_COLORFORMAT_DESC: u32 = 6;
pub const VIDEO_VC_TERMINAL_LEN: u32 = 52;
pub const VIDEO_VC_DESCRIPTOR_LEN: u32 = 81;
pub const VIDEO_VC_NOEP_DESCRIPTOR_LEN: u32 = 69;
pub const USBH_VIDEO_FORMAT_UNCOMPRESSED: u32 = 0;
pub const USBH_VIDEO_FORMAT_MJPEG: u32 = 1;
pub const NDIS_STATUS_MULTICAST_FULL: u32 = 3221291017;
pub const NDIS_STATUS_MULTICAST_EXISTS: u32 = 3221291018;
pub const NDIS_STATUS_MULTICAST_NOT_FOUND: u32 = 3221291019;
pub const OID_PNP_CAPABILITIES: u32 = 4244701440;
pub const OID_PNP_SET_POWER: u32 = 4244701441;
pub const OID_PNP_QUERY_POWER: u32 = 4244701442;
pub const OID_PNP_ADD_WAKE_UP_PATTERN: u32 = 4244701443;
pub const OID_PNP_REMOVE_WAKE_UP_PATTERN: u32 = 4244701444;
pub const OID_PNP_ENABLE_WAKE_UP: u32 = 4244701446;
pub const NDIS_DEVICE_WAKE_UP_ENABLE: u32 = 1;
pub const NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE: u32 = 2;
pub const NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE: u32 = 4;
pub const OID_GEN_SUPPORTED_LIST: u32 = 65793;
pub const OID_GEN_HARDWARE_STATUS: u32 = 65794;
pub const OID_GEN_MEDIA_SUPPORTED: u32 = 65795;
pub const OID_GEN_MEDIA_IN_USE: u32 = 65796;
pub const OID_GEN_MAXIMUM_LOOKAHEAD: u32 = 65797;
pub const OID_GEN_MAXIMUM_FRAME_SIZE: u32 = 65798;
pub const OID_GEN_LINK_SPEED: u32 = 65799;
pub const OID_GEN_TRANSMIT_BUFFER_SPACE: u32 = 65800;
pub const OID_GEN_RECEIVE_BUFFER_SPACE: u32 = 65801;
pub const OID_GEN_TRANSMIT_BLOCK_SIZE: u32 = 65802;
pub const OID_GEN_RECEIVE_BLOCK_SIZE: u32 = 65803;
pub const OID_GEN_VENDOR_ID: u32 = 65804;
pub const OID_GEN_VENDOR_DESCRIPTION: u32 = 65805;
pub const OID_GEN_CURRENT_PACKET_FILTER: u32 = 65806;
pub const OID_GEN_CURRENT_LOOKAHEAD: u32 = 65807;
pub const OID_GEN_DRIVER_VERSION: u32 = 65808;
pub const OID_GEN_MAXIMUM_TOTAL_SIZE: u32 = 65809;
pub const OID_GEN_PROTOCOL_OPTIONS: u32 = 65810;
pub const OID_GEN_MAC_OPTIONS: u32 = 65811;
pub const OID_GEN_MEDIA_CONNECT_STATUS: u32 = 65812;
pub const OID_GEN_MAXIMUM_SEND_PACKETS: u32 = 65813;
pub const OID_GEN_VENDOR_DRIVER_VERSION: u32 = 65814;
pub const OID_GEN_SUPPORTED_GUIDS: u32 = 65815;
pub const OID_GEN_NETWORK_LAYER_ADDRESSES: u32 = 65816;
pub const OID_GEN_TRANSPORT_HEADER_OFFSET: u32 = 65817;
pub const OID_GEN_MACHINE_NAME: u32 = 66074;
pub const OID_GEN_RNDIS_CONFIG_PARAMETER: u32 = 66075;
pub const OID_GEN_VLAN_ID: u32 = 66076;
pub const OID_GEN_MEDIA_CAPABILITIES: u32 = 66049;
pub const OID_GEN_PHYSICAL_MEDIUM: u32 = 66050;
pub const OID_GEN_XMIT_OK: u32 = 131329;
pub const OID_GEN_RCV_OK: u32 = 131330;
pub const OID_GEN_XMIT_ERROR: u32 = 131331;
pub const OID_GEN_RCV_ERROR: u32 = 131332;
pub const OID_GEN_RCV_NO_BUFFER: u32 = 131333;
pub const OID_GEN_DIRECTED_BYTES_XMIT: u32 = 131585;
pub const OID_GEN_DIRECTED_FRAMES_XMIT: u32 = 131586;
pub const OID_GEN_MULTICAST_BYTES_XMIT: u32 = 131587;
pub const OID_GEN_MULTICAST_FRAMES_XMIT: u32 = 131588;
pub const OID_GEN_BROADCAST_BYTES_XMIT: u32 = 131589;
pub const OID_GEN_BROADCAST_FRAMES_XMIT: u32 = 131590;
pub const OID_GEN_DIRECTED_BYTES_RCV: u32 = 131591;
pub const OID_GEN_DIRECTED_FRAMES_RCV: u32 = 131592;
pub const OID_GEN_MULTICAST_BYTES_RCV: u32 = 131593;
pub const OID_GEN_MULTICAST_FRAMES_RCV: u32 = 131594;
pub const OID_GEN_BROADCAST_BYTES_RCV: u32 = 131595;
pub const OID_GEN_BROADCAST_FRAMES_RCV: u32 = 131596;
pub const OID_GEN_RCV_CRC_ERROR: u32 = 131597;
pub const OID_GEN_TRANSMIT_QUEUE_LENGTH: u32 = 131598;
pub const OID_GEN_GET_TIME_CAPS: u32 = 131599;
pub const OID_GEN_GET_NETCARD_TIME: u32 = 131600;
pub const OID_GEN_NETCARD_LOAD: u32 = 131601;
pub const OID_GEN_DEVICE_PROFILE: u32 = 131602;
pub const OID_GEN_INIT_TIME_MS: u32 = 131603;
pub const OID_GEN_RESET_COUNTS: u32 = 131604;
pub const OID_GEN_MEDIA_SENSE_COUNTS: u32 = 131605;
pub const OID_GEN_FRIENDLY_NAME: u32 = 131606;
pub const OID_GEN_MINIPORT_INFO: u32 = 131607;
pub const OID_GEN_RESET_VERIFY_PARAMETERS: u32 = 131608;
pub const NDIS_802_3_MAC_OPTION_PRIORITY: u32 = 1;
pub const OID_802_3_PERMANENT_ADDRESS: u32 = 16843009;
pub const OID_802_3_CURRENT_ADDRESS: u32 = 16843010;
pub const OID_802_3_MULTICAST_LIST: u32 = 16843011;
pub const OID_802_3_MAXIMUM_LIST_SIZE: u32 = 16843012;
pub const OID_802_3_MAC_OPTIONS: u32 = 16843013;
pub const OID_802_3_RCV_ERROR_ALIGNMENT: u32 = 16908545;
pub const OID_802_3_XMIT_ONE_COLLISION: u32 = 16908546;
pub const OID_802_3_XMIT_MORE_COLLISIONS: u32 = 16908547;
pub const OID_802_3_XMIT_DEFERRED: u32 = 16908801;
pub const OID_802_3_XMIT_MAX_COLLISIONS: u32 = 16908802;
pub const OID_802_3_RCV_OVERRUN: u32 = 16908803;
pub const OID_802_3_XMIT_UNDERRUN: u32 = 16908804;
pub const OID_802_3_XMIT_HEARTBEAT_FAILURE: u32 = 16908805;
pub const OID_802_3_XMIT_TIMES_CRS_LOST: u32 = 16908806;
pub const OID_802_3_XMIT_LATE_COLLISIONS: u32 = 16908807;
pub const OID_802_11_BSSID: u32 = 218169601;
pub const OID_802_11_SSID: u32 = 218169602;
pub const OID_802_11_NETWORK_TYPE_IN_USE: u32 = 218169860;
pub const OID_802_11_RSSI: u32 = 218169862;
pub const OID_802_11_BSSID_LIST: u32 = 218169879;
pub const OID_802_11_BSSID_LIST_SCAN: u32 = 218169626;
pub const OID_802_11_INFRASTRUCTURE_MODE: u32 = 218169608;
pub const OID_802_11_SUPPORTED_RATES: u32 = 218169870;
pub const OID_802_11_CONFIGURATION: u32 = 218169873;
pub const OID_802_11_ADD_WEP: u32 = 218169619;
pub const OID_802_11_WEP_STATUS: u32 = 218169627;
pub const OID_802_11_REMOVE_WEP: u32 = 218169620;
pub const OID_802_11_DISASSOCIATE: u32 = 218169621;
pub const OID_802_11_AUTHENTICATION_MODE: u32 = 218169624;
pub const OID_802_11_RELOAD_DEFAULTS: u32 = 218169628;
pub const NDIS_MINIPORT_BUS_MASTER: u32 = 1;
pub const NDIS_MINIPORT_WDM_DRIVER: u32 = 2;
pub const NDIS_MINIPORT_SG_LIST: u32 = 4;
pub const NDIS_MINIPORT_SUPPORTS_MEDIA_QUERY: u32 = 8;
pub const NDIS_MINIPORT_INDICATES_PACKETS: u32 = 16;
pub const NDIS_MINIPORT_IGNORE_PACKET_QUEUE: u32 = 32;
pub const NDIS_MINIPORT_IGNORE_REQUEST_QUEUE: u32 = 64;
pub const NDIS_MINIPORT_IGNORE_TOKEN_RING_ERRORS: u32 = 128;
pub const NDIS_MINIPORT_INTERMEDIATE_DRIVER: u32 = 256;
pub const NDIS_MINIPORT_IS_NDIS_5: u32 = 512;
pub const NDIS_MINIPORT_IS_CO: u32 = 1024;
pub const NDIS_MINIPORT_DESERIALIZE: u32 = 2048;
pub const NDIS_MINIPORT_REQUIRES_MEDIA_POLLING: u32 = 4096;
pub const NDIS_MINIPORT_SUPPORTS_MEDIA_SENSE: u32 = 8192;
pub const NDIS_MINIPORT_NETBOOT_CARD: u32 = 16384;
pub const NDIS_MINIPORT_PM_SUPPORTED: u32 = 32768;
pub const NDIS_MINIPORT_SUPPORTS_MAC_ADDRESS_OVERWRITE: u32 = 65536;
pub const NDIS_MINIPORT_USES_SAFE_BUFFER_APIS: u32 = 131072;
pub const NDIS_MINIPORT_HIDDEN: u32 = 262144;
pub const NDIS_MINIPORT_SWENUM: u32 = 524288;
pub const NDIS_MINIPORT_SURPRISE_REMOVE_OK: u32 = 1048576;
pub const NDIS_MINIPORT_NO_HALT_ON_SUSPEND: u32 = 2097152;
pub const NDIS_MINIPORT_HARDWARE_DEVICE: u32 = 4194304;
pub const NDIS_MINIPORT_SUPPORTS_CANCEL_SEND_PACKETS: u32 = 8388608;
pub const NDIS_MINIPORT_64BITS_DMA: u32 = 16777216;
pub const NDIS_MEDIUM_802_3: u32 = 0;
pub const NDIS_MEDIUM_802_5: u32 = 1;
pub const NDIS_MEDIUM_FDDI: u32 = 2;
pub const NDIS_MEDIUM_WAN: u32 = 3;
pub const NDIS_MEDIUM_LOCAL_TALK: u32 = 4;
pub const NDIS_MEDIUM_DIX: u32 = 5;
pub const NDIS_MEDIUM_ARCENT_RAW: u32 = 6;
pub const NDIS_MEDIUM_ARCENT_878_2: u32 = 7;
pub const NDIS_MEDIUM_ATM: u32 = 8;
pub const NDIS_MEDIUM_WIRELESS_LAN: u32 = 9;
pub const NDIS_MEDIUM_IRDA: u32 = 10;
pub const NDIS_MEDIUM_BPC: u32 = 11;
pub const NDIS_MEDIUM_CO_WAN: u32 = 12;
pub const NDIS_MEDIUM_1394: u32 = 13;
pub const NDIS_PACKET_TYPE_DIRECTED: u32 = 1;
pub const NDIS_PACKET_TYPE_MULTICAST: u32 = 2;
pub const NDIS_PACKET_TYPE_ALL_MULTICAST: u32 = 4;
pub const NDIS_PACKET_TYPE_BROADCAST: u32 = 8;
pub const NDIS_PACKET_TYPE_SOURCE_ROUTING: u32 = 16;
pub const NDIS_PACKET_TYPE_PROMISCUOUS: u32 = 32;
pub const NDIS_PACKET_TYPE_SMT: u32 = 64;
pub const NDIS_PACKET_TYPE_ALL_LOCAL: u32 = 128;
pub const NDIS_PACKET_TYPE_GROUP: u32 = 256;
pub const NDIS_PACKET_TYPE_ALL_FUNCTIONAL: u32 = 512;
pub const NDIS_PACKET_TYPE_FUNCTIONAL: u32 = 1024;
pub const NDIS_PACKET_TYPE_MAC_FRAME: u32 = 2048;
pub const NDIS_MEDIA_STATE_CONNECTED: u32 = 0;
pub const NDIS_MEDIA_STATE_DISCONNECTED: u32 = 1;
pub const NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA: u32 = 1;
pub const NDIS_MAC_OPTION_RECEIVE_SERIALIZED: u32 = 2;
pub const NDIS_MAC_OPTION_TRANSFERS_NOT_PEND: u32 = 4;
pub const NDIS_MAC_OPTION_NO_LOOPBACK: u32 = 8;
pub const NDIS_MAC_OPTION_FULL_DUPLEX: u32 = 16;
pub const NDIS_MAC_OPTION_EOTX_INDICATION: u32 = 32;
pub const NDIS_MAC_OPTION_8021P_PRIORITY: u32 = 64;
pub const NDIS_MAC_OPTION_RESERVED: u32 = 2147483648;
pub const NDIS_HW_STS_READY: u32 = 0;
pub const NDIS_HW_STS_INITIALIZING: u32 = 1;
pub const NDIS_HW_STS_RESET: u32 = 2;
pub const NDIS_HW_STS_CLOSING: u32 = 3;
pub const NDIS_HW_STS_NOT_READY: u32 = 4;
pub const RNDIS_MAJOR_VERSION: u32 = 1;
pub const RNDIS_MINOR_VERSION: u32 = 0;
pub const RNDIS_STATUS_SUCCESS: u32 = 0;
pub const RNDIS_STATUS_FAILURE: u32 = 3221225473;
pub const RNDIS_STATUS_INVALID_DATA: u32 = 3221291029;
pub const RNDIS_STATUS_NOT_SUPPORTED: u32 = 3221225659;
pub const RNDIS_STATUS_MEDIA_CONNECT: u32 = 1073807371;
pub const RNDIS_STATUS_MEDIA_DISCONNECT: u32 = 1073807372;
pub const REMOTE_NDIS_PACKET_MSG: u32 = 1;
pub const REMOTE_NDIS_INITIALIZE_MSG: u32 = 2;
pub const REMOTE_NDIS_HALT_MSG: u32 = 3;
pub const REMOTE_NDIS_QUERY_MSG: u32 = 4;
pub const REMOTE_NDIS_SET_MSG: u32 = 5;
pub const REMOTE_NDIS_RESET_MSG: u32 = 6;
pub const REMOTE_NDIS_INDICATE_STATUS_MSG: u32 = 7;
pub const REMOTE_NDIS_KEEPALIVE_MSG: u32 = 8;
pub const REMOTE_NDIS_INITIALIZE_CMPLT: u32 = 2147483650;
pub const REMOTE_NDIS_QUERY_CMPLT: u32 = 2147483652;
pub const REMOTE_NDIS_SET_CMPLT: u32 = 2147483653;
pub const REMOTE_NDIS_RESET_CMPLT: u32 = 2147483654;
pub const REMOTE_NDIS_KEEPALIVE_CMPLT: u32 = 2147483656;
pub const RNDIS_DF_CONNECTIONLESS: u32 = 1;
pub const RNDIS_DF_CONNECTION_ORIENTED: u32 = 2;
pub const RNDIS_MEDIUM_802_3: u32 = 0;
pub const PARAMETER_TYPE_STRING: u32 = 2;
pub const PARAMETER_TYPE_NUMERICAL: u32 = 0;
pub const USB_BLUETOOTH_HCI_NONE: u32 = 0;
pub const USB_BLUETOOTH_HCI_CMD: u32 = 1;
pub const USB_BLUETOOTH_HCI_ACL: u32 = 2;
pub const USB_BLUETOOTH_HCI_SCO: u32 = 3;
pub const USB_BLUETOOTH_HCI_EVT: u32 = 4;
pub const USB_BLUETOOTH_HCI_ISO: u32 = 5;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::core::ffi::c_longlong,
    pub __max_align_ld: f64,
}
pub type wint_t = ::core::ffi::c_int;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
pub type locale_t = *mut __locale_t;
extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_uint);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strerror(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: ::core::ffi::c_int, arg2: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn stpcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strdup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strndup_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const ::core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__signo: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn __locale_mb_cur_max() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_uniform(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::core::ffi::c_void, arg2: usize);
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoff(__nptr: *const ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _atoi_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _atol_r(arg1: *mut _reent, __nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(arg1: ::core::ffi::c_uint, arg2: ::core::ffi::c_uint)
        -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn getenv(__string: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _getenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _findenv_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: ::core::ffi::c_uint) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn mblen(arg1: *const ::core::ffi::c_char, arg2: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mblen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mbtowc_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _wctomb_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: wchar_t,
        arg4: *mut _mbstate_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn _mbstowcs_r(
        arg1: *mut _reent,
        arg2: *mut wchar_t,
        arg3: *const ::core::ffi::c_char,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn _wcstombs_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const wchar_t,
        arg4: usize,
        arg5: *mut _mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(arg1: *mut ::core::ffi::c_char, arg2: ::core::ffi::c_int)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkdtemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _mkostemp_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkostemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mkstemps_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _mktemp_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        _compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realloc(
        arg1: *mut ::core::ffi::c_void,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocarray(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn reallocf(arg1: *mut ::core::ffi::c_void, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realpath(
        path: *const ::core::ffi::c_char,
        resolved_path: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rpmatch(response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn strtod(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f64;
}
extern "C" {
    pub fn _strtod_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(__n: *const ::core::ffi::c_char, __end_PTR: *mut *mut ::core::ffi::c_char)
        -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _strtol_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn _strtoul_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn system(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn a64l(__input: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn l64a(__input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _l64a_r(arg1: *mut _reent, __input: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(arg1: ::core::ffi::c_int, arg2: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putenv_r(arg1: *mut _reent, __string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _reallocf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn setenv(
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _setenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn itoa(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn utoa(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn _drand48_r(arg1: *mut _reent) -> f64;
}
extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn _erand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _jrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn _lcong48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _lrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _mrand48_r(arg1: *mut _reent) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _nrand48_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn _seed48_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
extern "C" {
    pub fn _srand48_r(arg1: *mut _reent, arg2: ::core::ffi::c_long);
}
extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn setstate(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _atoll_r(
        arg1: *mut _reent,
        __nptr: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn _strtoll_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_r(
        arg1: *mut _reent,
        __n: *const ::core::ffi::c_char,
        __end_PTR: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn cfree(arg1: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn unsetenv(__string: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _unsetenv_r(
        arg1: *mut _reent,
        __string: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn posix_memalign(
        arg1: *mut *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dtoa_r(
        arg1: *mut _reent,
        arg2: f64,
        arg3: ::core::ffi::c_int,
        arg4: ::core::ffi::c_int,
        arg5: *mut ::core::ffi::c_int,
        arg6: *mut ::core::ffi::c_int,
        arg7: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _malloc_r(arg1: *mut _reent, arg2: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _calloc_r(arg1: *mut _reent, arg2: usize, arg3: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _free_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn _realloc_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn _mstats_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn _system_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __eprintf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
        arg4: *const ::core::ffi::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}__bsd_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __thunk: *mut ::core::ffi::c_void,
        _compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn _strtold_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtold(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn aligned_alloc(
        arg1: ::core::ffi::c_uint,
        arg2: ::core::ffi::c_uint,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_setup_packet {
    #[doc = " Request type. Bits 0:4 determine recipient, see\n \\ref usb_request_recipient. Bits 5:6 determine type, see\n \\ref usb_request_type. Bit 7 determines data transfer direction, see\n \\ref usb_endpoint_direction."]
    pub bmRequestType: u8,
    #[doc = " Request. If the type bits of bmRequestType are equal to\n \\ref usb_request_type::LIBUSB_REQUEST_TYPE_STANDARD\n \"USB_REQUEST_TYPE_STANDARD\" then this field refers to\n \\ref usb_standard_request. For other cases, use of this field is\n application-specific."]
    pub bRequest: u8,
    #[doc = " Value. Varies according to request"]
    pub wValue: u16,
    #[doc = " Index. Varies according to request, typically used to pass an index\n or offset"]
    pub wIndex: u16,
    #[doc = " Number of bytes to transfer"]
    pub wLength: u16,
}
#[doc = " Standard Device Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_device_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUSB: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize0: u8,
    pub idVendor: u16,
    pub idProduct: u16,
    pub bcdDevice: u16,
    pub iManufacturer: u8,
    pub iProduct: u8,
    pub iSerialNumber: u8,
    pub bNumConfigurations: u8,
}
#[doc = " Standard Configuration Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_configuration_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumInterfaces: u8,
    pub bConfigurationValue: u8,
    pub iConfiguration: u8,
    pub bmAttributes: u8,
    pub bMaxPower: u8,
}
#[doc = " Standard Interface Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_interface_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bInterfaceNumber: u8,
    pub bAlternateSetting: u8,
    pub bNumEndpoints: u8,
    pub bInterfaceClass: u8,
    pub bInterfaceSubClass: u8,
    pub bInterfaceProtocol: u8,
    pub iInterface: u8,
}
#[doc = " Standard Endpoint Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_endpoint_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
}
#[doc = " Unicode (UTF16LE) String Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_string_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bString: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_interface_association_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bFirstInterface: u8,
    pub bInterfaceCount: u8,
    pub bFunctionClass: u8,
    pub bFunctionSubClass: u8,
    pub bFunctionProtocol: u8,
    pub iFunction: u8,
}
#[doc = " USB device_qualifier descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_device_qualifier_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdUSB: u16,
    pub bDeviceClass: u8,
    pub bDeviceSubClass: u8,
    pub bDeviceProtocol: u8,
    pub bMaxPacketSize: u8,
    pub bNumConfigurations: u8,
    pub bReserved: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv1_string_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bString: [u8; 14usize],
    pub bMS_VendorCode: u8,
    pub bPad: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv1_compat_id_header_descriptor {
    pub dwLength: u32,
    pub bcdVersion: u16,
    pub wIndex: u16,
    pub bCount: u8,
    pub reserved: [u8; 7usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv1_comp_id_function_descriptor {
    pub bFirstInterfaceNumber: u8,
    pub reserved1: u8,
    pub compatibleID: [u8; 8usize],
    pub subCompatibleID: [u8; 8usize],
    pub reserved2: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_msosv1_descriptor {
    pub string: *const u8,
    pub vendor_code: u8,
    pub compat_id: *const u8,
    pub comp_id_property: *mut *const u8,
}
impl Default for usb_msosv1_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv2_header_descriptor {
    pub dwLength: u32,
    pub bcdVersion: u16,
    pub wIndex: u16,
    pub bCount: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv2_set_header_descriptor {
    pub wLength: u16,
    pub wDescriptorType: u16,
    pub dwWindowsVersion: u32,
    pub wDescriptorSetTotalLength: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv2_comp_id_descriptor {
    pub wLength: u16,
    pub wDescriptorType: u16,
    pub compatibleID: [u8; 8usize],
    pub subCompatibleID: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_msosv2_property_descriptor {
    pub wLength: u16,
    pub wDescriptorType: u16,
    pub dwPropertyDataType: u32,
    pub wPropertyNameLength: u16,
    pub bPropertyName: *const ::core::ffi::c_char,
    pub dwPropertyDataLength: u32,
    pub bPropertyData: *const ::core::ffi::c_char,
}
impl Default for usb_msosv2_property_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_msosv2_subset_function_descriptor {
    pub wLength: u16,
    pub wDescriptorType: u16,
    pub bFirstInterface: u8,
    pub bReserved: u8,
    pub wSubsetLength: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_msosv2_descriptor {
    pub compat_id: *const u8,
    pub compat_id_len: u16,
    pub vendor_code: u8,
}
impl Default for usb_msosv2_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub wTotalLength: u16,
    pub bNumDeviceCaps: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_platform_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub bReserved: u8,
    pub PlatformCapabilityUUID: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_msosv2_descriptor {
    pub dwWindowsVersion: u32,
    pub wMSOSDescriptorSetTotalLength: u16,
    pub bVendorCode: u8,
    pub bAltEnumCode: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_webusb_descriptor {
    pub bcdVersion: u16,
    pub bVendorCode: u8,
    pub iLandingPage: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_extension_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
    pub bmAttributes: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_platform_msosv2_descriptor {
    pub platform_msos: usb_bos_capability_platform_descriptor,
    pub data_msosv2: usb_bos_capability_msosv2_descriptor,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_bos_capability_platform_webusb_descriptor {
    pub platform_webusb: usb_bos_capability_platform_descriptor,
    pub data_webusb: usb_bos_capability_webusb_descriptor,
}
#[repr(C, packed)]
pub struct usb_webusb_url_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bScheme: u8,
    pub URL: __IncompleteArrayField<::core::ffi::c_char>,
}
impl Default for usb_webusb_url_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_webusb_url_ex_descriptor {
    pub vendor_code: u8,
    pub string: *const u8,
    pub string_len: u32,
}
impl Default for usb_webusb_url_ex_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_bos_descriptor {
    pub string: *const u8,
    pub string_len: u32,
}
impl Default for usb_bos_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_device_capability_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDevCapabilityType: u8,
}
#[doc = " USB descriptor header"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_desc_header {
    #[doc = "< descriptor length"]
    pub bLength: u8,
    #[doc = "< descriptor type"]
    pub bDescriptorType: u8,
}
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut usb_slist_node,
}
impl Default for usb_slist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Single List structure"]
pub type usb_slist_t = usb_slist_node;
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_dlist_node {
    #[doc = "< point to next node."]
    pub next: *mut usb_dlist_node,
    #[doc = "< point to prev node."]
    pub prev: *mut usb_dlist_node,
}
impl Default for usb_dlist_node {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Double List structure"]
pub type usb_dlist_t = usb_dlist_node;
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::core::ffi::c_long,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::core::ffi::c_char,
        _new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn usb_assert(filename: *const ::core::ffi::c_char, linenum: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief init device controller registers.\n @return On success will return 0, and others indicate fail."]
    pub fn usb_dc_init(busid: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief deinit device controller registers.\n @return On success will return 0, and others indicate fail."]
    pub fn usb_dc_deinit(busid: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set USB device address\n\n @param[in] addr Device address\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_set_address(busid: u8, addr: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get USB device speed\n\n @param[in] busid bus index\n\n @return port speed, USB_SPEED_LOW or USB_SPEED_FULL or USB_SPEED_HIGH"]
    pub fn usbd_get_port_speed(busid: u8) -> u8;
}
extern "C" {
    #[doc = " @brief configure and enable endpoint.\n\n @param [in]  ep_cfg Endpoint config.\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_ep_open(busid: u8, ep: *const usb_endpoint_descriptor) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Disable the selected endpoint\n\n @param[in] ep Endpoint address\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_ep_close(busid: u8, ep: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Set stall condition for the selected endpoint\n\n @param[in] ep Endpoint address\n\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_ep_set_stall(busid: u8, ep: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Clear stall condition for the selected endpoint\n\n @param[in] ep Endpoint address corresponding to the one\n               listed in the device configuration table\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_ep_clear_stall(busid: u8, ep: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Check if the selected endpoint is stalled\n\n @param[in]  ep       Endpoint address\n\n @param[out] stalled  Endpoint stall status\n\n @return On success will return 0, and others indicate fail."]
    pub fn usbd_ep_is_stalled(busid: u8, ep: u8, stalled: *mut u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Setup in ep transfer setting and start transfer.\n\n This function is asynchronous.\n This function is similar to uart with tx dma.\n\n This function is called to write data to the specified endpoint. The\n supplied usbd_endpoint_callback function will be called when data is transmitted\n out.\n\n @param[in]  ep        Endpoint address corresponding to the one\n                       listed in the device configuration table\n @param[in]  data      Pointer to data to write\n @param[in]  data_len  Length of the data requested to write. This may\n                       be zero for a zero length status packet.\n @return 0 on success, negative errno code on fail."]
    pub fn usbd_ep_start_write(
        busid: u8,
        ep: u8,
        data: *const u8,
        data_len: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Setup out ep transfer setting and start transfer.\n\n This function is asynchronous.\n This function is similar to uart with rx dma.\n\n This function is called to read data to the specified endpoint. The\n supplied usbd_endpoint_callback function will be called when data is received\n in.\n\n @param[in]  ep        Endpoint address corresponding to the one\n                       listed in the device configuration table\n @param[in]  data      Pointer to data to read\n @param[in]  data_len  Max length of the data requested to read.\n\n @return 0 on success, negative errno code on fail."]
    pub fn usbd_ep_start_read(
        busid: u8,
        ep: u8,
        data: *mut u8,
        data_len: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Usb connect irq callback."]
    pub fn usbd_event_connect_handler(busid: u8);
}
extern "C" {
    #[doc = " @brief Usb disconnect irq callback."]
    pub fn usbd_event_disconnect_handler(busid: u8);
}
extern "C" {
    #[doc = " @brief Usb resume irq callback."]
    pub fn usbd_event_resume_handler(busid: u8);
}
extern "C" {
    #[doc = " @brief Usb suspend irq callback."]
    pub fn usbd_event_suspend_handler(busid: u8);
}
extern "C" {
    #[doc = " @brief Usb reset irq callback."]
    pub fn usbd_event_reset_handler(busid: u8);
}
extern "C" {
    #[doc = " @brief Usb setup packet recv irq callback.\n @param[in]  psetup  setup packet."]
    pub fn usbd_event_ep0_setup_complete_handler(busid: u8, psetup: *mut u8);
}
extern "C" {
    #[doc = " @brief In ep transfer complete irq callback.\n @param[in]  ep        Endpoint address corresponding to the one\n                       listed in the device configuration table\n @param[in]  nbytes    How many nbytes have transferred."]
    pub fn usbd_event_ep_in_complete_handler(busid: u8, ep: u8, nbytes: u32);
}
extern "C" {
    #[doc = " @brief Out ep transfer complete irq callback.\n @param[in]  ep        Endpoint address corresponding to the one\n                       listed in the device configuration table\n @param[in]  nbytes    How many nbytes have transferred."]
    pub fn usbd_event_ep_out_complete_handler(busid: u8, ep: u8, nbytes: u32);
}
extern "C" {
    pub fn usbd_send_remote_wakeup(busid: u8);
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum usbd_event_type {
    USBD_EVENT_ERROR = 0,
    #[doc = " USB error reported by the controller"]
    USBD_EVENT_RESET = 1,
    #[doc = " USB reset"]
    USBD_EVENT_SOF = 2,
    #[doc = " Start of Frame received"]
    USBD_EVENT_CONNECTED = 3,
    #[doc = " USB connected"]
    USBD_EVENT_DISCONNECTED = 4,
    #[doc = " USB disconnected"]
    USBD_EVENT_SUSPEND = 5,
    #[doc = " USB connection suspended by the HOST"]
    USBD_EVENT_RESUME = 6,
    #[doc = " USB connection resumed by the HOST"]
    USBD_EVENT_CONFIGURED = 7,
    #[doc = " USB configuration done"]
    USBD_EVENT_SET_INTERFACE = 8,
    #[doc = " USB interface selected"]
    USBD_EVENT_SET_REMOTE_WAKEUP = 9,
    #[doc = " USB set remote wakeup"]
    USBD_EVENT_CLR_REMOTE_WAKEUP = 10,
    #[doc = " USB clear remote wakeup"]
    USBD_EVENT_INIT = 11,
    #[doc = " USB init done when call usbd_initialize"]
    USBD_EVENT_DEINIT = 12,
    #[doc = " USB deinit done when call usbd_deinitialize"]
    USBD_EVENT_UNKNOWN = 13,
}
pub type usbd_request_handler = ::core::option::Option<
    unsafe extern "C" fn(
        busid: u8,
        setup: *mut usb_setup_packet,
        data: *mut *mut u8,
        len: *mut u32,
    ) -> ::core::ffi::c_int,
>;
pub type usbd_endpoint_callback =
    ::core::option::Option<unsafe extern "C" fn(busid: u8, ep: u8, nbytes: u32)>;
pub type usbd_notify_handler = ::core::option::Option<
    unsafe extern "C" fn(busid: u8, event: u8, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbd_endpoint {
    pub ep_addr: u8,
    pub ep_cb: usbd_endpoint_callback,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_interface {
    pub class_interface_handler: usbd_request_handler,
    pub class_endpoint_handler: usbd_request_handler,
    pub vendor_handler: usbd_request_handler,
    pub notify_handler: usbd_notify_handler,
    pub hid_report_descriptor: *const u8,
    pub hid_report_descriptor_len: u32,
    pub intf_num: u8,
}
impl Default for usbd_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_descriptor {
    pub device_descriptor_callback:
        ::core::option::Option<unsafe extern "C" fn(speed: u8) -> *const u8>,
    pub config_descriptor_callback:
        ::core::option::Option<unsafe extern "C" fn(speed: u8) -> *const u8>,
    pub device_quality_descriptor_callback:
        ::core::option::Option<unsafe extern "C" fn(speed: u8) -> *const u8>,
    pub other_speed_descriptor_callback:
        ::core::option::Option<unsafe extern "C" fn(speed: u8) -> *const u8>,
    pub string_descriptor_callback: ::core::option::Option<
        unsafe extern "C" fn(speed: u8, index: u8) -> *const ::core::ffi::c_char,
    >,
    pub msosv1_descriptor: *const usb_msosv1_descriptor,
    pub msosv2_descriptor: *const usb_msosv2_descriptor,
    pub webusb_url_descriptor: *const usb_webusb_url_ex_descriptor,
    pub bos_descriptor: *const usb_bos_descriptor,
}
impl Default for usb_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbd_bus {
    pub busid: u8,
    pub reg_base: u32,
}
extern "C" {
    pub static mut g_usbdev_bus: [usbd_bus; 0usize];
}
extern "C" {
    pub fn usbd_desc_register(busid: u8, desc: *const u8);
}
extern "C" {
    pub fn usbd_msosv1_desc_register(busid: u8, desc: *mut usb_msosv1_descriptor);
}
extern "C" {
    pub fn usbd_msosv2_desc_register(busid: u8, desc: *mut usb_msosv2_descriptor);
}
extern "C" {
    pub fn usbd_bos_desc_register(busid: u8, desc: *mut usb_bos_descriptor);
}
extern "C" {
    pub fn usbd_add_interface(busid: u8, intf: *mut usbd_interface);
}
extern "C" {
    pub fn usbd_add_endpoint(busid: u8, ep: *mut usbd_endpoint);
}
extern "C" {
    pub fn usbd_get_ep_mps(busid: u8, ep: u8) -> u16;
}
extern "C" {
    pub fn usbd_get_ep_mult(busid: u8, ep: u8) -> u8;
}
extern "C" {
    pub fn usb_device_is_configured(busid: u8) -> bool;
}
extern "C" {
    pub fn usbd_initialize(
        busid: u8,
        reg_base: u32,
        event_handler: ::core::option::Option<unsafe extern "C" fn(busid: u8, event: u8)>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbd_deinitialize(busid: u8) -> ::core::ffi::c_int;
}
pub type usbh_complete_callback_t = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void, nbytes: ::core::ffi::c_int),
>;
#[doc = " @brief USB Iso Configuration.\n\n Structure containing the USB Iso configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_iso_frame_packet {
    pub transfer_buffer: *mut u8,
    pub transfer_buffer_length: u32,
    pub actual_length: u32,
    pub errorcode: ::core::ffi::c_int,
}
impl Default for usbh_iso_frame_packet {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief USB Urb Configuration.\n\n Structure containing the USB Urb configuration."]
#[repr(C)]
#[derive(Debug)]
pub struct usbh_urb {
    pub list: usb_slist_t,
    pub hcpriv: *mut ::core::ffi::c_void,
    pub hport: *mut usbh_hubport,
    pub ep: *mut usb_endpoint_descriptor,
    pub data_toggle: u8,
    pub interval: u8,
    pub setup: *mut usb_setup_packet,
    pub transfer_buffer: *mut u8,
    pub transfer_buffer_length: u32,
    pub transfer_flags: ::core::ffi::c_int,
    pub actual_length: u32,
    pub timeout: u32,
    pub errorcode: ::core::ffi::c_int,
    pub num_of_iso_packets: u32,
    pub start_frame: u32,
    pub complete: usbh_complete_callback_t,
    pub arg: *mut ::core::ffi::c_void,
    pub iso_packet: __IncompleteArrayField<usbh_iso_frame_packet>,
}
impl Default for usbh_urb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief usb host controller hardware init.\n\n @return On success will return 0, and others indicate fail."]
    pub fn usb_hc_init(bus: *mut usbh_bus) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief usb host controller hardware deinit.\n\n @return On success will return 0, and others indicate fail."]
    pub fn usb_hc_deinit(bus: *mut usbh_bus) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get frame number.\n\n @return frame number."]
    pub fn usbh_get_frame_number(bus: *mut usbh_bus) -> u16;
}
extern "C" {
    #[doc = " @brief control roothub.\n\n @param setup setup request buffer.\n @param buf buf for reading response or write data.\n @return On success will return 0, and others indicate fail."]
    pub fn usbh_roothub_control(
        bus: *mut usbh_bus,
        setup: *mut usb_setup_packet,
        buf: *mut u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Submit a usb transfer request to an endpoint.\n\n If timeout is not zero, this function will be in poll transfer mode,\n otherwise will be in async transfer mode.\n\n @param urb Usb request block.\n @return  On success will return 0, and others indicate fail."]
    pub fn usbh_submit_urb(urb: *mut usbh_urb) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Cancel a transfer request.\n\n This function will call When calls usbh_submit_urb and return -USB_ERR_TIMEOUT or -USB_ERR_SHUTDOWN.\n\n @param urb Usb request block.\n @return  On success will return 0, and others indicate fail."]
    pub fn usbh_kill_urb(urb: *mut usbh_urb) -> ::core::ffi::c_int;
}
pub type usb_osal_thread_t = *mut ::core::ffi::c_void;
pub type usb_osal_sem_t = *mut ::core::ffi::c_void;
pub type usb_osal_mutex_t = *mut ::core::ffi::c_void;
pub type usb_osal_mq_t = *mut ::core::ffi::c_void;
pub type usb_thread_entry_t =
    ::core::option::Option<unsafe extern "C" fn(argument: *mut ::core::ffi::c_void)>;
pub type usb_timer_handler_t =
    ::core::option::Option<unsafe extern "C" fn(argument: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usb_osal_timer {
    pub handler: usb_timer_handler_t,
    pub argument: *mut ::core::ffi::c_void,
    pub is_period: bool,
    pub ticks: u32,
    pub timer: *mut ::core::ffi::c_void,
}
impl Default for usb_osal_timer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usb_osal_thread_create(
        name: *const ::core::ffi::c_char,
        stack_size: u32,
        prio: u32,
        entry: usb_thread_entry_t,
        args: *mut ::core::ffi::c_void,
    ) -> usb_osal_thread_t;
}
extern "C" {
    pub fn usb_osal_thread_delete(thread: usb_osal_thread_t);
}
extern "C" {
    pub fn usb_osal_sem_create(initial_count: u32) -> usb_osal_sem_t;
}
extern "C" {
    pub fn usb_osal_sem_delete(sem: usb_osal_sem_t);
}
extern "C" {
    pub fn usb_osal_sem_take(sem: usb_osal_sem_t, timeout: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_sem_give(sem: usb_osal_sem_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_sem_reset(sem: usb_osal_sem_t);
}
extern "C" {
    pub fn usb_osal_mutex_create() -> usb_osal_mutex_t;
}
extern "C" {
    pub fn usb_osal_mutex_delete(mutex: usb_osal_mutex_t);
}
extern "C" {
    pub fn usb_osal_mutex_take(mutex: usb_osal_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_mutex_give(mutex: usb_osal_mutex_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_mq_create(max_msgs: u32) -> usb_osal_mq_t;
}
extern "C" {
    pub fn usb_osal_mq_delete(mq: usb_osal_mq_t);
}
extern "C" {
    pub fn usb_osal_mq_send(mq: usb_osal_mq_t, addr: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_mq_recv(
        mq: usb_osal_mq_t,
        addr: *mut usize,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usb_osal_timer_create(
        name: *const ::core::ffi::c_char,
        timeout_ms: u32,
        handler: usb_timer_handler_t,
        argument: *mut ::core::ffi::c_void,
        is_period: bool,
    ) -> *mut usb_osal_timer;
}
extern "C" {
    pub fn usb_osal_timer_delete(timer: *mut usb_osal_timer);
}
extern "C" {
    pub fn usb_osal_timer_start(timer: *mut usb_osal_timer);
}
extern "C" {
    pub fn usb_osal_timer_stop(timer: *mut usb_osal_timer);
}
extern "C" {
    pub fn usb_osal_enter_critical_section() -> usize;
}
extern "C" {
    pub fn usb_osal_leave_critical_section(flag: usize);
}
extern "C" {
    pub fn usb_osal_msleep(delay: u32);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hub_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bNbrPorts: u8,
    pub wHubCharacteristics: u16,
    pub bPwrOn2PwrGood: u8,
    pub bHubContrCurrent: u8,
    pub DeviceRemovable: u8,
    pub PortPwrCtrlMask: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hub_ss_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bNbrPorts: u8,
    pub wHubCharacteristics: u16,
    pub bPwrOn2PwrGood: u8,
    pub bHubContrCurrent: u8,
    pub bHubHdrDecLat: u8,
    pub wHubDelay: u16,
    pub DeviceRemovable: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hub_status {
    pub wPortStatus: u16,
    pub wPortChange: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hub_port_status {
    pub wPortStatus: u16,
    pub wPortChange: u16,
}
extern "C" {
    pub fn usbh_hub_set_feature(hub: *mut usbh_hub, port: u8, feature: u8) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hub_clear_feature(hub: *mut usbh_hub, port: u8, feature: u8) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hub_thread_wakeup(hub: *mut usbh_hub);
}
extern "C" {
    pub fn usbh_hub_initialize(bus: *mut usbh_bus) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hub_deinitialize(bus: *mut usbh_bus) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_class_info {
    pub match_flags: u8,
    pub class: u8,
    pub subclass: u8,
    pub protocol: u8,
    pub id_table: *const [::core::ffi::c_ushort; 2usize],
    pub class_driver: *const usbh_class_driver,
}
impl Default for usbh_class_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_class_driver {
    pub driver_name: *const ::core::ffi::c_char,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(hport: *mut usbh_hubport, intf: u8) -> ::core::ffi::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(hport: *mut usbh_hubport, intf: u8) -> ::core::ffi::c_int,
    >,
}
impl Default for usbh_class_driver {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_endpoint {
    pub ep_desc: usb_endpoint_descriptor,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_interface_altsetting {
    pub intf_desc: usb_interface_descriptor,
    pub ep: [usbh_endpoint; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_interface {
    pub devname: [::core::ffi::c_char; 16usize],
    pub class_driver: *mut usbh_class_driver,
    pub priv_: *mut ::core::ffi::c_void,
    pub altsetting: [usbh_interface_altsetting; 8usize],
    pub altsetting_num: u8,
}
impl Default for usbh_interface {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_configuration {
    pub config_desc: usb_configuration_descriptor,
    pub intf: [usbh_interface; 8usize],
}
impl Default for usbh_configuration {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_hubport {
    pub connected: bool,
    pub port: u8,
    pub dev_addr: u8,
    pub speed: u8,
    pub depth: u8,
    pub route: u8,
    pub slot_id: u8,
    pub device_desc: usb_device_descriptor,
    pub config: usbh_configuration,
    pub iManufacturer: *const ::core::ffi::c_char,
    pub iProduct: *const ::core::ffi::c_char,
    pub iSerialNumber: *const ::core::ffi::c_char,
    pub raw_config_desc: *mut u8,
    pub setup: *mut usb_setup_packet,
    pub parent: *mut usbh_hub,
    pub self_: *mut usbh_hub,
    pub bus: *mut usbh_bus,
    pub ep0: usb_endpoint_descriptor,
    pub ep0_urb: usbh_urb,
    pub mutex: usb_osal_mutex_t,
}
impl Default for usbh_hubport {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_hub {
    pub connected: bool,
    pub is_roothub: bool,
    pub index: u8,
    pub hub_addr: u8,
    pub speed: u8,
    pub nports: u8,
    pub powerdelay: u8,
    pub tt_think: u8,
    pub ismtt: bool,
    pub hub_desc: usb_hub_descriptor,
    pub hub_ss_desc: usb_hub_ss_descriptor,
    pub child: [usbh_hubport; 4usize],
    pub parent: *mut usbh_hubport,
    pub bus: *mut usbh_bus,
    pub intin: *mut usb_endpoint_descriptor,
    pub intin_urb: usbh_urb,
    pub int_buffer: *mut u8,
    pub int_timer: *mut usb_osal_timer,
}
impl Default for usbh_hub {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_devaddr_map {
    #[doc = " alloctab[0]:addr from 0~31\n alloctab[1]:addr from 32~63\n alloctab[2]:addr from 64~95\n alloctab[3]:addr from 96~127\n"]
    pub next: u8,
    pub alloctab: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_hcd {
    pub reg_base: u32,
    pub hcd_id: u8,
    pub roothub_intbuf: [u8; 2usize],
    pub roothub: usbh_hub,
}
impl Default for usbh_hcd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_bus {
    pub list: usb_slist_t,
    pub busid: u8,
    pub hcd: usbh_hcd,
    pub devgen: usbh_devaddr_map,
    pub hub_thread: usb_osal_thread_t,
    pub hub_mq: usb_osal_mq_t,
}
impl Default for usbh_bus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut g_usbhost_bus: [usbh_bus; 0usize];
}
extern "C" {
    #[doc = " @brief Submit an control transfer to an endpoint.\n This is a blocking method; this method will not return until the transfer has completed.\n Default timeout is 500ms.\n\n @param pipe The control endpoint to send/receive the control request.\n @param setup Setup packet to be sent.\n @param buffer buffer used for sending the request and for returning any responses.\n @return On success will return 0, and others indicate fail."]
    pub fn usbh_control_transfer(
        hport: *mut usbh_hubport,
        setup: *mut usb_setup_packet,
        buffer: *mut u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Retrieves a USB string descriptor from a specific hub port.\n\n This function is responsible for retrieving the USB string descriptor\n with the specified index from the USB device connected to the given hub port.\n The retrieved descriptor is stored in the output buffer provided.\n\n @param hport Pointer to the USB hub port structure.\n @param index Index of the string descriptor to retrieve.\n @param output Pointer to the buffer where the retrieved descriptor will be stored.\n @return On success will return 0, and others indicate fail."]
    pub fn usbh_get_string_desc(
        hport: *mut usbh_hubport,
        index: u8,
        output: *mut u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Sets the alternate setting for a USB interface on a specific hub port.\n\n This function is responsible for setting the alternate setting of the\n specified USB interface on the USB device connected to the given hub port.\n The interface and alternate setting are identified by the respective parameters.\n\n @param hport Pointer to the USB hub port structure.\n @param intf Interface number to set the alternate setting for.\n @param altsetting Alternate setting value to set for the interface.\n @return On success will return 0, and others indicate fail."]
    pub fn usbh_set_interface(
        hport: *mut usbh_hubport,
        intf: u8,
        altsetting: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_initialize(busid: u8, reg_base: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_deinitialize(busid: u8) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_find_class_instance(
        devname: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn lsusb(
        argc: ::core::ffi::c_int,
        argv: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
#[repr(C, packed)]
pub struct audio_cs_if_ac_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bcdADC: u16,
    pub wTotalLength: u16,
    pub bInCollection: u8,
    pub baInterfaceNr: __IncompleteArrayField<u8>,
}
impl Default for audio_cs_if_ac_header_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_if_ac_input_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub bNrChannels: u8,
    pub wChannelConfig: u16,
    pub iChannelNames: u8,
    pub iTerminal: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_if_ac_output_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub bSourceID: u8,
    pub iTerminal: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_if_ac_feature_unit_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bUnitID: u8,
    pub bSourceID: u8,
    pub bControlSize: u8,
    pub bmaControls: [u8; 1usize],
    pub iFeature: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_if_as_general_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalLink: u8,
    pub bDelay: u8,
    pub wFormatTag: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_if_as_format_type_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bFormatType: u8,
    pub bNrChannels: u8,
    pub bSubframeSize: u8,
    pub bBitResolution: u8,
    pub bSamFreqType: u8,
    pub tSamFreq: [u8; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_ep_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bEndpointAddress: u8,
    pub bmAttributes: u8,
    pub wMaxPacketSize: u16,
    pub bInterval: u8,
    pub bRefresh: u8,
    pub bSynchAddress: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_cs_ep_ep_general_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmAttributes: u8,
    pub bLockDelayUnits: u8,
    pub wLockDelay: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_channel_cluster_descriptor {
    pub bNrChannels: u8,
    pub bmChannelConfig: u32,
    pub iChannelNames: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bcdADC: u16,
    pub bCategory: u8,
    pub wTotalLength: u16,
    pub bmControls: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_clock_source_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bClockID: u8,
    pub bmAttributes: u8,
    pub bmControls: u8,
    pub bAssocTerminal: u8,
    pub iClockSource: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_clock_selector_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bClockID: u8,
    pub bNrInPins: u8,
    pub baCSourceID: [u8; 1usize],
    pub iClockSelector: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_clock_multiplier_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bClockID: u8,
    pub bCSourceID: u8,
    pub bmControls: u8,
    pub iClockMultiplier: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_input_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub bCSourceID: u8,
    pub bNrChannels: u8,
    pub wChannelConfig: u32,
    pub iChannelNames: u8,
    pub bmControls: u16,
    pub iTerminal: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_output_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub bSourceID: u8,
    pub bCSourceID: u8,
    pub bmControls: u16,
    pub iTerminal: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_ac_feature_unit_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bUnitID: u8,
    pub bSourceID: u8,
    pub bmaControls: [u32; 1usize],
    pub iFeature: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_cs_if_as_general_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bTerminalLink: u8,
    pub bmControls: u8,
    pub bFormatType: u8,
    pub bmFormats: u32,
    pub bNrChannels: u8,
    pub bmChannelConfig: u32,
    pub iChannelNames: u8,
}
#[repr(C, packed)]
pub struct audio_v2_control_range1_param_block {
    pub wNumSubRanges: u16,
    pub subrange: __IncompleteArrayField<audio_v2_control_range1_param_block__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_control_range1_param_block__bindgen_ty_1 {
    pub bMin: u8,
    pub bMax: u8,
    pub bRes: u8,
}
impl Default for audio_v2_control_range1_param_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct audio_v2_control_range2_param_block {
    pub wNumSubRanges: u16,
    pub subrange: __IncompleteArrayField<audio_v2_control_range2_param_block__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_control_range2_param_block__bindgen_ty_1 {
    pub wMin: u16,
    pub wMax: u16,
    pub wRes: u16,
}
impl Default for audio_v2_control_range2_param_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct audio_v2_control_range3_param_block {
    pub wNumSubRanges: u16,
    pub subrange: __IncompleteArrayField<audio_v2_control_range3_param_block__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_v2_control_range3_param_block__bindgen_ty_1 {
    pub dMin: u32,
    pub dMax: u32,
    pub dRes: u32,
}
impl Default for audio_v2_control_range3_param_block {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct audio_entity_info {
    pub bDescriptorSubtype: u8,
    pub bEntityId: u8,
    pub ep: u8,
}
extern "C" {
    pub fn usbd_audio_init_intf(
        busid: u8,
        intf: *mut usbd_interface,
        uac_version: u16,
        table: *mut audio_entity_info,
        num: u8,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_audio_open(busid: u8, intf: u8);
}
extern "C" {
    pub fn usbd_audio_close(busid: u8, intf: u8);
}
extern "C" {
    pub fn usbd_audio_set_volume(busid: u8, ep: u8, ch: u8, volume: ::core::ffi::c_int);
}
extern "C" {
    pub fn usbd_audio_get_volume(busid: u8, ep: u8, ch: u8) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbd_audio_set_mute(busid: u8, ep: u8, ch: u8, mute: bool);
}
extern "C" {
    pub fn usbd_audio_get_mute(busid: u8, ep: u8, ch: u8) -> bool;
}
extern "C" {
    pub fn usbd_audio_set_sampling_freq(busid: u8, ep: u8, sampling_freq: u32);
}
extern "C" {
    pub fn usbd_audio_get_sampling_freq(busid: u8, ep: u8) -> u32;
}
extern "C" {
    pub fn usbd_audio_get_sampling_freq_table(busid: u8, ep: u8, sampling_freq_table: *mut *mut u8);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_audio_format_type {
    pub channels: u8,
    pub format_type: u8,
    pub bitresolution: u8,
    pub sampfreq_num: u8,
    pub sampfreq: [u32; 3usize],
}
#[doc = " bSourceID in feature_unit = input_terminal_id\n bSourceID in output_terminal = feature_unit_id\n terminal_link_id = input_terminal_id or output_terminal_id (if input_terminal_type or output_terminal_type is 0x0101)\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_audio_module {
    pub name: *const ::core::ffi::c_char,
    pub data_intf: u8,
    pub input_terminal_id: u8,
    pub input_terminal_type: u16,
    pub input_channel_config: u16,
    pub output_terminal_id: u8,
    pub output_terminal_type: u16,
    pub feature_unit_id: u8,
    pub feature_unit_controlsize: u8,
    pub feature_unit_controls: [u8; 8usize],
    pub terminal_link_id: u8,
    pub altsetting: [usbh_audio_format_type; 8usize],
}
impl Default for usbh_audio_module {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_audio {
    pub hport: *mut usbh_hubport,
    pub isoin: *mut usb_endpoint_descriptor,
    pub isoout: *mut usb_endpoint_descriptor,
    pub ctrl_intf: u8,
    pub minor: u8,
    pub isoin_mps: u16,
    pub isoout_mps: u16,
    pub is_opened: bool,
    pub bcdADC: u16,
    pub bInCollection: u8,
    pub num_of_intf_altsettings: u8,
    pub module: [usbh_audio_module; 2usize],
    pub module_num: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_audio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_audio_open(
        audio_class: *mut usbh_audio,
        name: *const ::core::ffi::c_char,
        samp_freq: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_audio_close(
        audio_class: *mut usbh_audio,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_audio_set_volume(
        audio_class: *mut usbh_audio,
        name: *const ::core::ffi::c_char,
        ch: u8,
        volume: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_audio_set_mute(
        audio_class: *mut usbh_audio,
        name: *const ::core::ffi::c_char,
        ch: u8,
        mute: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_audio_run(audio_class: *mut usbh_audio);
}
extern "C" {
    pub fn usbh_audio_stop(audio_class: *mut usbh_audio);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_header_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bcdCDC: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_call_management_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
    pub bDataInterface: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_abstract_control_management_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bmCapabilities: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_union_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bMasterInterface: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_union_1slave_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub bControlInterface: u8,
    pub bSubordinateInterface0: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_line_coding {
    pub dwDTERate: u32,
    pub bCharFormat: u8,
    pub bParityType: u8,
    pub bDataBits: u8,
}
#[doc = " Data structure for the notification about SerialState"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_acm_notification {
    pub bmRequestType: u8,
    pub bNotificationType: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub data: u16,
}
#[doc = " Ethernet Networking Functional Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_eth_descriptor {
    pub bFunctionLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubtype: u8,
    pub iMACAddress: u8,
    pub bmEthernetStatistics: u32,
    pub wMaxSegmentSize: u16,
    pub wNumberMCFilters: u16,
    pub bNumberPowerFilters: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_eth_notification {
    pub bmRequestType: u8,
    pub bNotificationType: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub data: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_ncm_ntb_parameters {
    pub wLength: u16,
    pub bmNtbFormatsSupported: u16,
    pub dwNtbInMaxSize: u32,
    pub wNdbInDivisor: u16,
    pub wNdbInPayloadRemainder: u16,
    pub wNdbInAlignment: u16,
    pub wReserved: u16,
    pub dwNtbOutMaxSize: u32,
    pub wNdbOutDivisor: u16,
    pub wNdbOutPayloadRemainder: u16,
    pub wNdbOutAlignment: u16,
    pub wNtbOutMaxDatagrams: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_ncm_nth16 {
    pub dwSignature: u32,
    pub wHeaderLength: u16,
    pub wSequence: u16,
    pub wBlockLength: u16,
    pub wNdpIndex: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cdc_ncm_ndp16_datagram {
    pub wDatagramIndex: u16,
    pub wDatagramLength: u16,
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cdc_ncm_ndp16 {
    pub dwSignature: u32,
    pub wLength: u16,
    pub wNextNdpIndex: u16,
    pub datagram: __IncompleteArrayField<cdc_ncm_ndp16_datagram>,
}
extern "C" {
    pub fn usbd_cdc_acm_init_intf(busid: u8, intf: *mut usbd_interface) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_cdc_acm_set_line_coding(busid: u8, intf: u8, line_coding: *mut cdc_line_coding);
}
extern "C" {
    pub fn usbd_cdc_acm_get_line_coding(busid: u8, intf: u8, line_coding: *mut cdc_line_coding);
}
extern "C" {
    pub fn usbd_cdc_acm_set_dtr(busid: u8, intf: u8, dtr: bool);
}
extern "C" {
    pub fn usbd_cdc_acm_set_rts(busid: u8, intf: u8, rts: bool);
}
extern "C" {
    pub fn usbd_cdc_acm_send_break(busid: u8, intf: u8);
}
extern "C" {
    pub fn usbd_cdc_ecm_init_intf(
        intf: *mut usbd_interface,
        int_ep: u8,
        out_ep: u8,
        in_ep: u8,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_cdc_ecm_set_connect_speed(speed: *mut u32);
}
extern "C" {
    pub fn usbd_cdc_ecm_get_tx_buffer() -> *mut u8;
}
extern "C" {
    pub fn usbd_cdc_ecm_send_done();
}
extern "C" {
    pub fn usbd_cdc_ecm_start_write(buf: *mut u8, len: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbd_cdc_ecm_data_recv_done(buf: *mut u8, len: u32);
}
extern "C" {
    pub fn usbd_cdc_ecm_start_read_next();
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_cdc_acm {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub linecoding: cdc_line_coding,
    pub intf: u8,
    pub minor: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_cdc_acm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_cdc_acm_set_line_coding(
        cdc_acm_class: *mut usbh_cdc_acm,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_acm_get_line_coding(
        cdc_acm_class: *mut usbh_cdc_acm,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_acm_set_line_state(
        cdc_acm_class: *mut usbh_cdc_acm,
        dtr: bool,
        rts: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_acm_bulk_in_transfer(
        cdc_acm_class: *mut usbh_cdc_acm,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_acm_bulk_out_transfer(
        cdc_acm_class: *mut usbh_cdc_acm,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_acm_run(cdc_acm_class: *mut usbh_cdc_acm);
}
extern "C" {
    pub fn usbh_cdc_acm_stop(cdc_acm_class: *mut usbh_cdc_acm);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_cdc_ecm {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub intin: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub intin_urb: usbh_urb,
    pub ctrl_intf: u8,
    pub data_intf: u8,
    pub minor: u8,
    pub mac: [u8; 6usize],
    pub connect_status: bool,
    pub max_segment_size: u16,
    pub speed: [u32; 2usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_cdc_ecm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_cdc_ecm_get_connect_status(cdc_ecm_class: *mut usbh_cdc_ecm) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_ecm_run(cdc_ecm_class: *mut usbh_cdc_ecm);
}
extern "C" {
    pub fn usbh_cdc_ecm_stop(cdc_ecm_class: *mut usbh_cdc_ecm);
}
extern "C" {
    pub fn usbh_cdc_ecm_get_eth_txbuf() -> *mut u8;
}
extern "C" {
    pub fn usbh_cdc_ecm_eth_output(buflen: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_ecm_eth_input(buf: *mut u8, buflen: u32);
}
extern "C" {
    pub fn usbh_cdc_ecm_rx_thread(argument: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_cdc_ncm {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub intin: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub intin_urb: usbh_urb,
    pub ctrl_intf: u8,
    pub data_intf: u8,
    pub minor: u8,
    pub ntb_param: cdc_ncm_ntb_parameters,
    pub bulkin_sequence: u16,
    pub bulkout_sequence: u16,
    pub mac: [u8; 6usize],
    pub connect_status: bool,
    pub max_segment_size: u16,
    pub speed: [u32; 2usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_cdc_ncm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_cdc_ncm_get_connect_status(cdc_ncm_class: *mut usbh_cdc_ncm) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_ncm_run(cdc_ncm_class: *mut usbh_cdc_ncm);
}
extern "C" {
    pub fn usbh_cdc_ncm_stop(cdc_ncm_class: *mut usbh_cdc_ncm);
}
extern "C" {
    pub fn usbh_cdc_ncm_get_eth_txbuf() -> *mut u8;
}
extern "C" {
    pub fn usbh_cdc_ncm_eth_output(buflen: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cdc_ncm_eth_input(buf: *mut u8, buflen: u32);
}
extern "C" {
    pub fn usbh_cdc_ncm_rx_thread(argument: *mut ::core::ffi::c_void);
}
#[doc = " Run-Time Functional Descriptor"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dfu_runtime_descriptor {
    #[doc = "<\\brief Descriptor length in bytes."]
    pub bLength: u8,
    #[doc = "<\\brief DFU functional descriptor type."]
    pub bDescriptorType: u8,
    #[doc = "<\\brief USB DFU capabilities \\ref USB_DFU_CAPAB"]
    pub bmAttributes: u8,
    #[doc = "<\\brief USB DFU detach timeout in ms."]
    pub wDetachTimeout: u16,
    #[doc = "<\\brief USB DFU maximum transfer block size in bytes."]
    pub wTransferSize: u16,
    #[doc = "<\\brief USB DFU version \\ref VERSION_BCD utility macro."]
    pub bcdDFUVersion: u16,
}
#[doc = "\\brief Payload packet to response in DFU_GETSTATUS request"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dfu_info {
    #[doc = "<\\brief An indication of the status resulting from the\n execution of the most recent request."]
    pub bStatus: u8,
    #[doc = "<\\brief Minimum time (LSB) in ms, that the host should wait\n before sending a subsequent DFU_GETSTATUS request."]
    pub bPollTimeout: u8,
    #[doc = "<\\brief Minimum time (MSB) in ms, that the host should wait\n before sending a subsequent DFU_GETSTATUS request."]
    pub wPollTimeout: u16,
    #[doc = "<\\brief An indication of the state that the device is going\n to enter immediately following transmission of this response."]
    pub bState: u8,
    #[doc = "<\\brief Index of the status string descriptor."]
    pub iString: u8,
}
extern "C" {
    pub fn usbd_dfu_init_intf(intf: *mut usbd_interface) -> *mut usbd_interface;
}
extern "C" {
    pub fn dfu_read_flash(src: *mut u8, dest: *mut u8, len: u32) -> *mut u8;
}
extern "C" {
    pub fn dfu_write_flash(src: *mut u8, dest: *mut u8, len: u32) -> u16;
}
extern "C" {
    pub fn dfu_erase_flash(add: u32) -> u16;
}
extern "C" {
    pub fn dfu_leave();
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hid_class_subdescriptor {
    pub bDescriptorType: u8,
    pub wDescriptorLength: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hid_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bcdHID: u16,
    pub bCountryCode: u8,
    pub bNumDescriptors: u8,
    pub subdesc: [usb_hid_class_subdescriptor; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hid_kbd_report {
    pub modifier: u8,
    pub reserved: u8,
    pub key: [u8; 6usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hid_mouse_report {
    pub buttons: u8,
    pub xdisp: u8,
    pub ydisp: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_hid_js_report {
    pub xpos: u8,
    pub ypos: u8,
    pub buttons: u8,
    pub throttle: u8,
}
extern "C" {
    pub fn usbd_hid_init_intf(
        busid: u8,
        intf: *mut usbd_interface,
        desc: *const u8,
        desc_len: u32,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_hid_descriptor_register(busid: u8, intf_num: u8, desc: *const u8);
}
extern "C" {
    pub fn usbd_hid_report_descriptor_register(
        busid: u8,
        intf_num: u8,
        desc: *const u8,
        desc_len: u32,
    );
}
extern "C" {
    pub fn usbd_hid_get_report(
        busid: u8,
        intf: u8,
        report_id: u8,
        report_type: u8,
        data: *mut *mut u8,
        len: *mut u32,
    );
}
extern "C" {
    pub fn usbd_hid_get_idle(busid: u8, intf: u8, report_id: u8) -> u8;
}
extern "C" {
    pub fn usbd_hid_get_protocol(busid: u8, intf: u8) -> u8;
}
extern "C" {
    pub fn usbd_hid_set_report(
        busid: u8,
        intf: u8,
        report_id: u8,
        report_type: u8,
        report: *mut u8,
        report_len: u32,
    );
}
extern "C" {
    pub fn usbd_hid_set_idle(busid: u8, intf: u8, report_id: u8, duration: u8);
}
extern "C" {
    pub fn usbd_hid_set_protocol(busid: u8, intf: u8, protocol: u8);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_hid {
    pub hport: *mut usbh_hubport,
    pub intin: *mut usb_endpoint_descriptor,
    pub intout: *mut usb_endpoint_descriptor,
    pub intin_urb: usbh_urb,
    pub intout_urb: usbh_urb,
    pub report_desc: [u8; 256usize],
    pub intf: u8,
    pub minor: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_hid {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_hid_set_idle(
        hid_class: *mut usbh_hid,
        report_id: u8,
        duration: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hid_get_idle(hid_class: *mut usbh_hid, buffer: *mut u8) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hid_set_report(
        hid_class: *mut usbh_hid,
        report_type: u8,
        report_id: u8,
        buffer: *mut u8,
        buflen: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hid_get_report(
        hid_class: *mut usbh_hid,
        report_type: u8,
        report_id: u8,
        buffer: *mut u8,
        buflen: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_hid_run(hid_class: *mut usbh_hid);
}
extern "C" {
    pub fn usbh_hid_stop(hid_class: *mut usbh_hid);
}
#[repr(u8)]
#[doc = " Enumeration of MIDI code index number"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MidiCodeIndexNumber {
    MIDI_CIN_MISC = 0,
    MIDI_CIN_CABLE_EVENT = 1,
    #[doc = "< 2 byte system common message e.g MTC, SongSelect"]
    MIDI_CIN_SYSCOM_2BYTE = 2,
    #[doc = "< 3 byte system common message e.g SPP"]
    MIDI_CIN_SYSCOM_3BYTE = 3,
    #[doc = "< SysEx starts or continue"]
    MIDI_CIN_SYSEX_START = 4,
    #[doc = "< SysEx ends with 1 data, or 1 byte system common message"]
    MIDI_CIN_SYSEX_END_1BYTE = 5,
    #[doc = "< SysEx ends with 2 data"]
    MIDI_CIN_SYSEX_END_2BYTE = 6,
    #[doc = "< SysEx ends with 3 data"]
    MIDI_CIN_SYSEX_END_3BYTE = 7,
    MIDI_CIN_NOTE_OFF = 8,
    MIDI_CIN_NOTE_ON = 9,
    MIDI_CIN_POLY_KEYPRESS = 10,
    MIDI_CIN_CONTROL_CHANGE = 11,
    MIDI_CIN_PROGRAM_CHANGE = 12,
    MIDI_CIN_CHANNEL_PRESSURE = 13,
    MIDI_CIN_PITCH_BEND_CHANGE = 14,
    MIDI_CIN_1BYTE_DATA = 15,
}
#[repr(u8)]
#[doc = " Enumeration of MIDI types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MidiType {
    #[doc = "< For notifying errors"]
    InvalidType = 0,
    #[doc = "< Note Off"]
    NoteOff = 128,
    #[doc = "< Note On"]
    NoteOn = 144,
    #[doc = "< Polyphonic AfterTouch"]
    AfterTouchPoly = 160,
    #[doc = "< Control Change / Channel Mode"]
    ControlChange = 176,
    #[doc = "< Program Change"]
    ProgramChange = 192,
    #[doc = "< Channel (monophonic) AfterTouch"]
    AfterTouchChannel = 208,
    #[doc = "< Pitch Bend"]
    PitchBend = 224,
    #[doc = "< System Exclusive"]
    SystemExclusive = 240,
    #[doc = "< System Common - MIDI Time Code Quarter Frame"]
    TimeCodeQuarterFrame = 241,
    #[doc = "< System Common - Song Position Pointer"]
    SongPosition = 242,
    #[doc = "< System Common - Song Select"]
    SongSelect = 243,
    #[doc = "< System Common - Tune Request"]
    TuneRequest = 246,
    #[doc = "< System Real Time - Timing Clock"]
    Clock = 248,
    #[doc = "< System Real Time - Start"]
    Start = 250,
    #[doc = "< System Real Time - Continue"]
    Continue = 251,
    #[doc = "< System Real Time - Stop"]
    Stop = 252,
    #[doc = "< System Real Time - Active Sensing"]
    ActiveSensing = 254,
    #[doc = "< System Real Time - System Reset"]
    SystemReset = 255,
}
#[repr(u8)]
#[doc = " Enumeration of Thru filter modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MidiFilterMode {
    #[doc = "< Thru disabled (nothing passes through)."]
    Off = 0,
    #[doc = "< Fully enabled Thru (every incoming message is sent back)."]
    Full = 1,
    #[doc = "< Only the messages on the Input Channel will be sent back."]
    SameChannel = 2,
    #[doc = "< All the messages but the ones on the Input Channel will be sent back."]
    DifferentChannel = 3,
}
#[repr(u8)]
#[doc = " \\brief Enumeration of Control Change command numbers.\nSee the detailed controllers numbers & description here:\nhttp://www.somascape.org/midi/tech/spec.html#ctrlnums"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum MidiControlChangeNumber {
    BankSelect = 0,
    ModulationWheel = 1,
    BreathController = 2,
    FootController = 4,
    PortamentoTime = 5,
    DataEntry = 6,
    ChannelVolume = 7,
    Balance = 8,
    Pan = 10,
    ExpressionController = 11,
    EffectControl1 = 12,
    EffectControl2 = 13,
    GeneralPurposeController1 = 16,
    GeneralPurposeController2 = 17,
    GeneralPurposeController3 = 18,
    GeneralPurposeController4 = 19,
    Sustain = 64,
    Portamento = 65,
    Sostenuto = 66,
    SoftPedal = 67,
    Legato = 68,
    Hold = 69,
    #[doc = "< Synth: Sound Variation   FX: Exciter On/Off"]
    SoundController1 = 70,
    #[doc = "< Synth: Harmonic Content  FX: Compressor On/Off"]
    SoundController2 = 71,
    #[doc = "< Synth: Release Time      FX: Distortion On/Off"]
    SoundController3 = 72,
    #[doc = "< Synth: Attack Time       FX: EQ On/Off"]
    SoundController4 = 73,
    #[doc = "< Synth: Brightness        FX: Expander On/Off"]
    SoundController5 = 74,
    #[doc = "< Synth: Decay Time        FX: Reverb On/Off"]
    SoundController6 = 75,
    #[doc = "< Synth: Vibrato Rate      FX: Delay On/Off"]
    SoundController7 = 76,
    #[doc = "< Synth: Vibrato Depth     FX: Pitch Transpose On/Off"]
    SoundController8 = 77,
    #[doc = "< Synth: Vibrato Delay     FX: Flange/Chorus On/Off"]
    SoundController9 = 78,
    #[doc = "< Synth: Undefined         FX: Special Effects On/Off"]
    SoundController10 = 79,
    GeneralPurposeController5 = 80,
    GeneralPurposeController6 = 81,
    GeneralPurposeController7 = 82,
    GeneralPurposeController8 = 83,
    PortamentoControl = 84,
    #[doc = "< Reverb send level"]
    Effects1 = 91,
    #[doc = "< Tremolo depth"]
    Effects2 = 92,
    #[doc = "< Chorus send level"]
    Effects3 = 93,
    #[doc = "< Celeste depth"]
    Effects4 = 94,
    #[doc = "< Phaser depth"]
    Effects5 = 95,
    AllSoundOff = 120,
    ResetAllControllers = 121,
    LocalControl = 122,
    AllNotesOff = 123,
    OmniModeOff = 124,
    OmniModeOn = 125,
    MonoModeOn = 126,
    PolyModeOn = 127,
}
#[repr(C, packed)]
pub struct midi_cs_if_ac_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bcdADC: u16,
    pub wTotalLength: u16,
    pub bInCollection: u8,
    pub baInterfaceNr: __IncompleteArrayField<u8>,
}
impl Default for midi_cs_if_ac_header_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct midi_cs_if_ms_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bcdMSC: u16,
    pub wTotalLength: u16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct midi_cs_if_in_jack_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bJackType: u8,
    pub bJackId: u8,
    pub iJack: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct midi_cs_if_out_jack_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bJackType: u8,
    pub bJackId: u8,
    pub bNrInputPins: u8,
    pub baSourceId: u8,
    pub baSourcePin: u8,
    pub iJack: u8,
}
#[repr(C, packed)]
pub struct midi_cs_ep_ms_general_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bNumEmbMIDIJack: u8,
    pub baAssocJackID: __IncompleteArrayField<u8>,
}
impl Default for midi_cs_ep_ms_general_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " MSC Bulk-Only Command Block Wrapper (CBW)"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBW {
    pub dSignature: u32,
    pub dTag: u32,
    pub dDataLength: u32,
    pub bmFlags: u8,
    pub bLUN: u8,
    pub bCBLength: u8,
    pub CB: [u8; 16usize],
}
#[doc = " MSC Bulk-Only Command Status Wrapper (CSW)"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSW {
    pub dSignature: u32,
    pub dTag: u32,
    pub dDataResidue: u32,
    pub bStatus: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_requestsense_s {
    pub opcode: u8,
    pub flags: u8,
    pub reserved: [u8; 2usize],
    pub alloclen: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_fixedsensedata_s {
    pub code: u8,
    pub obsolete: u8,
    pub flags: u8,
    pub info: [u8; 4usize],
    pub len: u8,
    pub cmdinfo: [u8; 4usize],
    pub code2: u8,
    pub qual2: u8,
    pub fru: u8,
    pub key: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scscicmd_inquiry_s {
    pub opcode: u8,
    pub flags: u8,
    pub pagecode: u8,
    pub alloclen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_inquiry_s {
    pub qualtype: u8,
    pub flags1: u8,
    pub version: u8,
    pub flags2: u8,
    pub len: u8,
    pub flags3: u8,
    pub flags4: u8,
    pub flags5: u8,
    pub vendorid: [u8; 8usize],
    pub productid: [u8; 16usize],
    pub revision: [u8; 4usize],
    pub vendor: [u8; 20usize],
    pub flags6: u8,
    pub reserved1: u8,
    pub version1: [u8; 2usize],
    pub version2: [u8; 2usize],
    pub version3: [u8; 2usize],
    pub version4: [u8; 2usize],
    pub version5: [u8; 2usize],
    pub version6: [u8; 2usize],
    pub version7: [u8; 2usize],
    pub version8: [u8; 2usize],
    pub reserved2: [u8; 22usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_modeselect6_s {
    pub opcode: u8,
    pub flags: u8,
    pub reserved: [u8; 2usize],
    pub plen: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_modesense6_s {
    pub opcode: u8,
    pub flags: u8,
    pub pcpgcode: u8,
    pub subpgcode: u8,
    pub alloclen: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_modeparameterhdr6_s {
    pub mdlen: u8,
    pub type_: u8,
    pub param: u8,
    pub bdlen: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_blockdesc_s {
    pub density: u8,
    pub nblocks: [u8; 3usize],
    pub reserved: u8,
    pub blklen: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_pageformat_s {
    pub pgcode: u8,
    pub pglen: u8,
    pub parms: [u8; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_subpageformat_s {
    pub pgcode: u8,
    pub subpgcode: u8,
    pub pglen: [u8; 2usize],
    pub parms: [u8; 1usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_cachingmodepage_s {
    pub pgcode: u8,
    pub len: u8,
    pub flags1: u8,
    pub priority: u8,
    pub dpflen: [u8; 2usize],
    pub minpf: [u8; 2usize],
    pub maxpf: [u8; 2usize],
    pub maxpfc: [u8; 2usize],
    pub flags2: u8,
    pub nsegments: u8,
    pub segsize: [u8; 2usize],
    pub reserved: u8,
    pub obsolete: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_read6_s {
    pub opcode: u8,
    pub mslba: u8,
    pub lslba: [u8; 2usize],
    pub xfrlen: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_write6_s {
    pub opcode: u8,
    pub mslba: u8,
    pub lslba: [u8; 2usize],
    pub xfrlen: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_startstopunit_s {
    pub opcode: u8,
    pub immed: u8,
    pub reserved: u8,
    pub pcm: u8,
    pub pc: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_preventmediumremoval_s {
    pub opcode: u8,
    pub reserved: [u8; 3usize],
    pub prevent: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_readformatcapcacities_s {
    pub opcode: u8,
    pub reserved: [u8; 6usize],
    pub alloclen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_readformatcapacities_s {
    pub reserved: [u8; 3usize],
    pub listlen: u8,
    pub nblocks: [u8; 4usize],
    pub type_: u8,
    pub blocklen: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_formattedcapacitydesc_s {
    pub nblocks: [u8; 4usize],
    pub type_: u8,
    pub param: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_readcapacity10_s {
    pub opcode: u8,
    pub reserved1: u8,
    pub lba: [u8; 4usize],
    pub reserved2: [u8; 2usize],
    pub pmi: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_readcapacity10_s {
    pub lba: [u8; 4usize],
    pub blklen: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_read10_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub groupno: u8,
    pub xfrlen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_write10_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub groupno: u8,
    pub xfrlen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_verify10_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub groupno: u8,
    pub len: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_synchronizecache10_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub groupno: u8,
    pub len: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_modeselect10_s {
    pub opcode: u8,
    pub flags: u8,
    pub reserved: [u8; 5usize],
    pub parmlen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsiresp_modeparameterhdr10_s {
    pub mdlen: [u8; 2usize],
    pub type_: u8,
    pub param: u8,
    pub reserved: [u8; 2usize],
    pub bdlen: [u8; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_modesense10_s {
    pub opcode: u8,
    pub flags: u8,
    pub pcpgcode: u8,
    pub subpgcode: u8,
    pub reserved: [u8; 3usize],
    pub alloclen: [u8; 2usize],
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_readcapacity16_s {
    pub opcode: u8,
    pub action: u8,
    pub lba: [u8; 8usize],
    pub len: [u8; 4usize],
    pub reserved: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_read12_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub xfrlen: [u8; 4usize],
    pub groupno: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_write12_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub xfrlen: [u8; 4usize],
    pub groupno: u8,
    pub control: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct scsicmd_verify12_s {
    pub opcode: u8,
    pub flags: u8,
    pub lba: [u8; 4usize],
    pub len: [u8; 4usize],
    pub groupno: u8,
    pub control: u8,
}
extern "C" {
    pub fn usbd_msc_init_intf(
        busid: u8,
        intf: *mut usbd_interface,
        out_ep: u8,
        in_ep: u8,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_msc_get_cap(busid: u8, lun: u8, block_num: *mut u32, block_size: *mut u32);
}
extern "C" {
    pub fn usbd_msc_sector_read(
        busid: u8,
        lun: u8,
        sector: u32,
        buffer: *mut u8,
        length: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbd_msc_sector_write(
        busid: u8,
        lun: u8,
        sector: u32,
        buffer: *mut u8,
        length: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbd_msc_set_readonly(busid: u8, readonly: bool);
}
extern "C" {
    pub fn usbd_msc_set_popup(busid: u8) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_msc {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkin_urb: usbh_urb,
    pub bulkout_urb: usbh_urb,
    pub intf: u8,
    pub sdchar: u8,
    pub blocknum: u32,
    pub blocksize: u16,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_msc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_msc_modeswitch_config {
    pub name: *const ::core::ffi::c_char,
    pub vid: u16,
    pub pid: u16,
    pub message_content: *const u8,
}
impl Default for usbh_msc_modeswitch_config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_msc_modeswitch_enable(config: *mut usbh_msc_modeswitch_config);
}
extern "C" {
    pub fn usbh_msc_scsi_write10(
        msc_class: *mut usbh_msc,
        start_sector: u32,
        buffer: *const u8,
        nsectors: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_msc_scsi_read10(
        msc_class: *mut usbh_msc,
        start_sector: u32,
        buffer: *const u8,
        nsectors: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_msc_run(msc_class: *mut usbh_msc);
}
extern "C" {
    pub fn usbh_msc_stop(msc_class: *mut usbh_msc);
}
extern "C" {
    pub fn usbd_xxx_init_intf(busid: u8, intf: *mut usbd_interface) -> *mut usbd_interface;
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_xxx {
    pub hport: *mut usbh_hubport,
    pub xxxin: *mut usb_endpoint_descriptor,
    pub xxxout: *mut usb_endpoint_descriptor,
    pub xxxin_urb: usbh_urb,
    pub xxxout_urb: usbh_urb,
    pub intf: u8,
    pub minor: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_xxx {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_xxx_run(xxx_class: *mut usbh_xxx);
}
extern "C" {
    pub fn usbh_xxx_stop(xxx_class: *mut usbh_xxx);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_asix {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub intin: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub intin_urb: usbh_urb,
    pub intf: u8,
    pub name: *mut ::core::ffi::c_char,
    pub phy_addr: u8,
    pub embd_phy: u8,
    pub chipcode: u8,
    pub mac_capabilities: u16,
    pub connect_status: bool,
    pub mac: [u8; 6usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_asix {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_asix_get_connect_status(asix_class: *mut usbh_asix) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_asix_run(asix_class: *mut usbh_asix);
}
extern "C" {
    pub fn usbh_asix_stop(asix_class: *mut usbh_asix);
}
extern "C" {
    pub fn usbh_asix_get_eth_txbuf() -> *mut u8;
}
extern "C" {
    pub fn usbh_asix_eth_output(buflen: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_asix_eth_input(buf: *mut u8, buflen: u32);
}
extern "C" {
    pub fn usbh_asix_rx_thread(argument: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_rtl8152 {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub intin: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub intin_urb: usbh_urb,
    pub intf: u8,
    pub mac: [u8; 6usize],
    pub connect_status: bool,
    pub speed: [u32; 2usize],
    pub version: u8,
    pub eee_adv: u8,
    pub eee_en: u8,
    pub supports_gmii: u8,
    pub min_mtu: u16,
    pub max_mtu: u16,
    pub ocp_base: u16,
    pub saved_wolopts: u32,
    pub rx_buf_sz: u32,
    pub rtl_ops: usbh_rtl8152_rtl_ops,
    pub user_data: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_rtl8152_rtl_ops {
    pub init: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub enable:
        ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152) -> ::core::ffi::c_int>,
    pub disable: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub up: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub down: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub unload: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub in_nway: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152) -> bool>,
    pub hw_phy_cfg: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
    pub autosuspend_en:
        ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152, enable: bool)>,
    pub change_mtu: ::core::option::Option<unsafe extern "C" fn(tp: *mut usbh_rtl8152)>,
}
impl Default for usbh_rtl8152 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_rtl8152_get_connect_status(rtl8152_class: *mut usbh_rtl8152) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_rtl8152_run(rtl8152_class: *mut usbh_rtl8152);
}
extern "C" {
    pub fn usbh_rtl8152_stop(rtl8152_class: *mut usbh_rtl8152);
}
extern "C" {
    pub fn usbh_rtl8152_get_eth_txbuf() -> *mut u8;
}
extern "C" {
    pub fn usbh_rtl8152_eth_output(buflen: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_rtl8152_eth_input(buf: *mut u8, buflen: u32);
}
extern "C" {
    pub fn usbh_rtl8152_rx_thread(argument: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_ch34x {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub line_coding: cdc_line_coding,
    pub intf: u8,
    pub minor: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_ch34x {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_ch34x_set_line_coding(
        ch34x_class: *mut usbh_ch34x,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ch34x_get_line_coding(
        ch34x_class: *mut usbh_ch34x,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ch34x_set_line_state(
        ch34x_class: *mut usbh_ch34x,
        dtr: bool,
        rts: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ch34x_bulk_in_transfer(
        ch34x_class: *mut usbh_ch34x,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ch34x_bulk_out_transfer(
        ch34x_class: *mut usbh_ch34x,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ch34x_run(ch34x_class: *mut usbh_ch34x);
}
extern "C" {
    pub fn usbh_ch34x_stop(ch34x_class: *mut usbh_ch34x);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_cp210x {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub line_coding: cdc_line_coding,
    pub intf: u8,
    pub minor: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_cp210x {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_cp210x_set_line_coding(
        ftdi_class: *mut usbh_cp210x,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cp210x_get_line_coding(
        ftdi_class: *mut usbh_cp210x,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cp210x_set_line_state(
        ftdi_class: *mut usbh_cp210x,
        dtr: bool,
        rts: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cp210x_bulk_in_transfer(
        cp210x_class: *mut usbh_cp210x,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cp210x_bulk_out_transfer(
        cp210x_class: *mut usbh_cp210x,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_cp210x_run(cp210x_class: *mut usbh_cp210x);
}
extern "C" {
    pub fn usbh_cp210x_stop(cp210x_class: *mut usbh_cp210x);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_ftdi {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub line_coding: cdc_line_coding,
    pub intf: u8,
    pub minor: u8,
    pub modem_status: [u8; 2usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_ftdi {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_ftdi_set_line_coding(
        ftdi_class: *mut usbh_ftdi,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ftdi_get_line_coding(
        ftdi_class: *mut usbh_ftdi,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ftdi_set_line_state(
        ftdi_class: *mut usbh_ftdi,
        dtr: bool,
        rts: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ftdi_bulk_in_transfer(
        ftdi_class: *mut usbh_ftdi,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ftdi_bulk_out_transfer(
        ftdi_class: *mut usbh_ftdi,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_ftdi_run(ftdi_class: *mut usbh_ftdi);
}
extern "C" {
    pub fn usbh_ftdi_stop(ftdi_class: *mut usbh_ftdi);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_pl2303 {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkout_urb: usbh_urb,
    pub bulkin_urb: usbh_urb,
    pub linecoding: cdc_line_coding,
    pub intf: u8,
    pub minor: u8,
    pub chiptype: u8,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_pl2303 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_pl2303_set_line_coding(
        pl2303_class: *mut usbh_pl2303,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_pl2303_get_line_coding(
        pl2303_class: *mut usbh_pl2303,
        line_coding: *mut cdc_line_coding,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_pl2303_set_line_state(
        pl2303_class: *mut usbh_pl2303,
        dtr: bool,
        rts: bool,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_pl2303_bulk_in_transfer(
        pl2303_class: *mut usbh_pl2303,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_pl2303_bulk_out_transfer(
        pl2303_class: *mut usbh_pl2303,
        buffer: *mut u8,
        buflen: u32,
        timeout: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_pl2303_run(pl2303_class: *mut usbh_pl2303);
}
extern "C" {
    pub fn usbh_pl2303_stop(pl2303_class: *mut usbh_pl2303);
}
#[doc = " @brief The payload header structure."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct video_payload_header {
    #[doc = "< The payload header length."]
    pub bHeaderLength: u8,
    pub headerInfoUnion: video_payload_header__bindgen_ty_1,
    #[doc = "< Presentation time stamp (PTS) field."]
    pub dwPresentationTime: u32,
    #[doc = "< Source clock reference (SCR) field."]
    pub bSourceClockReference: [u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union video_payload_header__bindgen_ty_1 {
    #[doc = "< The payload header bitmap field."]
    pub bmheaderInfo: u8,
    pub headerInfoBits: video_payload_header__bindgen_ty_1__bindgen_ty_1,
    pub headerInfoBitmap: video_payload_header__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_payload_header__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_payload_header__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frameIdentifier(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frameIdentifier(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn endOfFrame(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_endOfFrame(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn presentationTimeStamp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_presentationTimeStamp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sourceClockReference(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sourceClockReference(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stillImage(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stillImage(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errorBit(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_errorBit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn endOfHeader(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_endOfHeader(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frameIdentifier: u8,
        endOfFrame: u8,
        presentationTimeStamp: u8,
        sourceClockReference: u8,
        reserved: u8,
        stillImage: u8,
        errorBit: u8,
        endOfHeader: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frameIdentifier: u8 = unsafe { ::core::mem::transmute(frameIdentifier) };
            frameIdentifier as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let endOfFrame: u8 = unsafe { ::core::mem::transmute(endOfFrame) };
            endOfFrame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let presentationTimeStamp: u8 =
                unsafe { ::core::mem::transmute(presentationTimeStamp) };
            presentationTimeStamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sourceClockReference: u8 = unsafe { ::core::mem::transmute(sourceClockReference) };
            sourceClockReference as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let stillImage: u8 = unsafe { ::core::mem::transmute(stillImage) };
            stillImage as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let errorBit: u8 = unsafe { ::core::mem::transmute(errorBit) };
            errorBit as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let endOfHeader: u8 = unsafe { ::core::mem::transmute(endOfHeader) };
            endOfHeader as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_payload_header__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_payload_header__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn FID(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FID(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EOI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EOI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PTS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SCR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SCR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RES(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RES(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EOH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EOH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FID: u8,
        EOI: u8,
        PTS: u8,
        SCR: u8,
        RES: u8,
        STI: u8,
        ERR: u8,
        EOH: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FID: u8 = unsafe { ::core::mem::transmute(FID) };
            FID as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EOI: u8 = unsafe { ::core::mem::transmute(EOI) };
            EOI as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PTS: u8 = unsafe { ::core::mem::transmute(PTS) };
            PTS as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SCR: u8 = unsafe { ::core::mem::transmute(SCR) };
            SCR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RES: u8 = unsafe { ::core::mem::transmute(RES) };
            RES as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STI: u8 = unsafe { ::core::mem::transmute(STI) };
            STI as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EOH: u8 = unsafe { ::core::mem::transmute(EOH) };
            EOH as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for video_payload_header__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for video_payload_header {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The Video probe and commit controls structure."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct video_probe_and_commit_controls {
    pub hintUnion: video_probe_and_commit_controls__bindgen_ty_1,
    pub hintUnion1: video_probe_and_commit_controls__bindgen_ty_2,
    #[doc = "< Video format index from a format descriptor."]
    pub bFormatIndex: u8,
    #[doc = "< Video frame index from a frame descriptor."]
    pub bFrameIndex: u8,
    #[doc = "< Frame interval in 100ns units."]
    pub dwFrameInterval: u32,
    #[doc = "< Key frame rate in key-frame per video-frame units."]
    pub wKeyFrameRate: u16,
    #[doc = "< PFrame rate in PFrame/key frame units."]
    pub wPFrameRate: u16,
    #[doc = "< Compression quality control in abstract units 0U (lowest) to 10000U (highest)."]
    pub wCompQuality: u16,
    #[doc = "< Window size for average bit rate control."]
    pub wCompWindowSize: u16,
    #[doc = "< Internal video streaming interface latency in ms from video data capture to presentation on\nthe USB."]
    pub wDelay: u16,
    #[doc = "< Maximum video frame or codec-specific segment size in bytes."]
    pub dwMaxVideoFrameSize: u32,
    #[doc = "< Specifies the maximum number of bytes that the device can transmit or\nreceive in a single payload transfer."]
    pub dwMaxPayloadTransferSize: u32,
    #[doc = "< The device clock frequency in Hz for the specified format. This specifies the\nunits used for the time information fields in the Video Payload Headers in the data\nstream."]
    pub dwClockFrequency: u32,
    #[doc = "< Bit-field control supporting the following values: D0 Frame ID, D1 EOF."]
    pub bmFramingInfo: u8,
    #[doc = "< The preferred payload format version supported by the host or device for the\nspecified bFormatIndex value."]
    pub bPreferedVersion: u8,
    #[doc = "< The minimum payload format version supported by the device for the specified bFormatIndex\nvalue."]
    pub bMinVersion: u8,
    #[doc = "< The maximum payload format version supported by the device for the specified bFormatIndex\nvalue."]
    pub bMaxVersion: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union video_probe_and_commit_controls__bindgen_ty_1 {
    #[doc = "< Bit-field control indicating to the function what fields shall be kept fixed."]
    pub bmHint: u8,
    pub hintBitmap: video_probe_and_commit_controls__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_probe_and_commit_controls__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_probe_and_commit_controls__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn dwFrameInterval(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dwFrameInterval(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wKeyFrameRate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wKeyFrameRate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wPFrameRate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wPFrameRate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wCompQuality(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wCompQuality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wCompWindowSize(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wCompWindowSize(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dwFrameInterval: u8,
        wKeyFrameRate: u8,
        wPFrameRate: u8,
        wCompQuality: u8,
        wCompWindowSize: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dwFrameInterval: u8 = unsafe { ::core::mem::transmute(dwFrameInterval) };
            dwFrameInterval as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wKeyFrameRate: u8 = unsafe { ::core::mem::transmute(wKeyFrameRate) };
            wKeyFrameRate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let wPFrameRate: u8 = unsafe { ::core::mem::transmute(wPFrameRate) };
            wPFrameRate as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wCompQuality: u8 = unsafe { ::core::mem::transmute(wCompQuality) };
            wCompQuality as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wCompWindowSize: u8 = unsafe { ::core::mem::transmute(wCompWindowSize) };
            wCompWindowSize as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for video_probe_and_commit_controls__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union video_probe_and_commit_controls__bindgen_ty_2 {
    #[doc = "< Bit-field control indicating to the function what fields shall be kept fixed."]
    pub bmHint: u8,
    pub hintBitmap: video_probe_and_commit_controls__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_probe_and_commit_controls__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_probe_and_commit_controls__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for video_probe_and_commit_controls__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for video_probe_and_commit_controls {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The Video still probe and still commit controls structure."]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_still_probe_and_commit_controls {
    #[doc = "< Video format index from a format descriptor."]
    pub bFormatIndex: u8,
    #[doc = "< Video frame index from a frame descriptor."]
    pub bFrameIndex: u8,
    #[doc = "< Compression index from a frame descriptor."]
    pub bCompressionIndex: u8,
    #[doc = "< Maximum still image size in bytes."]
    pub dwMaxVideoFrameSize: u32,
    #[doc = "< Specifies the maximum number of bytes that the device can transmit or\nreceive in a single payload transfer."]
    pub dwMaxPayloadTransferSize: u32,
}
#[repr(C, packed)]
pub struct video_cs_if_vc_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bcdUVC: u16,
    pub wTotalLength: u16,
    pub dwClockFrequency: u32,
    pub bInCollection: u8,
    pub baInterfaceNr: __IncompleteArrayField<u8>,
}
impl Default for video_cs_if_vc_header_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct video_cs_if_vc_input_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub iTerminal: u8,
    pub wObjectiveFocalLenMin: u16,
    pub wObjectiveFocalLenMax: u16,
    pub wOcularFocalLength: u16,
    pub bControlSize: u8,
    pub bmaControls: __IncompleteArrayField<u8>,
}
impl Default for video_cs_if_vc_input_terminal_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vc_processing_unit_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bUnitID: u8,
    pub bSourceID: u8,
    pub wMaxMultiplier: u16,
    pub bControlSize: u8,
    pub iProcessing: u8,
    pub bmVideoStandards: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vc_output_terminal_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bTerminalID: u8,
    pub wTerminalType: u16,
    pub bAssocTerminal: u8,
    pub bSourceID: u8,
    pub iTerminal: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vc_extension_unit_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bUnitID: u8,
    pub guidExtensionCode: [u8; 16usize],
    pub bNumControls: u8,
    pub bNrInPins: u8,
    pub bControlSize: u8,
    pub iExtension: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_ep_vc_ep_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub wMaxTransferSize: u16,
}
#[repr(C, packed)]
pub struct video_cs_if_vs_input_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bNumFormats: u8,
    pub wTotalLength: u16,
    pub bEndpointAddress: u8,
    pub bmInfo: u8,
    pub bTerminalLink: u8,
    pub bStillCaptureMethod: u8,
    pub bTriggerSupport: u8,
    pub bTriggerUsage: u8,
    pub bControlSize: u8,
    pub bmaControls: __IncompleteArrayField<u8>,
}
impl Default for video_cs_if_vs_input_header_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct video_cs_if_vs_output_header_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bNumFormats: u8,
    pub wTotalLength: u16,
    pub bEndpointAddress: u8,
    pub bTerminalLink: u8,
    pub bControlSize: u8,
    pub bmaControls: __IncompleteArrayField<u8>,
}
impl Default for video_cs_if_vs_output_header_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vs_format_uncompressed_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFormatIndex: u8,
    pub bNumFrameDescriptors: u8,
    pub guidFormat: [u8; 16usize],
    pub bBitsPerPixel: u8,
    pub bDefaultFrameIndex: u8,
    pub bAspectRatioX: u8,
    pub bAspectRatioY: u8,
    pub bmInterlaceFlags: u8,
    pub bCopyProtect: u8,
}
#[repr(C, packed)]
pub struct video_cs_if_vs_frame_uncompressed_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFrameIndex: u8,
    pub bmCapabilities: u8,
    pub wWidth: u16,
    pub wHeight: u16,
    pub dwMinBitRate: u32,
    pub dwMaxBitRate: u32,
    pub dwMaxVideoFrameBufferSize: u32,
    pub dwDefaultFrameInterval: u32,
    pub bFrameIntervalType: u8,
    pub dwFrameInterval: __IncompleteArrayField<u32>,
}
impl Default for video_cs_if_vs_frame_uncompressed_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vs_format_mjpeg_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFormatIndex: u8,
    pub bNumFrameDescriptors: u8,
    pub bmFlags: u8,
    pub bDefaultFrameIndex: u8,
    pub bAspectRatioX: u8,
    pub bAspectRatioY: u8,
    pub bmInterlaceFlags: u8,
    pub bCopyProtect: u8,
}
#[repr(C, packed)]
pub struct video_cs_if_vs_frame_mjpeg_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFrameIndex: u8,
    pub bmCapabilities: u8,
    pub wWidth: u16,
    pub wHeight: u16,
    pub dwMinBitRate: u32,
    pub dwMaxBitRate: u32,
    pub dwMaxVideoFrameBufferSize: u32,
    pub dwDefaultFrameInterval: u32,
    pub bFrameIntervalType: u8,
    pub dwFrameInterval: __IncompleteArrayField<u32>,
}
impl Default for video_cs_if_vs_frame_mjpeg_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vs_format_h26x_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFormatIndex: u8,
    pub bNumFrameDescriptors: u8,
    pub guidFormat: [u8; 16usize],
    pub bBitsPerPixel: u8,
    pub bDefaultFrameIndex: u8,
    pub bAspectRatioX: u8,
    pub bAspectRatioY: u8,
    pub bmInterfaceFlags: u8,
    pub bCopyProtect: u8,
    pub bVariableSize: u8,
}
#[repr(C, packed)]
pub struct video_cs_if_vs_frame_h26x_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bFrameIndex: u8,
    pub bmCapabilities: u8,
    pub wWidth: u16,
    pub wHeight: u16,
    pub dwMinBitRate: u32,
    pub dwMaxBitRate: u32,
    pub dwDefaultFrameInterval: u32,
    pub bFrameIntervalType: u8,
    pub dwBytesPerLine: u32,
    pub dwFrameInterval: __IncompleteArrayField<u32>,
}
impl Default for video_cs_if_vs_frame_h26x_descriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_cs_if_vs_colorformat_descriptor {
    pub bLength: u8,
    pub bDescriptorType: u8,
    pub bDescriptorSubType: u8,
    pub bColorPrimaries: u8,
    pub bXferCharacteristics: u8,
    pub bMatrixCoefficients: u8,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_vc_input_terminal_bmcontrol_bitmap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl video_vc_input_terminal_bmcontrol_bitmap {
    #[inline]
    pub fn scanning_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scanning_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_exposure_mode(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_exposure_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_exposure_priority(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_exposure_priority(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exposure_time_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exposure_time_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exposure_time_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exposure_time_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_focus_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_focus_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iris_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iris_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn iris_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iris_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zoom_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zoom_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zoom_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zoom_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pantilt_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pantilt_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pantilt_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pantilt_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn roll_absolute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roll_absolute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn roll_relative(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_roll_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_auto(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_focus_auto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pricvcy(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pricvcy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scanning_mode: u32,
        auto_exposure_mode: u32,
        auto_exposure_priority: u32,
        exposure_time_absolute: u32,
        exposure_time_relative: u32,
        focus_absolute: u32,
        focus_relative: u32,
        iris_absolute: u32,
        iris_relative: u32,
        zoom_absolute: u32,
        zoom_relative: u32,
        pantilt_absolute: u32,
        pantilt_relative: u32,
        roll_absolute: u32,
        roll_relative: u32,
        reserved: u32,
        focus_auto: u32,
        pricvcy: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scanning_mode: u32 = unsafe { ::core::mem::transmute(scanning_mode) };
            scanning_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auto_exposure_mode: u32 = unsafe { ::core::mem::transmute(auto_exposure_mode) };
            auto_exposure_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let auto_exposure_priority: u32 =
                unsafe { ::core::mem::transmute(auto_exposure_priority) };
            auto_exposure_priority as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let exposure_time_absolute: u32 =
                unsafe { ::core::mem::transmute(exposure_time_absolute) };
            exposure_time_absolute as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exposure_time_relative: u32 =
                unsafe { ::core::mem::transmute(exposure_time_relative) };
            exposure_time_relative as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let focus_absolute: u32 = unsafe { ::core::mem::transmute(focus_absolute) };
            focus_absolute as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let focus_relative: u32 = unsafe { ::core::mem::transmute(focus_relative) };
            focus_relative as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let iris_absolute: u32 = unsafe { ::core::mem::transmute(iris_absolute) };
            iris_absolute as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let iris_relative: u32 = unsafe { ::core::mem::transmute(iris_relative) };
            iris_relative as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let zoom_absolute: u32 = unsafe { ::core::mem::transmute(zoom_absolute) };
            zoom_absolute as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let zoom_relative: u32 = unsafe { ::core::mem::transmute(zoom_relative) };
            zoom_relative as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pantilt_absolute: u32 = unsafe { ::core::mem::transmute(pantilt_absolute) };
            pantilt_absolute as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let pantilt_relative: u32 = unsafe { ::core::mem::transmute(pantilt_relative) };
            pantilt_relative as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let roll_absolute: u32 = unsafe { ::core::mem::transmute(roll_absolute) };
            roll_absolute as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let roll_relative: u32 = unsafe { ::core::mem::transmute(roll_relative) };
            roll_relative as u64
        });
        __bindgen_bitfield_unit.set(15usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let focus_auto: u32 = unsafe { ::core::mem::transmute(focus_auto) };
            focus_auto as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pricvcy: u32 = unsafe { ::core::mem::transmute(pricvcy) };
            pricvcy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_vc_processing_unit_bmcontrol_bitmap {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl video_vc_processing_unit_bmcontrol_bitmap {
    #[inline]
    pub fn brightness(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_brightness(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn contrast(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_contrast(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn saturation(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_saturation(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sharpness(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sharpness(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gamma(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gamma(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn white_bal_temp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_white_bal_temp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn white_bal_comp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_white_bal_comp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn backlight_comp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_backlight_comp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gain(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gain(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_line_freq(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_power_line_freq(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hue_auto(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hue_auto(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn white_bal_temp_auto(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_white_bal_temp_auto(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn white_bal_comp_auto(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_white_bal_comp_auto(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn digital_mult(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_digital_mult(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn digital_mult_limit(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_digital_mult_limit(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        brightness: u16,
        contrast: u16,
        hue: u16,
        saturation: u16,
        sharpness: u16,
        gamma: u16,
        white_bal_temp: u16,
        white_bal_comp: u16,
        backlight_comp: u16,
        gain: u16,
        power_line_freq: u16,
        hue_auto: u16,
        white_bal_temp_auto: u16,
        white_bal_comp_auto: u16,
        digital_mult: u16,
        digital_mult_limit: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let brightness: u16 = unsafe { ::core::mem::transmute(brightness) };
            brightness as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let contrast: u16 = unsafe { ::core::mem::transmute(contrast) };
            contrast as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hue: u16 = unsafe { ::core::mem::transmute(hue) };
            hue as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let saturation: u16 = unsafe { ::core::mem::transmute(saturation) };
            saturation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sharpness: u16 = unsafe { ::core::mem::transmute(sharpness) };
            sharpness as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gamma: u16 = unsafe { ::core::mem::transmute(gamma) };
            gamma as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let white_bal_temp: u16 = unsafe { ::core::mem::transmute(white_bal_temp) };
            white_bal_temp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let white_bal_comp: u16 = unsafe { ::core::mem::transmute(white_bal_comp) };
            white_bal_comp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let backlight_comp: u16 = unsafe { ::core::mem::transmute(backlight_comp) };
            backlight_comp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let gain: u16 = unsafe { ::core::mem::transmute(gain) };
            gain as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let power_line_freq: u16 = unsafe { ::core::mem::transmute(power_line_freq) };
            power_line_freq as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hue_auto: u16 = unsafe { ::core::mem::transmute(hue_auto) };
            hue_auto as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let white_bal_temp_auto: u16 = unsafe { ::core::mem::transmute(white_bal_temp_auto) };
            white_bal_temp_auto as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let white_bal_comp_auto: u16 = unsafe { ::core::mem::transmute(white_bal_comp_auto) };
            white_bal_comp_auto as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let digital_mult: u16 = unsafe { ::core::mem::transmute(digital_mult) };
            digital_mult as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let digital_mult_limit: u16 = unsafe { ::core::mem::transmute(digital_mult_limit) };
            digital_mult_limit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_camera_capabilities {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_camera_capabilities {
    #[inline]
    pub fn support_get_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_get_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn support_set_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_support_set_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled_by_automatic_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled_by_automatic_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_update_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_update_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_async_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        support_get_request: u8,
        support_set_request: u8,
        disabled_by_automatic_mode: u8,
        auto_update_control: u8,
        async_control: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let support_get_request: u8 = unsafe { ::core::mem::transmute(support_get_request) };
            support_get_request as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let support_set_request: u8 = unsafe { ::core::mem::transmute(support_set_request) };
            support_set_request as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled_by_automatic_mode: u8 =
                unsafe { ::core::mem::transmute(disabled_by_automatic_mode) };
            disabled_by_automatic_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let auto_update_control: u8 = unsafe { ::core::mem::transmute(auto_update_control) };
            auto_update_control as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let async_control: u8 = unsafe { ::core::mem::transmute(async_control) };
            async_control as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct video_autoexposure_mode {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl video_autoexposure_mode {
    #[inline]
    pub fn manual_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_manual_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shutter_priority_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shutter_priority_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn aperture_priority_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_aperture_priority_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        manual_mode: u8,
        auto_mode: u8,
        shutter_priority_mode: u8,
        aperture_priority_mode: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let manual_mode: u8 = unsafe { ::core::mem::transmute(manual_mode) };
            manual_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auto_mode: u8 = unsafe { ::core::mem::transmute(auto_mode) };
            auto_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let shutter_priority_mode: u8 =
                unsafe { ::core::mem::transmute(shutter_priority_mode) };
            shutter_priority_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let aperture_priority_mode: u8 =
                unsafe { ::core::mem::transmute(aperture_priority_mode) };
            aperture_priority_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn usbd_video_init_intf(
        busid: u8,
        intf: *mut usbd_interface,
        dwFrameInterval: u32,
        dwMaxVideoFrameSize: u32,
        dwMaxPayloadTransferSize: u32,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_video_open(busid: u8, intf: u8);
}
extern "C" {
    pub fn usbd_video_close(busid: u8, intf: u8);
}
extern "C" {
    pub fn usbd_video_payload_fill(
        busid: u8,
        input: *mut u8,
        input_len: u32,
        output: *mut u8,
        out_len: *mut u32,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_video_resolution {
    pub wWidth: u16,
    pub wHeight: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usbh_video_format {
    pub frame: [usbh_video_resolution; 12usize],
    pub format_type: u8,
    pub num_of_frames: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_videoframe {
    pub frame_buf: *mut u8,
    pub frame_bufsize: u32,
    pub frame_format: u32,
    pub frame_size: u32,
}
impl Default for usbh_videoframe {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbh_videostreaming {
    pub frame: *mut usbh_videoframe,
    pub frame_format: u32,
    pub bufoffset: u32,
    pub width: u16,
    pub height: u16,
}
impl Default for usbh_videostreaming {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usbh_video {
    pub hport: *mut usbh_hubport,
    pub isoin: *mut usb_endpoint_descriptor,
    pub isoout: *mut usb_endpoint_descriptor,
    pub ctrl_intf: u8,
    pub data_intf: u8,
    pub minor: u8,
    pub probe: video_probe_and_commit_controls,
    pub commit: video_probe_and_commit_controls,
    pub isoin_mps: u16,
    pub isoout_mps: u16,
    pub is_opened: bool,
    pub current_format: u8,
    pub bcdVDC: u16,
    pub num_of_intf_altsettings: u8,
    pub num_of_formats: u8,
    pub format: [usbh_video_format; 3usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_video {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_video_get(
        video_class: *mut usbh_video,
        request: u8,
        intf: u8,
        entity_id: u8,
        cs: u8,
        buf: *mut u8,
        len: u16,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_video_set(
        video_class: *mut usbh_video,
        request: u8,
        intf: u8,
        entity_id: u8,
        cs: u8,
        buf: *mut u8,
        len: u16,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_video_open(
        video_class: *mut usbh_video,
        format_type: u8,
        wWidth: u16,
        wHeight: u16,
        altsetting: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_video_close(video_class: *mut usbh_video) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_video_list_info(video_class: *mut usbh_video);
}
extern "C" {
    pub fn usbh_video_run(video_class: *mut usbh_video);
}
extern "C" {
    pub fn usbh_video_stop(video_class: *mut usbh_video);
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum NDIS_DEVICE_POWER_STATE {
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0 = 1,
    NdisDeviceStateD1 = 2,
    NdisDeviceStateD2 = 3,
    NdisDeviceStateD3 = 4,
    NdisDeviceStateMaximum = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NDIS_PM_WAKE_UP_CAPABILITIES {
    pub MinMagicPacketWakeUp: NDIS_DEVICE_POWER_STATE,
    pub MinPatternWakeUp: NDIS_DEVICE_POWER_STATE,
    pub MinLinkChangeWakeUp: NDIS_DEVICE_POWER_STATE,
}
impl Default for NDIS_PM_WAKE_UP_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type rndis_MessageType_t = u32;
pub type rndis_MessageLength_t = u32;
pub type rndis_RequestId_t = u32;
pub type rndis_MajorVersion_t = u32;
pub type rndis_MinorVersion_t = u32;
pub type rndis_MaxTransferSize_t = u32;
pub type rndis_Status_t = u32;
pub type rndis_DeviceFlags_t = u32;
pub type rndis_Medium_t = u32;
pub type rndis_MaxPacketsPerTransfer_t = u32;
pub type rndis_PacketAlignmentFactor_t = u32;
pub type rndis_AfListOffset_t = u32;
pub type rndis_AfListSize_t = u32;
#[doc = " Remote NDIS Generic Message type"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_generic_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
}
#[doc = " Remote NDIS Initialize Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_initialize_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub MajorVersion: rndis_MajorVersion_t,
    pub MinorVersion: rndis_MinorVersion_t,
    pub MaxTransferSize: rndis_MaxTransferSize_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_initialize_cmplt_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Status: rndis_Status_t,
    pub MajorVersion: rndis_MajorVersion_t,
    pub MinorVersion: rndis_MinorVersion_t,
    pub DeviceFlags: rndis_DeviceFlags_t,
    pub Medium: rndis_Medium_t,
    pub MaxPacketsPerTransfer: rndis_MaxPacketsPerTransfer_t,
    pub MaxTransferSize: rndis_MaxTransferSize_t,
    pub PacketAlignmentFactor: rndis_PacketAlignmentFactor_t,
    pub AfListOffset: rndis_AfListOffset_t,
    pub AfListSize: rndis_AfListSize_t,
}
#[doc = " Remote NDIS Halt Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_halt_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
}
pub type rndis_Oid_t = u32;
pub type rndis_InformationBufferLength_t = u32;
pub type rndis_InformationBufferOffset_t = u32;
pub type rndis_DeviceVcHandle_t = u32;
#[doc = " Remote NDIS Query Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_query_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Oid: rndis_Oid_t,
    pub InformationBufferLength: rndis_InformationBufferLength_t,
    pub InformationBufferOffset: rndis_InformationBufferOffset_t,
    pub DeviceVcHandle: rndis_DeviceVcHandle_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_query_cmplt_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Status: rndis_Status_t,
    pub InformationBufferLength: rndis_InformationBufferLength_t,
    pub InformationBufferOffset: rndis_InformationBufferOffset_t,
}
#[doc = " Remote NDIS Set Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_set_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Oid: rndis_Oid_t,
    pub InformationBufferLength: rndis_InformationBufferLength_t,
    pub InformationBufferOffset: rndis_InformationBufferOffset_t,
    pub DeviceVcHandle: rndis_DeviceVcHandle_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_set_cmplt_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Status: rndis_Status_t,
}
pub type rndis_ParameterNameOffset_t = u32;
pub type rndis_ParameterNameLength_t = u32;
pub type rndis_ParameterType_t = u32;
pub type rndis_ParameterValueOffset_t = u32;
pub type rndis_ParameterValueLength_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_config_parameter_t {
    pub ParameterNameOffset: rndis_ParameterNameOffset_t,
    pub ParameterNameLength: rndis_ParameterNameLength_t,
    pub ParameterType: rndis_ParameterType_t,
    pub ParameterValueOffset: rndis_ParameterValueOffset_t,
    pub ParameterValueLength: rndis_ParameterValueLength_t,
}
pub type rndis_Reserved_t = u32;
#[doc = " Remote NDIS Soft Reset Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_reset_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub Reserved: rndis_Reserved_t,
}
pub type rndis_AddressingReset_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_reset_cmplt_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub Status: rndis_Status_t,
    pub AddressingReset: rndis_AddressingReset_t,
}
#[doc = " Remote NDIS Indicate Status Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_indicate_status_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub Status: rndis_Status_t,
    pub StatusBufferLength: rndis_Status_t,
    pub StatusBufferOffset: rndis_Status_t,
}
pub type rndis_DiagStatus_t = u32;
pub type rndis_ErrorOffset_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_diagnostic_info_t {
    pub DiagStatus: rndis_DiagStatus_t,
    pub ErrorOffset: rndis_ErrorOffset_t,
}
#[doc = " Remote NDIS Keepalive Message"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_keepalive_msg_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_keepalive_cmplt_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub RequestId: rndis_RequestId_t,
    pub Status: rndis_Status_t,
}
#[doc = " Remote NDIS Data Packet"]
pub type rndis_DataOffset_t = u32;
pub type rndis_DataLength_t = u32;
pub type rndis_OOBDataOffset_t = u32;
pub type rndis_OOBDataLength_t = u32;
pub type rndis_NumOOBDataElements_t = u32;
pub type rndis_PerPacketInfoOffset_t = u32;
pub type rndis_PerPacketInfoLength_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_data_packet_t {
    pub MessageType: rndis_MessageType_t,
    pub MessageLength: rndis_MessageLength_t,
    pub DataOffset: rndis_DataOffset_t,
    pub DataLength: rndis_DataLength_t,
    pub OOBDataOffset: rndis_OOBDataOffset_t,
    pub OOBDataLength: rndis_OOBDataLength_t,
    pub NumOOBDataElements: rndis_NumOOBDataElements_t,
    pub PerPacketInfoOffset: rndis_PerPacketInfoOffset_t,
    pub PerPacketInfoLength: rndis_PerPacketInfoLength_t,
    pub DeviceVcHandle: rndis_DeviceVcHandle_t,
    pub Reserved: rndis_Reserved_t,
}
pub type rndis_ClassInformationOffset_t = u32;
pub type rndis_Size_t = u32;
pub type rndis_Type_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rndis_OOB_packet_t {
    pub Size: rndis_Size_t,
    pub Type: rndis_Type_t,
    pub ClassInformationType: rndis_ClassInformationOffset_t,
}
#[repr(u8)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rnids_state_e {
    rndis_uninitialized = 0,
    rndis_initialized = 1,
    rndis_data_initialized = 2,
}
pub use self::rnids_state_e as rndis_state_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct usb_eth_stat_t {
    pub txok: u32,
    pub rxok: u32,
    pub txbad: u32,
    pub rxbad: u32,
}
extern "C" {
    pub fn usbd_rndis_init_intf(
        intf: *mut usbd_interface,
        out_ep: u8,
        in_ep: u8,
        int_ep: u8,
        mac: *mut u8,
    ) -> *mut usbd_interface;
}
extern "C" {
    pub fn usbd_rndis_data_recv_done();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn usbd_rndis_eth_rx() -> *mut pbuf;
}
extern "C" {
    pub fn usbd_rndis_eth_tx(p: *mut pbuf) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_bluetooth {
    pub hport: *mut usbh_hubport,
    pub intf: u8,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub bulkin_urb: usbh_urb,
    pub bulkout_urb: usbh_urb,
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_bluetooth {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_bluetooth_hci_write(
        hci_type: u8,
        buffer: *mut u8,
        buflen: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_bluetooth_hci_read_callback(data: *mut u8, len: u32);
}
extern "C" {
    pub fn usbh_bluetooth_hci_rx_thread(argument: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn usbh_bluetooth_run(bluetooth_class: *mut usbh_bluetooth);
}
extern "C" {
    pub fn usbh_bluetooth_stop(bluetooth_class: *mut usbh_bluetooth);
}
#[repr(C)]
#[derive(Debug)]
pub struct usbh_rndis {
    pub hport: *mut usbh_hubport,
    pub bulkin: *mut usb_endpoint_descriptor,
    pub bulkout: *mut usb_endpoint_descriptor,
    pub intin: *mut usb_endpoint_descriptor,
    pub bulkin_urb: usbh_urb,
    pub bulkout_urb: usbh_urb,
    pub intin_urb: usbh_urb,
    pub ctrl_intf: u8,
    pub data_intf: u8,
    pub minor: u8,
    pub request_id: u32,
    pub tx_offset: u32,
    pub max_transfer_pkts: u32,
    pub max_transfer_size: u32,
    pub link_speed: u32,
    pub connect_status: bool,
    pub mac: [u8; 6usize],
    pub user_data: *mut ::core::ffi::c_void,
}
impl Default for usbh_rndis {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usbh_rndis_get_connect_status(rndis_class: *mut usbh_rndis) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_rndis_keepalive(rndis_class: *mut usbh_rndis) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_rndis_run(rndis_class: *mut usbh_rndis);
}
extern "C" {
    pub fn usbh_rndis_stop(rndis_class: *mut usbh_rndis);
}
extern "C" {
    pub fn usbh_rndis_get_eth_txbuf() -> *mut u8;
}
extern "C" {
    pub fn usbh_rndis_eth_output(buflen: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn usbh_rndis_eth_input(buf: *mut u8, buflen: u32);
}
extern "C" {
    pub fn usbh_rndis_rx_thread(argument: *mut ::core::ffi::c_void);
}
